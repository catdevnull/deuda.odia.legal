var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/big-integer@1.6.52/node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS({
  "node_modules/.pnpm/big-integer@1.6.52/node_modules/big-integer/BigInteger.js"(exports, module) {
    var bigInt = function(undefined2) {
      "use strict";
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v3, radix, alphabet, caseSensitive) {
        if (typeof v3 === "undefined")
          return Integer[0];
        if (typeof radix !== "undefined")
          return +radix === 10 && !alphabet ? parseValue(v3) : parseBase(v3, radix, alphabet, caseSensitive);
        return parseValue(v3);
      }
      function BigInteger(value, sign3) {
        this.value = value;
        this.sign = sign3;
        this.isSmall = false;
      }
      BigInteger.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n2) {
        return -MAX_INT < n2 && n2 < MAX_INT;
      }
      function smallToArray(n2) {
        if (n2 < 1e7)
          return [n2];
        if (n2 < 1e14)
          return [n2 % 1e7, Math.floor(n2 / 1e7)];
        return [n2 % 1e7, Math.floor(n2 / 1e7) % 1e7, Math.floor(n2 / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length3 = arr.length;
        if (length3 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length3) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim(v3) {
        var i4 = v3.length;
        while (v3[--i4] === 0)
          ;
        v3.length = i4 + 1;
      }
      function createArray(length3) {
        var x6 = new Array(length3);
        var i4 = -1;
        while (++i4 < length3) {
          x6[i4] = 0;
        }
        return x6;
      }
      function truncate(n2) {
        if (n2 > 0)
          return Math.floor(n2);
        return Math.ceil(n2);
      }
      function add2(a4, b3) {
        var l_a = a4.length, l_b = b3.length, r3 = new Array(l_a), carry = 0, base2 = BASE, sum2, i4;
        for (i4 = 0; i4 < l_b; i4++) {
          sum2 = a4[i4] + b3[i4] + carry;
          carry = sum2 >= base2 ? 1 : 0;
          r3[i4] = sum2 - carry * base2;
        }
        while (i4 < l_a) {
          sum2 = a4[i4] + carry;
          carry = sum2 === base2 ? 1 : 0;
          r3[i4++] = sum2 - carry * base2;
        }
        if (carry > 0)
          r3.push(carry);
        return r3;
      }
      function addAny(a4, b3) {
        if (a4.length >= b3.length)
          return add2(a4, b3);
        return add2(b3, a4);
      }
      function addSmall(a4, carry) {
        var l3 = a4.length, r3 = new Array(l3), base2 = BASE, sum2, i4;
        for (i4 = 0; i4 < l3; i4++) {
          sum2 = a4[i4] - base2 + carry;
          carry = Math.floor(sum2 / base2);
          r3[i4] = sum2 - carry * base2;
          carry += 1;
        }
        while (carry > 0) {
          r3[i4++] = carry % base2;
          carry = Math.floor(carry / base2);
        }
        return r3;
      }
      BigInteger.prototype.add = function(v3) {
        var n2 = parseValue(v3);
        if (this.sign !== n2.sign) {
          return this.subtract(n2.negate());
        }
        var a4 = this.value, b3 = n2.value;
        if (n2.isSmall) {
          return new BigInteger(addSmall(a4, Math.abs(b3)), this.sign);
        }
        return new BigInteger(addAny(a4, b3), this.sign);
      };
      BigInteger.prototype.plus = BigInteger.prototype.add;
      SmallInteger.prototype.add = function(v3) {
        var n2 = parseValue(v3);
        var a4 = this.value;
        if (a4 < 0 !== n2.sign) {
          return this.subtract(n2.negate());
        }
        var b3 = n2.value;
        if (n2.isSmall) {
          if (isPrecise(a4 + b3))
            return new SmallInteger(a4 + b3);
          b3 = smallToArray(Math.abs(b3));
        }
        return new BigInteger(addSmall(b3, Math.abs(a4)), a4 < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v3) {
        return new NativeBigInt(this.value + parseValue(v3).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract(a4, b3) {
        var a_l = a4.length, b_l = b3.length, r3 = new Array(a_l), borrow = 0, base2 = BASE, i4, difference2;
        for (i4 = 0; i4 < b_l; i4++) {
          difference2 = a4[i4] - borrow - b3[i4];
          if (difference2 < 0) {
            difference2 += base2;
            borrow = 1;
          } else
            borrow = 0;
          r3[i4] = difference2;
        }
        for (i4 = b_l; i4 < a_l; i4++) {
          difference2 = a4[i4] - borrow;
          if (difference2 < 0)
            difference2 += base2;
          else {
            r3[i4++] = difference2;
            break;
          }
          r3[i4] = difference2;
        }
        for (; i4 < a_l; i4++) {
          r3[i4] = a4[i4];
        }
        trim(r3);
        return r3;
      }
      function subtractAny(a4, b3, sign3) {
        var value;
        if (compareAbs(a4, b3) >= 0) {
          value = subtract(a4, b3);
        } else {
          value = subtract(b3, a4);
          sign3 = !sign3;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign3)
            value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger(value, sign3);
      }
      function subtractSmall(a4, b3, sign3) {
        var l3 = a4.length, r3 = new Array(l3), carry = -b3, base2 = BASE, i4, difference2;
        for (i4 = 0; i4 < l3; i4++) {
          difference2 = a4[i4] + carry;
          carry = Math.floor(difference2 / base2);
          difference2 %= base2;
          r3[i4] = difference2 < 0 ? difference2 + base2 : difference2;
        }
        r3 = arrayToSmall(r3);
        if (typeof r3 === "number") {
          if (sign3)
            r3 = -r3;
          return new SmallInteger(r3);
        }
        return new BigInteger(r3, sign3);
      }
      BigInteger.prototype.subtract = function(v3) {
        var n2 = parseValue(v3);
        if (this.sign !== n2.sign) {
          return this.add(n2.negate());
        }
        var a4 = this.value, b3 = n2.value;
        if (n2.isSmall)
          return subtractSmall(a4, Math.abs(b3), this.sign);
        return subtractAny(a4, b3, this.sign);
      };
      BigInteger.prototype.minus = BigInteger.prototype.subtract;
      SmallInteger.prototype.subtract = function(v3) {
        var n2 = parseValue(v3);
        var a4 = this.value;
        if (a4 < 0 !== n2.sign) {
          return this.add(n2.negate());
        }
        var b3 = n2.value;
        if (n2.isSmall) {
          return new SmallInteger(a4 - b3);
        }
        return subtractSmall(b3, Math.abs(a4), a4 >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v3) {
        return new NativeBigInt(this.value - parseValue(v3).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign3 = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign3;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a4, b3) {
        var a_l = a4.length, b_l = b3.length, l3 = a_l + b_l, r3 = createArray(l3), base2 = BASE, product, carry, i4, a_i, b_j;
        for (i4 = 0; i4 < a_l; ++i4) {
          a_i = a4[i4];
          for (var j4 = 0; j4 < b_l; ++j4) {
            b_j = b3[j4];
            product = a_i * b_j + r3[i4 + j4];
            carry = Math.floor(product / base2);
            r3[i4 + j4] = product - carry * base2;
            r3[i4 + j4 + 1] += carry;
          }
        }
        trim(r3);
        return r3;
      }
      function multiplySmall(a4, b3) {
        var l3 = a4.length, r3 = new Array(l3), base2 = BASE, carry = 0, product, i4;
        for (i4 = 0; i4 < l3; i4++) {
          product = a4[i4] * b3 + carry;
          carry = Math.floor(product / base2);
          r3[i4] = product - carry * base2;
        }
        while (carry > 0) {
          r3[i4++] = carry % base2;
          carry = Math.floor(carry / base2);
        }
        return r3;
      }
      function shiftLeft(x6, n2) {
        var r3 = [];
        while (n2-- > 0)
          r3.push(0);
        return r3.concat(x6);
      }
      function multiplyKaratsuba(x6, y4) {
        var n2 = Math.max(x6.length, y4.length);
        if (n2 <= 30)
          return multiplyLong(x6, y4);
        n2 = Math.ceil(n2 / 2);
        var b3 = x6.slice(n2), a4 = x6.slice(0, n2), d3 = y4.slice(n2), c6 = y4.slice(0, n2);
        var ac = multiplyKaratsuba(a4, c6), bd = multiplyKaratsuba(b3, d3), abcd = multiplyKaratsuba(addAny(a4, b3), addAny(c6, d3));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n2)), shiftLeft(bd, 2 * n2));
        trim(product);
        return product;
      }
      function useKaratsuba(l1, l22) {
        return -0.012 * l1 - 0.012 * l22 + 15e-6 * l1 * l22 > 0;
      }
      BigInteger.prototype.multiply = function(v3) {
        var n2 = parseValue(v3), a4 = this.value, b3 = n2.value, sign3 = this.sign !== n2.sign, abs3;
        if (n2.isSmall) {
          if (b3 === 0)
            return Integer[0];
          if (b3 === 1)
            return this;
          if (b3 === -1)
            return this.negate();
          abs3 = Math.abs(b3);
          if (abs3 < BASE) {
            return new BigInteger(multiplySmall(a4, abs3), sign3);
          }
          b3 = smallToArray(abs3);
        }
        if (useKaratsuba(a4.length, b3.length))
          return new BigInteger(multiplyKaratsuba(a4, b3), sign3);
        return new BigInteger(multiplyLong(a4, b3), sign3);
      };
      BigInteger.prototype.times = BigInteger.prototype.multiply;
      function multiplySmallAndArray(a4, b3, sign3) {
        if (a4 < BASE) {
          return new BigInteger(multiplySmall(b3, a4), sign3);
        }
        return new BigInteger(multiplyLong(b3, smallToArray(a4)), sign3);
      }
      SmallInteger.prototype._multiplyBySmall = function(a4) {
        if (isPrecise(a4.value * this.value)) {
          return new SmallInteger(a4.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a4.value), smallToArray(Math.abs(this.value)), this.sign !== a4.sign);
      };
      BigInteger.prototype._multiplyBySmall = function(a4) {
        if (a4.value === 0)
          return Integer[0];
        if (a4.value === 1)
          return this;
        if (a4.value === -1)
          return this.negate();
        return multiplySmallAndArray(Math.abs(a4.value), this.value, this.sign !== a4.sign);
      };
      SmallInteger.prototype.multiply = function(v3) {
        return parseValue(v3)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v3) {
        return new NativeBigInt(this.value * parseValue(v3).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a4) {
        var l3 = a4.length, r3 = createArray(l3 + l3), base2 = BASE, product, carry, i4, a_i, a_j;
        for (i4 = 0; i4 < l3; i4++) {
          a_i = a4[i4];
          carry = 0 - a_i * a_i;
          for (var j4 = i4; j4 < l3; j4++) {
            a_j = a4[j4];
            product = 2 * (a_i * a_j) + r3[i4 + j4] + carry;
            carry = Math.floor(product / base2);
            r3[i4 + j4] = product - carry * base2;
          }
          r3[i4 + l3] = carry;
        }
        trim(r3);
        return r3;
      }
      BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value))
          return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v3) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a4, b3) {
        var a_l = a4.length, b_l = b3.length, base2 = BASE, result = createArray(b3.length), divisorMostSignificantDigit = b3[b_l - 1], lambda = Math.ceil(base2 / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a4, lambda), divisor = multiplySmall(b3, lambda), quotientDigit, shift, carry, borrow, i4, l3, q4;
        if (remainder.length <= a_l)
          remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base2 - 1;
          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base2 + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l3 = divisor.length;
          for (i4 = 0; i4 < l3; i4++) {
            carry += quotientDigit * divisor[i4];
            q4 = Math.floor(carry / base2);
            borrow += remainder[shift + i4] - (carry - q4 * base2);
            carry = q4;
            if (borrow < 0) {
              remainder[shift + i4] = borrow + base2;
              borrow = -1;
            } else {
              remainder[shift + i4] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i4 = 0; i4 < l3; i4++) {
              carry += remainder[shift + i4] - base2 + divisor[i4];
              if (carry < 0) {
                remainder[shift + i4] = carry + base2;
                carry = 0;
              } else {
                remainder[shift + i4] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a4, b3) {
        var a_l = a4.length, b_l = b3.length, result = [], part = [], base2 = BASE, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a4[--a_l]);
          trim(part);
          if (compareAbs(part, b3) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base2 + part[xlen - 2];
          highy = b3[b_l - 1] * base2 + b3[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base2;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b3, guess);
            if (compareAbs(check, part) <= 0)
              break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length3 = value.length, quotient = createArray(length3), base2 = BASE, i4, q4, remainder, divisor;
        remainder = 0;
        for (i4 = length3 - 1; i4 >= 0; --i4) {
          divisor = remainder * base2 + value[i4];
          q4 = truncate(divisor / lambda);
          remainder = divisor - q4 * lambda;
          quotient[i4] = q4 | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v3) {
        var value, n2 = parseValue(v3);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n2.value), new NativeBigInt(self2.value % n2.value)];
        }
        var a4 = self2.value, b3 = n2.value;
        var quotient;
        if (b3 === 0)
          throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n2.isSmall) {
            return [new SmallInteger(truncate(a4 / b3)), new SmallInteger(a4 % b3)];
          }
          return [Integer[0], self2];
        }
        if (n2.isSmall) {
          if (b3 === 1)
            return [self2, Integer[0]];
          if (b3 == -1)
            return [self2.negate(), Integer[0]];
          var abs3 = Math.abs(b3);
          if (abs3 < BASE) {
            value = divModSmall(a4, abs3);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign)
              remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n2.sign)
                quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger(quotient, self2.sign !== n2.sign), new SmallInteger(remainder)];
          }
          b3 = smallToArray(abs3);
        }
        var comparison = compareAbs(a4, b3);
        if (comparison === -1)
          return [Integer[0], self2];
        if (comparison === 0)
          return [Integer[self2.sign === n2.sign ? 1 : -1], Integer[0]];
        if (a4.length + b3.length <= 200)
          value = divMod1(a4, b3);
        else
          value = divMod2(a4, b3);
        quotient = value[0];
        var qSign = self2.sign !== n2.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign)
            quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else
          quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign)
            mod = -mod;
          mod = new SmallInteger(mod);
        } else
          mod = new BigInteger(mod, mSign);
        return [quotient, mod];
      }
      BigInteger.prototype.divmod = function(v3) {
        var result = divModAny(this, v3);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
      BigInteger.prototype.divide = function(v3) {
        return divModAny(this, v3)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v3) {
        return new NativeBigInt(this.value / parseValue(v3).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
      BigInteger.prototype.mod = function(v3) {
        return divModAny(this, v3)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v3) {
        return new NativeBigInt(this.value % parseValue(v3).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
      BigInteger.prototype.pow = function(v3) {
        var n2 = parseValue(v3), a4 = this.value, b3 = n2.value, value, x6, y4;
        if (b3 === 0)
          return Integer[1];
        if (a4 === 0)
          return Integer[0];
        if (a4 === 1)
          return Integer[1];
        if (a4 === -1)
          return n2.isEven() ? Integer[1] : Integer[-1];
        if (n2.sign) {
          return Integer[0];
        }
        if (!n2.isSmall)
          throw new Error("The exponent " + n2.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a4, b3)))
            return new SmallInteger(truncate(value));
        }
        x6 = this;
        y4 = Integer[1];
        while (true) {
          if (b3 & true) {
            y4 = y4.times(x6);
            --b3;
          }
          if (b3 === 0)
            break;
          b3 /= 2;
          x6 = x6.square();
        }
        return y4;
      };
      SmallInteger.prototype.pow = BigInteger.prototype.pow;
      NativeBigInt.prototype.pow = function(v3) {
        var n2 = parseValue(v3);
        var a4 = this.value, b3 = n2.value;
        var _0 = BigInt(0), _1 = BigInt(1), _22 = BigInt(2);
        if (b3 === _0)
          return Integer[1];
        if (a4 === _0)
          return Integer[0];
        if (a4 === _1)
          return Integer[1];
        if (a4 === BigInt(-1))
          return n2.isEven() ? Integer[1] : Integer[-1];
        if (n2.isNegative())
          return new NativeBigInt(_0);
        var x6 = this;
        var y4 = Integer[1];
        while (true) {
          if ((b3 & _1) === _1) {
            y4 = y4.times(x6);
            --b3;
          }
          if (b3 === _0)
            break;
          b3 /= _22;
          x6 = x6.square();
        }
        return y4;
      };
      BigInteger.prototype.modPow = function(exp2, mod) {
        exp2 = parseValue(exp2);
        mod = parseValue(mod);
        if (mod.isZero())
          throw new Error("Cannot take modPow with modulus 0");
        var r3 = Integer[1], base2 = this.mod(mod);
        if (exp2.isNegative()) {
          exp2 = exp2.multiply(Integer[-1]);
          base2 = base2.modInv(mod);
        }
        while (exp2.isPositive()) {
          if (base2.isZero())
            return Integer[0];
          if (exp2.isOdd())
            r3 = r3.multiply(base2).mod(mod);
          exp2 = exp2.divide(2);
          base2 = base2.square().mod(mod);
        }
        return r3;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
      function compareAbs(a4, b3) {
        if (a4.length !== b3.length) {
          return a4.length > b3.length ? 1 : -1;
        }
        for (var i4 = a4.length - 1; i4 >= 0; i4--) {
          if (a4[i4] !== b3[i4])
            return a4[i4] > b3[i4] ? 1 : -1;
        }
        return 0;
      }
      BigInteger.prototype.compareAbs = function(v3) {
        var n2 = parseValue(v3), a4 = this.value, b3 = n2.value;
        if (n2.isSmall)
          return 1;
        return compareAbs(a4, b3);
      };
      SmallInteger.prototype.compareAbs = function(v3) {
        var n2 = parseValue(v3), a4 = Math.abs(this.value), b3 = n2.value;
        if (n2.isSmall) {
          b3 = Math.abs(b3);
          return a4 === b3 ? 0 : a4 > b3 ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v3) {
        var a4 = this.value;
        var b3 = parseValue(v3).value;
        a4 = a4 >= 0 ? a4 : -a4;
        b3 = b3 >= 0 ? b3 : -b3;
        return a4 === b3 ? 0 : a4 > b3 ? 1 : -1;
      };
      BigInteger.prototype.compare = function(v3) {
        if (v3 === Infinity) {
          return -1;
        }
        if (v3 === -Infinity) {
          return 1;
        }
        var n2 = parseValue(v3), a4 = this.value, b3 = n2.value;
        if (this.sign !== n2.sign) {
          return n2.sign ? 1 : -1;
        }
        if (n2.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a4, b3) * (this.sign ? -1 : 1);
      };
      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
      SmallInteger.prototype.compare = function(v3) {
        if (v3 === Infinity) {
          return -1;
        }
        if (v3 === -Infinity) {
          return 1;
        }
        var n2 = parseValue(v3), a4 = this.value, b3 = n2.value;
        if (n2.isSmall) {
          return a4 == b3 ? 0 : a4 > b3 ? 1 : -1;
        }
        if (a4 < 0 !== n2.sign) {
          return a4 < 0 ? -1 : 1;
        }
        return a4 < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v3) {
        if (v3 === Infinity) {
          return -1;
        }
        if (v3 === -Infinity) {
          return 1;
        }
        var a4 = this.value;
        var b3 = parseValue(v3).value;
        return a4 === b3 ? 0 : a4 > b3 ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger.prototype.equals = function(v3) {
        return this.compare(v3) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
      BigInteger.prototype.notEquals = function(v3) {
        return this.compare(v3) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
      BigInteger.prototype.greater = function(v3) {
        return this.compare(v3) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
      BigInteger.prototype.lesser = function(v3) {
        return this.compare(v3) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
      BigInteger.prototype.greaterOrEquals = function(v3) {
        return this.compare(v3) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
      BigInteger.prototype.lesserOrEquals = function(v3) {
        return this.compare(v3) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
      BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger.prototype.isDivisibleBy = function(v3) {
        var n2 = parseValue(v3);
        if (n2.isZero())
          return false;
        if (n2.isUnit())
          return true;
        if (n2.compareAbs(2) === 0)
          return this.isEven();
        return this.mod(n2).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
      function isBasicPrime(v3) {
        var n2 = v3.abs();
        if (n2.isUnit())
          return false;
        if (n2.equals(2) || n2.equals(3) || n2.equals(5))
          return true;
        if (n2.isEven() || n2.isDivisibleBy(3) || n2.isDivisibleBy(5))
          return false;
        if (n2.lesser(49))
          return true;
      }
      function millerRabinTest(n2, a4) {
        var nPrev = n2.prev(), b3 = nPrev, r3 = 0, d3, t4, i4, x6;
        while (b3.isEven())
          b3 = b3.divide(2), r3++;
        next:
          for (i4 = 0; i4 < a4.length; i4++) {
            if (n2.lesser(a4[i4]))
              continue;
            x6 = bigInt(a4[i4]).modPow(b3, n2);
            if (x6.isUnit() || x6.equals(nPrev))
              continue;
            for (d3 = r3 - 1; d3 != 0; d3--) {
              x6 = x6.square().mod(n2);
              if (x6.isUnit())
                return false;
              if (x6.equals(nPrev))
                continue next;
            }
            return false;
          }
        return true;
      }
      BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n2 = this.abs();
        var bits = n2.bitLength();
        if (bits <= 64)
          return millerRabinTest(n2, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t4 = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a4 = [], i4 = 0; i4 < t4; i4++) {
          a4.push(bigInt(i4 + 2));
        }
        return millerRabinTest(n2, a4);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
      BigInteger.prototype.isProbablePrime = function(iterations2, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2)
          return isPrime;
        var n2 = this.abs();
        var t4 = iterations2 === undefined2 ? 5 : iterations2;
        for (var a4 = [], i4 = 0; i4 < t4; i4++) {
          a4.push(bigInt.randBetween(2, n2.minus(2), rng));
        }
        return millerRabinTest(n2, a4);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
      BigInteger.prototype.modInv = function(n2) {
        var t4 = bigInt.zero, newT = bigInt.one, r3 = parseValue(n2), newR = this.abs(), q4, lastT, lastR;
        while (!newR.isZero()) {
          q4 = r3.divide(newR);
          lastT = t4;
          lastR = r3;
          t4 = newT;
          r3 = newR;
          newT = lastT.subtract(q4.multiply(newT));
          newR = lastR.subtract(q4.multiply(newR));
        }
        if (!r3.isUnit())
          throw new Error(this.toString() + " and " + n2.toString() + " are not co-prime");
        if (t4.compare(0) === -1) {
          t4 = t4.add(n2);
        }
        if (this.isNegative()) {
          return t4.negate();
        }
        return t4;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
      BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT)
          return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT)
          return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
        powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n2) {
        return Math.abs(n2) <= BASE;
      }
      BigInteger.prototype.shiftLeft = function(v3) {
        var n2 = parseValue(v3).toJSNumber();
        if (!shift_isSmall(n2)) {
          throw new Error(String(n2) + " is too large for shifting.");
        }
        if (n2 < 0)
          return this.shiftRight(-n2);
        var result = this;
        if (result.isZero())
          return result;
        while (n2 >= powers2Length) {
          result = result.multiply(highestPower2);
          n2 -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n2]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
      BigInteger.prototype.shiftRight = function(v3) {
        var remQuo;
        var n2 = parseValue(v3).toJSNumber();
        if (!shift_isSmall(n2)) {
          throw new Error(String(n2) + " is too large for shifting.");
        }
        if (n2 < 0)
          return this.shiftLeft(-n2);
        var result = this;
        while (n2 >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit())
            return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n2 -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n2]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
      function bitwise(x6, y4, fn2) {
        y4 = parseValue(y4);
        var xSign = x6.isNegative(), ySign = y4.isNegative();
        var xRem = xSign ? x6.not() : x6, yRem = ySign ? y4.not() : y4;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn2(xDigit, yDigit));
        }
        var sum2 = fn2(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i4 = result.length - 1; i4 >= 0; i4 -= 1) {
          sum2 = sum2.multiply(highestPower2).add(bigInt(result[i4]));
        }
        return sum2;
      }
      BigInteger.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
      BigInteger.prototype.and = function(n2) {
        return bitwise(this, n2, function(a4, b3) {
          return a4 & b3;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
      BigInteger.prototype.or = function(n2) {
        return bitwise(this, n2, function(a4, b3) {
          return a4 | b3;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
      BigInteger.prototype.xor = function(n2) {
        return bitwise(this, n2, function(a4, b3) {
          return a4 ^ b3;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
      function roughLOB(n2) {
        var v3 = n2.value, x6 = typeof v3 === "number" ? v3 | LOBMASK_I : typeof v3 === "bigint" ? v3 | BigInt(LOBMASK_I) : v3[0] + v3[1] * BASE | LOBMASK_BI;
        return x6 & -x6;
      }
      function integerLogarithm(value, base2) {
        if (base2.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base2.square(base2));
          var p4 = tmp.p;
          var e3 = tmp.e;
          var t4 = p4.multiply(base2);
          return t4.compareTo(value) <= 0 ? { p: t4, e: e3 * 2 + 1 } : { p: p4, e: e3 * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger.prototype.bitLength = function() {
        var n2 = this;
        if (n2.compareTo(bigInt(0)) < 0) {
          n2 = n2.negate().subtract(bigInt(1));
        }
        if (n2.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n2, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
      function max3(a4, b3) {
        a4 = parseValue(a4);
        b3 = parseValue(b3);
        return a4.greater(b3) ? a4 : b3;
      }
      function min4(a4, b3) {
        a4 = parseValue(a4);
        b3 = parseValue(b3);
        return a4.lesser(b3) ? a4 : b3;
      }
      function gcd(a4, b3) {
        a4 = parseValue(a4).abs();
        b3 = parseValue(b3).abs();
        if (a4.equals(b3))
          return a4;
        if (a4.isZero())
          return b3;
        if (b3.isZero())
          return a4;
        var c6 = Integer[1], d3, t4;
        while (a4.isEven() && b3.isEven()) {
          d3 = min4(roughLOB(a4), roughLOB(b3));
          a4 = a4.divide(d3);
          b3 = b3.divide(d3);
          c6 = c6.multiply(d3);
        }
        while (a4.isEven()) {
          a4 = a4.divide(roughLOB(a4));
        }
        do {
          while (b3.isEven()) {
            b3 = b3.divide(roughLOB(b3));
          }
          if (a4.greater(b3)) {
            t4 = b3;
            b3 = a4;
            a4 = t4;
          }
          b3 = b3.subtract(a4);
        } while (!b3.isZero());
        return c6.isUnit() ? a4 : a4.multiply(c6);
      }
      function lcm(a4, b3) {
        a4 = parseValue(a4).abs();
        b3 = parseValue(b3).abs();
        return a4.divide(gcd(a4, b3)).multiply(b3);
      }
      function randBetween(a4, b3, rng) {
        a4 = parseValue(a4);
        b3 = parseValue(b3);
        var usedRNG = rng || Math.random;
        var low = min4(a4, b3), high = max3(a4, b3);
        var range3 = high.subtract(low).add(1);
        if (range3.isSmall)
          return low.add(Math.floor(usedRNG() * range3));
        var digits = toBase(range3, BASE).value;
        var result = [], restricted = true;
        for (var i4 = 0; i4 < digits.length; i4++) {
          var top2 = restricted ? digits[i4] + (i4 + 1 < digits.length ? digits[i4 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top2);
          result.push(digit);
          if (digit < digits[i4])
            restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
      }
      var parseBase = function(text2, base2, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text2 = String(text2);
        if (!caseSensitive) {
          text2 = text2.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length3 = text2.length;
        var i4;
        var absBase = Math.abs(base2);
        var alphabetValues = {};
        for (i4 = 0; i4 < alphabet.length; i4++) {
          alphabetValues[alphabet[i4]] = i4;
        }
        for (i4 = 0; i4 < length3; i4++) {
          var c6 = text2[i4];
          if (c6 === "-")
            continue;
          if (c6 in alphabetValues) {
            if (alphabetValues[c6] >= absBase) {
              if (c6 === "1" && absBase === 1)
                continue;
              throw new Error(c6 + " is not a valid digit in base " + base2 + ".");
            }
          }
        }
        base2 = parseValue(base2);
        var digits = [];
        var isNegative = text2[0] === "-";
        for (i4 = isNegative ? 1 : 0; i4 < text2.length; i4++) {
          var c6 = text2[i4];
          if (c6 in alphabetValues)
            digits.push(parseValue(alphabetValues[c6]));
          else if (c6 === "<") {
            var start2 = i4;
            do {
              i4++;
            } while (text2[i4] !== ">" && i4 < text2.length);
            digits.push(parseValue(text2.slice(start2 + 1, i4)));
          } else
            throw new Error(c6 + " is not a valid character");
        }
        return parseBaseFromArray(digits, base2, isNegative);
      };
      function parseBaseFromArray(digits, base2, isNegative) {
        var val = Integer[0], pow3 = Integer[1], i4;
        for (i4 = digits.length - 1; i4 >= 0; i4--) {
          val = val.add(digits[i4].times(pow3));
          pow3 = pow3.times(base2);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n2, base2) {
        base2 = bigInt(base2);
        if (base2.isZero()) {
          if (n2.isZero())
            return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base2.equals(-1)) {
          if (n2.isZero())
            return { value: [0], isNegative: false };
          if (n2.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n2.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n2.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n2.isNegative() && base2.isPositive()) {
          neg = true;
          n2 = n2.abs();
        }
        if (base2.isUnit()) {
          if (n2.isZero())
            return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n2.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left2 = n2, divmod;
        while (left2.isNegative() || left2.compareAbs(base2) >= 0) {
          divmod = left2.divmod(base2);
          left2 = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base2.minus(digit).abs();
            left2 = left2.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left2.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n2, base2, alphabet) {
        var arr = toBase(n2, base2);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x6) {
          return stringify(x6, alphabet);
        }).join("");
      }
      BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix !== 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        var v3 = this.value, l3 = v3.length, str = String(v3[--l3]), zeros = "0000000", digit;
        while (--l3 >= 0) {
          digit = String(v3[l3]);
          str += zeros.slice(digit.length) + digit;
        }
        var sign3 = this.sign ? "-" : "";
        return sign3 + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2)
          radix = 10;
        if (radix != 10 || alphabet)
          return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v3) {
        if (isPrecise(+v3)) {
          var x6 = +v3;
          if (x6 === truncate(x6))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x6)) : new SmallInteger(x6);
          throw new Error("Invalid integer: " + v3);
        }
        var sign3 = v3[0] === "-";
        if (sign3)
          v3 = v3.slice(1);
        var split = v3.split(/e/i);
        if (split.length > 2)
          throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp2 = split[1];
          if (exp2[0] === "+")
            exp2 = exp2.slice(1);
          exp2 = +exp2;
          if (exp2 !== truncate(exp2) || !isPrecise(exp2))
            throw new Error("Invalid integer: " + exp2 + " is not a valid exponent.");
          var text2 = split[0];
          var decimalPlace = text2.indexOf(".");
          if (decimalPlace >= 0) {
            exp2 -= text2.length - decimalPlace - 1;
            text2 = text2.slice(0, decimalPlace) + text2.slice(decimalPlace + 1);
          }
          if (exp2 < 0)
            throw new Error("Cannot include negative exponent part for integers");
          text2 += new Array(exp2 + 1).join("0");
          v3 = text2;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v3);
        if (!isValid)
          throw new Error("Invalid integer: " + v3);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign3 ? "-" + v3 : v3));
        }
        var r3 = [], max4 = v3.length, l3 = LOG_BASE, min5 = max4 - l3;
        while (max4 > 0) {
          r3.push(+v3.slice(min5, max4));
          min5 -= l3;
          if (min5 < 0)
            min5 = 0;
          max4 -= l3;
        }
        trim(r3);
        return new BigInteger(r3, sign3);
      }
      function parseNumberValue(v3) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v3));
        }
        if (isPrecise(v3)) {
          if (v3 !== truncate(v3))
            throw new Error(v3 + " is not an integer.");
          return new SmallInteger(v3);
        }
        return parseStringValue(v3.toString());
      }
      function parseValue(v3) {
        if (typeof v3 === "number") {
          return parseNumberValue(v3);
        }
        if (typeof v3 === "string") {
          return parseStringValue(v3);
        }
        if (typeof v3 === "bigint") {
          return new NativeBigInt(v3);
        }
        return v3;
      }
      for (var i3 = 0; i3 < 1e3; i3++) {
        Integer[i3] = parseValue(i3);
        if (i3 > 0)
          Integer[-i3] = parseValue(-i3);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max3;
      Integer.min = min4;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x6) {
        return x6 instanceof BigInteger || x6 instanceof SmallInteger || x6 instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base2, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base2 || 10), isNegative);
      };
      return Integer;
    }();
    if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
      module.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return bigInt;
      });
    }
  }
});

// node_modules/.pnpm/jed@1.1.1/node_modules/jed/jed.js
var require_jed = __commonJS({
  "node_modules/.pnpm/jed@1.1.1/node_modules/jed/jed.js"(exports, module) {
    (function(root2, undef) {
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice3 = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
      var _3 = {
        forEach: function(obj, iterator, context) {
          var i3, l3, key;
          if (obj === null) {
            return;
          }
          if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
          } else if (obj.length === +obj.length) {
            for (i3 = 0, l3 = obj.length; i3 < l3; i3++) {
              if (i3 in obj && iterator.call(context, obj[i3], i3, obj) === breaker) {
                return;
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProp.call(obj, key)) {
                if (iterator.call(context, obj[key], key, obj) === breaker) {
                  return;
                }
              }
            }
          }
        },
        extend: function(obj) {
          this.forEach(slice3.call(arguments, 1), function(source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          });
          return obj;
        }
      };
      var Jed2 = function(options) {
        this.defaults = {
          "locale_data": {
            "messages": {
              "": {
                "domain": "messages",
                "lang": "en",
                "plural_forms": "nplurals=2; plural=(n != 1);"
              }
              // There are no default keys, though
            }
          },
          // The default domain if one is missing
          "domain": "messages",
          // enable debug mode to log untranslated strings to the console
          "debug": false
        };
        this.options = _3.extend({}, this.defaults, options);
        this.textdomain(this.options.domain);
        if (options.domain && !this.options.locale_data[this.options.domain]) {
          throw new Error("Text domain set to non-existent domain: `" + options.domain + "`");
        }
      };
      Jed2.context_delimiter = String.fromCharCode(4);
      function getPluralFormFunc(plural_form_string) {
        return Jed2.PF.compile(plural_form_string || "nplurals=2; plural=(n != 1);");
      }
      function Chain(key, i18n2) {
        this._key = key;
        this._i18n = i18n2;
      }
      _3.extend(Chain.prototype, {
        onDomain: function(domain) {
          this._domain = domain;
          return this;
        },
        withContext: function(context) {
          this._context = context;
          return this;
        },
        ifPlural: function(num, pkey) {
          this._val = num;
          this._pkey = pkey;
          return this;
        },
        fetch: function(sArr) {
          if ({}.toString.call(sArr) != "[object Array]") {
            sArr = [].slice.call(arguments, 0);
          }
          return (sArr && sArr.length ? Jed2.sprintf : function(x6) {
            return x6;
          })(
            this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val),
            sArr
          );
        }
      });
      _3.extend(Jed2.prototype, {
        // The sexier api start point
        translate: function(key) {
          return new Chain(key, this);
        },
        textdomain: function(domain) {
          if (!domain) {
            return this._textdomain;
          }
          this._textdomain = domain;
        },
        gettext: function(key) {
          return this.dcnpgettext.call(this, undef, undef, key);
        },
        dgettext: function(domain, key) {
          return this.dcnpgettext.call(this, domain, undef, key);
        },
        dcgettext: function(domain, key) {
          return this.dcnpgettext.call(this, domain, undef, key);
        },
        ngettext: function(skey, pkey, val) {
          return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
        },
        dngettext: function(domain, skey, pkey, val) {
          return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
        },
        dcngettext: function(domain, skey, pkey, val) {
          return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
        },
        pgettext: function(context, key) {
          return this.dcnpgettext.call(this, undef, context, key);
        },
        dpgettext: function(domain, context, key) {
          return this.dcnpgettext.call(this, domain, context, key);
        },
        dcpgettext: function(domain, context, key) {
          return this.dcnpgettext.call(this, domain, context, key);
        },
        npgettext: function(context, skey, pkey, val) {
          return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
        },
        dnpgettext: function(domain, context, skey, pkey, val) {
          return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
        },
        // The most fully qualified gettext function. It has every option.
        // Since it has every option, we can use it from every other method.
        // This is the bread and butter.
        // Technically there should be one more argument in this function for 'Category',
        // but since we never use it, we might as well not waste the bytes to define it.
        dcnpgettext: function(domain, context, singular_key, plural_key, val) {
          plural_key = plural_key || singular_key;
          domain = domain || this._textdomain;
          var fallback;
          if (!this.options) {
            fallback = new Jed2();
            return fallback.dcnpgettext.call(fallback, void 0, void 0, singular_key, plural_key, val);
          }
          if (!this.options.locale_data) {
            throw new Error("No locale data provided.");
          }
          if (!this.options.locale_data[domain]) {
            throw new Error("Domain `" + domain + "` was not found.");
          }
          if (!this.options.locale_data[domain][""]) {
            throw new Error("No locale meta information provided.");
          }
          if (!singular_key) {
            throw new Error("No translation key found.");
          }
          var key = context ? context + Jed2.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[""], pluralForms = dict[""].plural_forms || dict[""]["Plural-Forms"] || dict[""]["plural-forms"] || defaultConf.plural_forms || defaultConf["Plural-Forms"] || defaultConf["plural-forms"], val_list, res;
          var val_idx;
          if (val === void 0) {
            val_idx = 0;
          } else {
            if (typeof val != "number") {
              val = parseInt(val, 10);
              if (isNaN(val)) {
                throw new Error("The number that was passed in is not a number.");
              }
            }
            val_idx = getPluralFormFunc(pluralForms)(val);
          }
          if (!dict) {
            throw new Error("No domain named `" + domain + "` could be found.");
          }
          val_list = dict[key];
          if (!val_list || val_idx > val_list.length) {
            if (this.options.missing_key_callback) {
              this.options.missing_key_callback(key, domain);
            }
            res = [singular_key, plural_key];
            if (this.options.debug === true) {
              console.log(res[getPluralFormFunc(pluralForms)(val)]);
            }
            return res[getPluralFormFunc()(val)];
          }
          res = val_list[val_idx];
          if (!res) {
            res = [singular_key, plural_key];
            return res[getPluralFormFunc()(val)];
          }
          return res;
        }
      });
      var sprintf = function() {
        function get_type(variable) {
          return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
          for (var output = []; multiplier > 0; output[--multiplier] = input) {
          }
          return output.join("");
        }
        var str_format = function() {
          if (!str_format.cache.hasOwnProperty(arguments[0])) {
            str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
          }
          return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
        str_format.format = function(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i3, k5, match5, pad4, pad_character, pad_length;
          for (i3 = 0; i3 < tree_length; i3++) {
            node_type = get_type(parse_tree[i3]);
            if (node_type === "string") {
              output.push(parse_tree[i3]);
            } else if (node_type === "array") {
              match5 = parse_tree[i3];
              if (match5[2]) {
                arg = argv[cursor];
                for (k5 = 0; k5 < match5[2].length; k5++) {
                  if (!arg.hasOwnProperty(match5[2][k5])) {
                    throw sprintf('[sprintf] property "%s" does not exist', match5[2][k5]);
                  }
                  arg = arg[match5[2][k5]];
                }
              } else if (match5[1]) {
                arg = argv[match5[1]];
              } else {
                arg = argv[cursor++];
              }
              if (/[^s]/.test(match5[8]) && get_type(arg) != "number") {
                throw sprintf("[sprintf] expecting number but found %s", get_type(arg));
              }
              if (typeof arg == "undefined" || arg === null) {
                arg = "";
              }
              switch (match5[8]) {
                case "b":
                  arg = arg.toString(2);
                  break;
                case "c":
                  arg = String.fromCharCode(arg);
                  break;
                case "d":
                  arg = parseInt(arg, 10);
                  break;
                case "e":
                  arg = match5[7] ? arg.toExponential(match5[7]) : arg.toExponential();
                  break;
                case "f":
                  arg = match5[7] ? parseFloat(arg).toFixed(match5[7]) : parseFloat(arg);
                  break;
                case "o":
                  arg = arg.toString(8);
                  break;
                case "s":
                  arg = (arg = String(arg)) && match5[7] ? arg.substring(0, match5[7]) : arg;
                  break;
                case "u":
                  arg = Math.abs(arg);
                  break;
                case "x":
                  arg = arg.toString(16);
                  break;
                case "X":
                  arg = arg.toString(16).toUpperCase();
                  break;
              }
              arg = /[def]/.test(match5[8]) && match5[3] && arg >= 0 ? "+" + arg : arg;
              pad_character = match5[4] ? match5[4] == "0" ? "0" : match5[4].charAt(1) : " ";
              pad_length = match5[6] - String(arg).length;
              pad4 = match5[6] ? str_repeat(pad_character, pad_length) : "";
              output.push(match5[5] ? arg + pad4 : pad4 + arg);
            }
          }
          return output.join("");
        };
        str_format.cache = {};
        str_format.parse = function(fmt) {
          var _fmt = fmt, match5 = [], parse_tree = [], arg_names = 0;
          while (_fmt) {
            if ((match5 = /^[^\x25]+/.exec(_fmt)) !== null) {
              parse_tree.push(match5[0]);
            } else if ((match5 = /^\x25{2}/.exec(_fmt)) !== null) {
              parse_tree.push("%");
            } else if ((match5 = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
              if (match5[2]) {
                arg_names |= 1;
                var field_list = [], replacement_field = match5[2], field_match = [];
                if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                  while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                    if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else {
                      throw "[sprintf] huh?";
                    }
                  }
                } else {
                  throw "[sprintf] huh?";
                }
                match5[2] = field_list;
              } else {
                arg_names |= 2;
              }
              if (arg_names === 3) {
                throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
              }
              parse_tree.push(match5);
            } else {
              throw "[sprintf] huh?";
            }
            _fmt = _fmt.substring(match5[0].length);
          }
          return parse_tree;
        };
        return str_format;
      }();
      var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
      };
      Jed2.parse_plural = function(plural_forms, n2) {
        plural_forms = plural_forms.replace(/n/g, n2);
        return Jed2.parse_expression(plural_forms);
      };
      Jed2.sprintf = function(fmt, args) {
        if ({}.toString.call(args) == "[object Array]") {
          return vsprintf(fmt, [].slice.call(args));
        }
        return sprintf.apply(this, [].slice.call(arguments));
      };
      Jed2.prototype.sprintf = function() {
        return Jed2.sprintf.apply(this, arguments);
      };
      Jed2.PF = {};
      Jed2.PF.parse = function(p4) {
        var plural_str = Jed2.PF.extractPluralExpr(p4);
        return Jed2.PF.parser.parse.call(Jed2.PF.parser, plural_str);
      };
      Jed2.PF.compile = function(p4) {
        function imply(val) {
          return val === true ? 1 : val ? val : 0;
        }
        var ast = Jed2.PF.parse(p4);
        return function(n2) {
          return imply(Jed2.PF.interpreter(ast)(n2));
        };
      };
      Jed2.PF.interpreter = function(ast) {
        return function(n2) {
          var res;
          switch (ast.type) {
            case "GROUP":
              return Jed2.PF.interpreter(ast.expr)(n2);
            case "TERNARY":
              if (Jed2.PF.interpreter(ast.expr)(n2)) {
                return Jed2.PF.interpreter(ast.truthy)(n2);
              }
              return Jed2.PF.interpreter(ast.falsey)(n2);
            case "OR":
              return Jed2.PF.interpreter(ast.left)(n2) || Jed2.PF.interpreter(ast.right)(n2);
            case "AND":
              return Jed2.PF.interpreter(ast.left)(n2) && Jed2.PF.interpreter(ast.right)(n2);
            case "LT":
              return Jed2.PF.interpreter(ast.left)(n2) < Jed2.PF.interpreter(ast.right)(n2);
            case "GT":
              return Jed2.PF.interpreter(ast.left)(n2) > Jed2.PF.interpreter(ast.right)(n2);
            case "LTE":
              return Jed2.PF.interpreter(ast.left)(n2) <= Jed2.PF.interpreter(ast.right)(n2);
            case "GTE":
              return Jed2.PF.interpreter(ast.left)(n2) >= Jed2.PF.interpreter(ast.right)(n2);
            case "EQ":
              return Jed2.PF.interpreter(ast.left)(n2) == Jed2.PF.interpreter(ast.right)(n2);
            case "NEQ":
              return Jed2.PF.interpreter(ast.left)(n2) != Jed2.PF.interpreter(ast.right)(n2);
            case "MOD":
              return Jed2.PF.interpreter(ast.left)(n2) % Jed2.PF.interpreter(ast.right)(n2);
            case "VAR":
              return n2;
            case "NUM":
              return ast.val;
            default:
              throw new Error("Invalid Token found.");
          }
        };
      };
      Jed2.PF.extractPluralExpr = function(p4) {
        p4 = p4.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (!/;\s*$/.test(p4)) {
          p4 = p4.concat(";");
        }
        var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p4.match(nplurals_re), res = {}, plural_matches;
        if (nplurals_matches.length > 1) {
          res.nplurals = nplurals_matches[1];
        } else {
          throw new Error("nplurals not found in plural_forms string: " + p4);
        }
        p4 = p4.replace(nplurals_re, "");
        plural_matches = p4.match(plural_re);
        if (!(plural_matches && plural_matches.length > 1)) {
          throw new Error("`plural` expression not found: " + p4);
        }
        return plural_matches[1];
      };
      Jed2.PF.parser = function() {
        var parser = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "expressions": 3, "e": 4, "EOF": 5, "?": 6, ":": 7, "||": 8, "&&": 9, "<": 10, "<=": 11, ">": 12, ">=": 13, "!=": 14, "==": 15, "%": 16, "(": 17, ")": 18, "n": 19, "NUMBER": 20, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 6: "?", 7: ":", 8: "||", 9: "&&", 10: "<", 11: "<=", 12: ">", 13: ">=", 14: "!=", 15: "==", 16: "%", 17: "(", 18: ")", 19: "n", 20: "NUMBER" },
          productions_: [0, [3, 2], [4, 5], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 1], [4, 1]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return { type: "GROUP", expr: $$[$0 - 1] };
                break;
              case 2:
                this.$ = { type: "TERNARY", expr: $$[$0 - 4], truthy: $$[$0 - 2], falsey: $$[$0] };
                break;
              case 3:
                this.$ = { type: "OR", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 4:
                this.$ = { type: "AND", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 5:
                this.$ = { type: "LT", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 6:
                this.$ = { type: "LTE", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 7:
                this.$ = { type: "GT", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 8:
                this.$ = { type: "GTE", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 9:
                this.$ = { type: "NEQ", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 10:
                this.$ = { type: "EQ", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 11:
                this.$ = { type: "MOD", left: $$[$0 - 2], right: $$[$0] };
                break;
              case 12:
                this.$ = { type: "GROUP", expr: $$[$0 - 1] };
                break;
              case 13:
                this.$ = { type: "VAR" };
                break;
              case 14:
                this.$ = { type: "NUM", val: Number(yytext) };
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 1: [3] }, { 5: [1, 6], 6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16] }, { 4: 17, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 5: [2, 13], 6: [2, 13], 7: [2, 13], 8: [2, 13], 9: [2, 13], 10: [2, 13], 11: [2, 13], 12: [2, 13], 13: [2, 13], 14: [2, 13], 15: [2, 13], 16: [2, 13], 18: [2, 13] }, { 5: [2, 14], 6: [2, 14], 7: [2, 14], 8: [2, 14], 9: [2, 14], 10: [2, 14], 11: [2, 14], 12: [2, 14], 13: [2, 14], 14: [2, 14], 15: [2, 14], 16: [2, 14], 18: [2, 14] }, { 1: [2, 1] }, { 4: 18, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 19, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 20, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 21, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 22, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 23, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 24, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 25, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 26, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 4: 27, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 6: [1, 7], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [1, 28] }, { 6: [1, 7], 7: [1, 29], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16] }, { 5: [2, 3], 6: [2, 3], 7: [2, 3], 8: [2, 3], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 3] }, { 5: [2, 4], 6: [2, 4], 7: [2, 4], 8: [2, 4], 9: [2, 4], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 4] }, { 5: [2, 5], 6: [2, 5], 7: [2, 5], 8: [2, 5], 9: [2, 5], 10: [2, 5], 11: [2, 5], 12: [2, 5], 13: [2, 5], 14: [2, 5], 15: [2, 5], 16: [1, 16], 18: [2, 5] }, { 5: [2, 6], 6: [2, 6], 7: [2, 6], 8: [2, 6], 9: [2, 6], 10: [2, 6], 11: [2, 6], 12: [2, 6], 13: [2, 6], 14: [2, 6], 15: [2, 6], 16: [1, 16], 18: [2, 6] }, { 5: [2, 7], 6: [2, 7], 7: [2, 7], 8: [2, 7], 9: [2, 7], 10: [2, 7], 11: [2, 7], 12: [2, 7], 13: [2, 7], 14: [2, 7], 15: [2, 7], 16: [1, 16], 18: [2, 7] }, { 5: [2, 8], 6: [2, 8], 7: [2, 8], 8: [2, 8], 9: [2, 8], 10: [2, 8], 11: [2, 8], 12: [2, 8], 13: [2, 8], 14: [2, 8], 15: [2, 8], 16: [1, 16], 18: [2, 8] }, { 5: [2, 9], 6: [2, 9], 7: [2, 9], 8: [2, 9], 9: [2, 9], 10: [2, 9], 11: [2, 9], 12: [2, 9], 13: [2, 9], 14: [2, 9], 15: [2, 9], 16: [1, 16], 18: [2, 9] }, { 5: [2, 10], 6: [2, 10], 7: [2, 10], 8: [2, 10], 9: [2, 10], 10: [2, 10], 11: [2, 10], 12: [2, 10], 13: [2, 10], 14: [2, 10], 15: [2, 10], 16: [1, 16], 18: [2, 10] }, { 5: [2, 11], 6: [2, 11], 7: [2, 11], 8: [2, 11], 9: [2, 11], 10: [2, 11], 11: [2, 11], 12: [2, 11], 13: [2, 11], 14: [2, 11], 15: [2, 11], 16: [2, 11], 18: [2, 11] }, { 5: [2, 12], 6: [2, 12], 7: [2, 12], 8: [2, 12], 9: [2, 12], 10: [2, 12], 11: [2, 12], 12: [2, 12], 13: [2, 12], 14: [2, 12], 15: [2, 12], 16: [2, 12], 18: [2, 12] }, { 4: 30, 17: [1, 3], 19: [1, 4], 20: [1, 5] }, { 5: [2, 2], 6: [1, 7], 7: [2, 2], 8: [1, 8], 9: [1, 9], 10: [1, 10], 11: [1, 11], 12: [1, 12], 13: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 18: [2, 2] }],
          defaultActions: { 6: [2, 1] },
          parseError: function parseError(str, hash3) {
            throw new Error(str);
          },
          parse: function parse2(input) {
            var self2 = this, stack2 = [0], vstack = [null], lstack = [], table2 = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            if (typeof this.lexer.yylloc == "undefined")
              this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            if (typeof this.yy.parseError === "function")
              this.parseError = this.yy.parseError;
            function popStack(n2) {
              stack2.length = stack2.length - 2 * n2;
              vstack.length = vstack.length - n2;
              lstack.length = lstack.length - n2;
            }
            function lex() {
              var token;
              token = self2.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol2, preErrorSymbol, state, action, a4, r3, yyval = {}, p4, len, newState, expected;
            while (true) {
              state = stack2[stack2.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol2 == null)
                  symbol2 = lex();
                action = table2[state] && table2[state][symbol2];
              }
              _handle_error:
                if (typeof action === "undefined" || !action.length || !action[0]) {
                  if (!recovering) {
                    expected = [];
                    for (p4 in table2[state])
                      if (this.terminals_[p4] && p4 > 2) {
                        expected.push("'" + this.terminals_[p4] + "'");
                      }
                    var errStr = "";
                    if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + this.terminals_[symbol2] + "'";
                    } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == 1 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
                    }
                    this.parseError(
                      errStr,
                      { text: this.lexer.match, token: this.terminals_[symbol2] || symbol2, line: this.lexer.yylineno, loc: yyloc, expected }
                    );
                  }
                  if (recovering == 3) {
                    if (symbol2 == EOF2) {
                      throw new Error(errStr || "Parsing halted.");
                    }
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    symbol2 = lex();
                  }
                  while (1) {
                    if (TERROR.toString() in table2[state]) {
                      break;
                    }
                    if (state == 0) {
                      throw new Error(errStr || "Parsing halted.");
                    }
                    popStack(1);
                    state = stack2[stack2.length - 1];
                  }
                  preErrorSymbol = symbol2;
                  symbol2 = TERROR;
                  state = stack2[stack2.length - 1];
                  action = table2[state] && table2[state][TERROR];
                  recovering = 3;
                }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
              }
              switch (action[0]) {
                case 1:
                  stack2.push(symbol2);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack2.push(action[1]);
                  symbol2 = null;
                  if (!preErrorSymbol) {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                      recovering--;
                  } else {
                    symbol2 = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                  };
                  r3 = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r3 !== "undefined") {
                    return r3;
                  }
                  if (len) {
                    stack2 = stack2.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack2.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table2[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
                  stack2.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash3) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash3);
              } else {
                throw new Error(str);
              }
            },
            setInput: function(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              return this;
            },
            input: function() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function(ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function() {
              this._more = true;
              return this;
            },
            pastInput: function() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function() {
              var pre = this.pastInput();
              var c6 = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c6 + "^";
            },
            next: function() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match5, col, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i3 = 0; i3 < rules.length; i3++) {
                match5 = this._input.match(this.rules[rules[i3]]);
                if (match5) {
                  lines = match5[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match5[0].length
                  };
                  this.yytext += match5[0];
                  this.match += match5[0];
                  this.matches = match5;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match5[0].length);
                  this.matched += match5[0];
                  token = this.performAction.call(this, this.yy, this, rules[i3], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                this.parseError(
                  "Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(),
                  { text: "", token: null, line: this.yylineno }
                );
              }
            },
            lex: function lex() {
              var r3 = this.next();
              if (typeof r3 !== "undefined") {
                return r3;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                break;
              case 1:
                return 20;
                break;
              case 2:
                return 19;
                break;
              case 3:
                return 8;
                break;
              case 4:
                return 9;
                break;
              case 5:
                return 6;
                break;
              case 6:
                return 7;
                break;
              case 7:
                return 11;
                break;
              case 8:
                return 13;
                break;
              case 9:
                return 10;
                break;
              case 10:
                return 12;
                break;
              case 11:
                return 14;
                break;
              case 12:
                return 15;
                break;
              case 13:
                return 16;
                break;
              case 14:
                return 17;
                break;
              case 15:
                return 18;
                break;
              case 16:
                return 5;
                break;
              case 17:
                return "INVALID";
                break;
            }
          };
          lexer2.rules = [/^\s+/, /^[0-9]+(\.[0-9]+)?\b/, /^n\b/, /^\|\|/, /^&&/, /^\?/, /^:/, /^<=/, /^>=/, /^</, /^>/, /^!=/, /^==/, /^%/, /^\(/, /^\)/, /^$/, /^./];
          lexer2.conditions = { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], "inclusive": true } };
          return lexer2;
        }();
        parser.lexer = lexer;
        return parser;
      }();
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = Jed2;
        }
        exports.Jed = Jed2;
      } else {
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Jed2;
          });
        }
        root2["Jed"] = Jed2;
      }
    })(exports);
  }
});

// node_modules/.pnpm/preact@10.11.3/node_modules/preact/dist/preact.module.js
function s(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function a(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function h(l3, u3, i3) {
  var t4, o3, r3, f3 = {};
  for (r3 in u3)
    "key" == r3 ? t4 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f3[r3] = u3[r3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (r3 in l3.defaultProps)
      void 0 === f3[r3] && (f3[r3] = l3.defaultProps[r3]);
  return v(l3, f3, t4, o3, null);
}
function v(n2, i3, t4, o3, r3) {
  var f3 = { type: n2, props: i3, key: t4, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r3 ? ++u : r3 };
  return null == r3 && null != l.vnode && l.vnode(f3), f3;
}
function y() {
  return { current: null };
}
function p2(n2) {
  return n2.children;
}
function d(n2, l3) {
  this.props = n2, this.context = l3;
}
function _(n2, l3) {
  if (null == l3)
    return n2.__ ? _(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? _(n2) : null;
}
function k(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return k(n2);
  }
}
function b(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
  for (var n2; g.__r = t.length; )
    n2 = t.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), t = [], n2.some(function(n3) {
      var l3, u3, i3, t4, o3, r3;
      n3.__d && (o3 = (t4 = (l3 = n3).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = s({}, t4)).__v = t4.__v + 1, j(r3, t4, i3, l3.__n, void 0 !== r3.ownerSVGElement, null != t4.__h ? [o3] : null, u3, null == o3 ? _(t4) : o3, t4.__h), z(u3, t4), t4.__e != o3 && k(t4)));
    });
}
function w(n2, l3, u3, i3, t4, o3, r3, c6, s4, a4) {
  var h3, y4, d3, k5, b3, g4, w4, x6 = i3 && i3.__k || e, C4 = x6.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (k5 = u3.__k[h3] = null == (k5 = l3[h3]) || "boolean" == typeof k5 ? null : "string" == typeof k5 || "number" == typeof k5 || "bigint" == typeof k5 ? v(null, k5, null, null, k5) : Array.isArray(k5) ? v(p2, { children: k5 }, null, null, null) : k5.__b > 0 ? v(k5.type, k5.props, k5.key, k5.ref ? k5.ref : null, k5.__v) : k5)) {
      if (k5.__ = u3, k5.__b = u3.__b + 1, null === (d3 = x6[h3]) || d3 && k5.key == d3.key && k5.type === d3.type)
        x6[h3] = void 0;
      else
        for (y4 = 0; y4 < C4; y4++) {
          if ((d3 = x6[y4]) && k5.key == d3.key && k5.type === d3.type) {
            x6[y4] = void 0;
            break;
          }
          d3 = null;
        }
      j(n2, k5, d3 = d3 || f, t4, o3, r3, c6, s4, a4), b3 = k5.__e, (y4 = k5.ref) && d3.ref != y4 && (w4 || (w4 = []), d3.ref && w4.push(d3.ref, null, k5), w4.push(y4, k5.__c || b3, k5)), null != b3 ? (null == g4 && (g4 = b3), "function" == typeof k5.type && k5.__k === d3.__k ? k5.__d = s4 = m(k5, s4, n2) : s4 = A2(n2, k5, d3, x6, b3, s4), "function" == typeof u3.type && (u3.__d = s4)) : s4 && d3.__e == s4 && s4.parentNode != n2 && (s4 = _(d3));
    }
  for (u3.__e = g4, h3 = C4; h3--; )
    null != x6[h3] && N(x6[h3], x6[h3]);
  if (w4)
    for (h3 = 0; h3 < w4.length; h3++)
      M2(w4[h3], w4[++h3], w4[++h3]);
}
function m(n2, l3, u3) {
  for (var i3, t4 = n2.__k, o3 = 0; t4 && o3 < t4.length; o3++)
    (i3 = t4[o3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? m(i3, l3, u3) : A2(u3, i3, i3, t4, i3.__e, l3));
  return l3;
}
function x(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    x(n3, l3);
  }) : l3.push(n2)), l3;
}
function A2(n2, l3, u3, i3, t4, o3) {
  var r3, f3, e3;
  if (void 0 !== l3.__d)
    r3 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t4 != o3 || null == t4.parentNode)
    n:
      if (null == o3 || o3.parentNode !== n2)
        n2.appendChild(t4), r3 = null;
      else {
        for (f3 = o3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t4)
            break n;
        n2.insertBefore(t4, o3), r3 = o3;
      }
  return void 0 !== r3 ? r3 : t4.nextSibling;
}
function C(n2, l3, u3, i3, t4) {
  var o3;
  for (o3 in u3)
    "children" === o3 || "key" === o3 || o3 in l3 || H(n2, o3, null, u3[o3], i3);
  for (o3 in l3)
    t4 && "function" != typeof l3[o3] || "children" === o3 || "key" === o3 || "value" === o3 || "checked" === o3 || u3[o3] === l3[o3] || H(n2, o3, l3[o3], u3[o3], i3);
}
function $(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || c.test(l3) ? u3 : u3 + "px";
}
function H(n2, l3, u3, i3, t4) {
  var o3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || $(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || $(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? i3 || n2.addEventListener(l3, o3 ? T : I2, o3) : n2.removeEventListener(l3, o3 ? T : I2, o3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t4)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function I2(n2) {
  this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function T(n2) {
  this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function j(n2, u3, i3, t4, o3, r3, f3, e3, c6) {
  var a4, h3, v3, y4, _3, k5, b3, g4, m3, x6, A6, C4, $3, H3, I4, T4 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c6 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, r3 = [e3]), (a4 = l.__b) && a4(u3);
  try {
    n:
      if ("function" == typeof T4) {
        if (g4 = u3.props, m3 = (a4 = T4.contextType) && t4[a4.__c], x6 = a4 ? m3 ? m3.props.value : a4.__ : t4, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in T4 && T4.prototype.render ? u3.__c = h3 = new T4(g4, x6) : (u3.__c = h3 = new d(g4, x6), h3.constructor = T4, h3.render = O), m3 && m3.sub(h3), h3.props = g4, h3.state || (h3.state = {}), h3.context = x6, h3.__n = t4, v3 = h3.__d = true, h3.__h = [], h3._sb = []), null == h3.__s && (h3.__s = h3.state), null != T4.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = s({}, h3.__s)), s(h3.__s, T4.getDerivedStateFromProps(g4, h3.__s))), y4 = h3.props, _3 = h3.state, v3)
          null == T4.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
        else {
          if (null == T4.getDerivedStateFromProps && g4 !== y4 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(g4, x6), !h3.__e && null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(g4, h3.__s, x6) || u3.__v === i3.__v) {
            for (h3.props = g4, h3.state = h3.__s, u3.__v !== i3.__v && (h3.__d = false), h3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), A6 = 0; A6 < h3._sb.length; A6++)
              h3.__h.push(h3._sb[A6]);
            h3._sb = [], h3.__h.length && f3.push(h3);
            break n;
          }
          null != h3.componentWillUpdate && h3.componentWillUpdate(g4, h3.__s, x6), null != h3.componentDidUpdate && h3.__h.push(function() {
            h3.componentDidUpdate(y4, _3, k5);
          });
        }
        if (h3.context = x6, h3.props = g4, h3.__v = u3, h3.__P = n2, C4 = l.__r, $3 = 0, "prototype" in T4 && T4.prototype.render) {
          for (h3.state = h3.__s, h3.__d = false, C4 && C4(u3), a4 = h3.render(h3.props, h3.state, h3.context), H3 = 0; H3 < h3._sb.length; H3++)
            h3.__h.push(h3._sb[H3]);
          h3._sb = [];
        } else
          do {
            h3.__d = false, C4 && C4(u3), a4 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
          } while (h3.__d && ++$3 < 25);
        h3.state = h3.__s, null != h3.getChildContext && (t4 = s(s({}, t4), h3.getChildContext())), v3 || null == h3.getSnapshotBeforeUpdate || (k5 = h3.getSnapshotBeforeUpdate(y4, _3)), I4 = null != a4 && a4.type === p2 && null == a4.key ? a4.props.children : a4, w(n2, Array.isArray(I4) ? I4 : [I4], u3, i3, t4, o3, r3, f3, e3, c6), h3.base = u3.__e, u3.__h = null, h3.__h.length && f3.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
      } else
        null == r3 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = L2(i3.__e, u3, i3, t4, o3, r3, f3, c6);
    (a4 = l.diffed) && a4(u3);
  } catch (n3) {
    u3.__v = null, (c6 || null != r3) && (u3.__e = e3, u3.__h = !!c6, r3[r3.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function z(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function L2(l3, u3, i3, t4, o3, r3, e3, c6) {
  var s4, h3, v3, y4 = i3.props, p4 = u3.props, d3 = u3.type, k5 = 0;
  if ("svg" === d3 && (o3 = true), null != r3) {
    for (; k5 < r3.length; k5++)
      if ((s4 = r3[k5]) && "setAttribute" in s4 == !!d3 && (d3 ? s4.localName === d3 : 3 === s4.nodeType)) {
        l3 = s4, r3[k5] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d3)
      return document.createTextNode(p4);
    l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p4.is && p4), r3 = null, c6 = false;
  }
  if (null === d3)
    y4 === p4 || c6 && l3.data === p4 || (l3.data = p4);
  else {
    if (r3 = r3 && n.call(l3.childNodes), h3 = (y4 = i3.props || f).dangerouslySetInnerHTML, v3 = p4.dangerouslySetInnerHTML, !c6) {
      if (null != r3)
        for (y4 = {}, k5 = 0; k5 < l3.attributes.length; k5++)
          y4[l3.attributes[k5].name] = l3.attributes[k5].value;
      (v3 || h3) && (v3 && (h3 && v3.__html == h3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if (C(l3, p4, y4, o3, c6), v3)
      u3.__k = [];
    else if (k5 = u3.props.children, w(l3, Array.isArray(k5) ? k5 : [k5], u3, i3, t4, o3 && "foreignObject" !== d3, r3, e3, r3 ? r3[0] : i3.__k && _(i3, 0), c6), null != r3)
      for (k5 = r3.length; k5--; )
        null != r3[k5] && a(r3[k5]);
    c6 || ("value" in p4 && void 0 !== (k5 = p4.value) && (k5 !== l3.value || "progress" === d3 && !k5 || "option" === d3 && k5 !== y4.value) && H(l3, "value", k5, y4.value, false), "checked" in p4 && void 0 !== (k5 = p4.checked) && k5 !== l3.checked && H(l3, "checked", k5, y4.checked, false));
  }
  return l3;
}
function M2(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function N(n2, u3, i3) {
  var t4, o3;
  if (l.unmount && l.unmount(n2), (t4 = n2.ref) && (t4.current && t4.current !== n2.__e || M2(t4, null, u3)), null != (t4 = n2.__c)) {
    if (t4.componentWillUnmount)
      try {
        t4.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t4.base = t4.__P = null, n2.__c = void 0;
  }
  if (t4 = n2.__k)
    for (o3 = 0; o3 < t4.length; o3++)
      t4[o3] && N(t4[o3], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || a(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function O(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function P(u3, i3, t4) {
  var o3, r3, e3;
  l.__ && l.__(u3, i3), r3 = (o3 = "function" == typeof t4) ? null : t4 && t4.__k || i3.__k, e3 = [], j(i3, u3 = (!o3 && t4 || i3).__k = h(p2, null, [u3]), r3 || f, f, void 0 !== i3.ownerSVGElement, !o3 && t4 ? [t4] : r3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, e3, !o3 && t4 ? t4 : r3 ? r3.__e : i3.firstChild, o3), z(e3, u3);
}
function S2(n2, l3) {
  P(n2, l3, S2);
}
function q(l3, u3, i3) {
  var t4, o3, r3, f3 = s({}, l3.props);
  for (r3 in u3)
    "key" == r3 ? t4 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f3[r3] = u3[r3];
  return arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), v(l3.type, f3, t4 || l3.key, o3 || l3.ref, null);
}
function B(n2, l3) {
  var u3 = { __c: l3 = "__cC" + r++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(b);
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
var n, l, u, i, t, o, r, f, e, c;
var init_preact_module = __esm({
  "node_modules/.pnpm/preact@10.11.3/node_modules/preact/dist/preact.module.js"() {
    f = {};
    e = [];
    c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = e.slice, l = { __e: function(n2, l3, u3, i3) {
      for (var t4, o3, r3; l3 = l3.__; )
        if ((t4 = l3.__c) && !t4.__)
          try {
            if ((o3 = t4.constructor) && null != o3.getDerivedStateFromError && (t4.setState(o3.getDerivedStateFromError(n2)), r3 = t4.__d), null != t4.componentDidCatch && (t4.componentDidCatch(n2, i3 || {}), r3 = t4.__d), r3)
              return t4.__E = t4;
          } catch (l4) {
            n2 = l4;
          }
      throw n2;
    } }, u = 0, i = function(n2) {
      return null != n2 && void 0 === n2.constructor;
    }, d.prototype.setState = function(n2, l3) {
      var u3;
      u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n2 && (n2 = n2(s({}, u3), this.props)), n2 && s(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), b(this));
    }, d.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), b(this));
    }, d.prototype.render = p2, t = [], g.__r = 0, r = 0;
  }
});

// node_modules/.pnpm/preact@10.11.3/node_modules/preact/hooks/dist/hooks.module.js
function d2(t4, u3) {
  l.__h && l.__h(r2, t4, o2 || u3), o2 = 0;
  var i3 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t4 >= i3.__.length && i3.__.push({ __V: c2 }), i3.__[t4];
}
function p3(n2) {
  return o2 = 1, y2(B2, n2);
}
function y2(n2, u3, i3) {
  var o3 = d2(t2++, 2);
  if (o3.t = n2, !o3.__c && (o3.__ = [i3 ? i3(u3) : B2(void 0, u3), function(n3) {
    var t4 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t4, n3);
    t4 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r2, !r2.u)) {
    r2.u = true;
    var f3 = r2.shouldComponentUpdate;
    r2.shouldComponentUpdate = function(n3, t4, r3) {
      if (!o3.__c.__H)
        return true;
      var u4 = o3.__c.__H.__.filter(function(n4) {
        return n4.__c;
      });
      if (u4.every(function(n4) {
        return !n4.__N;
      }))
        return !f3 || f3.call(this, n3, t4, r3);
      var i4 = false;
      return u4.forEach(function(n4) {
        if (n4.__N) {
          var t5 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t5 !== n4.__[0] && (i4 = true);
        }
      }), !(!i4 && o3.__c.props === n3) && (!f3 || f3.call(this, n3, t4, r3));
    };
  }
  return o3.__N || o3.__;
}
function h2(u3, i3) {
  var o3 = d2(t2++, 3);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__H.__h.push(o3));
}
function s2(u3, i3) {
  var o3 = d2(t2++, 4);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__h.push(o3));
}
function _2(n2) {
  return o2 = 5, F(function() {
    return { current: n2 };
  }, []);
}
function A3(n2, t4, r3) {
  o2 = 6, s2(function() {
    return "function" == typeof n2 ? (n2(t4()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t4(), function() {
      return n2.current = null;
    }) : void 0;
  }, null == r3 ? r3 : r3.concat(n2));
}
function F(n2, r3) {
  var u3 = d2(t2++, 7);
  return z2(u3.__H, r3) ? (u3.__V = n2(), u3.i = r3, u3.__h = n2, u3.__V) : u3.__;
}
function T2(n2, t4) {
  return o2 = 8, F(function() {
    return n2;
  }, t4);
}
function q2(n2) {
  var u3 = r2.context[n2.__c], i3 = d2(t2++, 9);
  return i3.c = n2, u3 ? (null == i3.__ && (i3.__ = true, u3.sub(r2)), u3.props.value) : n2.__;
}
function x2(t4, r3) {
  l.useDebugValue && l.useDebugValue(r3 ? r3(t4) : t4);
}
function P2(n2) {
  var u3 = d2(t2++, 10), i3 = p3();
  return u3.__ = n2, r2.componentDidCatch || (r2.componentDidCatch = function(n3, t4) {
    u3.__ && u3.__(n3, t4), i3[1](n3);
  }), [i3[0], function() {
    i3[1](void 0);
  }];
}
function V() {
  var n2 = d2(t2++, 11);
  if (!n2.__) {
    for (var u3 = r2.__v; null !== u3 && !u3.__m && null !== u3.__; )
      u3 = u3.__;
    var i3 = u3.__m || (u3.__m = [0, 0]);
    n2.__ = "P" + i3[0] + "-" + i3[1]++;
  }
  return n2.__;
}
function b2() {
  for (var t4; t4 = f2.shift(); )
    if (t4.__P && t4.__H)
      try {
        t4.__H.__h.forEach(k2), t4.__H.__h.forEach(w2), t4.__H.__h = [];
      } catch (r3) {
        t4.__H.__h = [], l.__e(r3, t4.__v);
      }
}
function j2(n2) {
  var t4, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t4), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t4 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t4 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t4;
}
function w2(n2) {
  var t4 = r2;
  n2.__c = n2.__(), r2 = t4;
}
function z2(n2, t4) {
  return !n2 || n2.length !== t4.length || t4.some(function(t5, r3) {
    return t5 !== n2[r3];
  });
}
function B2(n2, t4) {
  return "function" == typeof t4 ? t4(n2) : t4;
}
var t2, r2, u2, i2, o2, f2, c2, e2, a2, v2, l2, m2, g2;
var init_hooks_module = __esm({
  "node_modules/.pnpm/preact@10.11.3/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o2 = 0;
    f2 = [];
    c2 = [];
    e2 = l.__b;
    a2 = l.__r;
    v2 = l.diffed;
    l2 = l.__c;
    m2 = l.unmount;
    l.__b = function(n2) {
      r2 = null, e2 && e2(n2);
    }, l.__r = function(n2) {
      a2 && a2(n2), t2 = 0;
      var i3 = (r2 = n2.__c).__H;
      i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
        n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
      })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
    }, l.diffed = function(t4) {
      v2 && v2(t4);
      var o3 = t4.__c;
      o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n2) {
        n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
      })), u2 = r2 = null;
    }, l.__c = function(t4, r3) {
      r3.some(function(t5) {
        try {
          t5.__h.forEach(k2), t5.__h = t5.__h.filter(function(n2) {
            return !n2.__ || w2(n2);
          });
        } catch (u3) {
          r3.some(function(n2) {
            n2.__h && (n2.__h = []);
          }), r3 = [], l.__e(u3, t5.__v);
        }
      }), l2 && l2(t4, r3);
    }, l.unmount = function(t4) {
      m2 && m2(t4);
      var r3, u3 = t4.__c;
      u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
        try {
          k2(n2);
        } catch (n3) {
          r3 = n3;
        }
      }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
    };
    g2 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/.pnpm/preact@10.11.3/node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => O2,
  Component: () => d,
  Fragment: () => p2,
  PureComponent: () => w3,
  StrictMode: () => vn2,
  Suspense: () => D3,
  SuspenseList: () => V2,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => rn,
  cloneElement: () => cn,
  createContext: () => B,
  createElement: () => h,
  createFactory: () => on,
  createPortal: () => j3,
  createRef: () => y,
  default: () => bn,
  findDOMNode: () => an,
  flushSync: () => hn,
  forwardRef: () => k3,
  hydrate: () => q3,
  isValidElement: () => ln,
  lazy: () => M3,
  memo: () => R,
  render: () => Y2,
  startTransition: () => dn,
  unmountComponentAtNode: () => fn,
  unstable_batchedUpdates: () => sn,
  useCallback: () => T2,
  useContext: () => q2,
  useDebugValue: () => x2,
  useDeferredValue: () => pn,
  useEffect: () => h2,
  useErrorBoundary: () => P2,
  useId: () => V,
  useImperativeHandle: () => A3,
  useInsertionEffect: () => yn,
  useLayoutEffect: () => s2,
  useMemo: () => F,
  useReducer: () => y2,
  useRef: () => _2,
  useState: () => p3,
  useSyncExternalStore: () => _n,
  useTransition: () => mn,
  version: () => un
});
function g3(n2, t4) {
  for (var e3 in t4)
    n2[e3] = t4[e3];
  return n2;
}
function C2(n2, t4) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t4))
      return true;
  for (var r3 in t4)
    if ("__source" !== r3 && n2[r3] !== t4[r3])
      return true;
  return false;
}
function E(n2, t4) {
  return n2 === t4 && (0 !== n2 || 1 / n2 == 1 / t4) || n2 != n2 && t4 != t4;
}
function w3(n2) {
  this.props = n2;
}
function R(n2, e3) {
  function r3(n3) {
    var t4 = this.props.ref, r4 = t4 == n3.ref;
    return !r4 && t4 && (t4.call ? t4(null) : t4.current = null), e3 ? !e3(this.props, n3) || !r4 : C2(this.props, n3);
  }
  function u3(e4) {
    return this.shouldComponentUpdate = r3, h(n2, e4);
  }
  return u3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u3.prototype.isReactComponent = true, u3.__f = true, u3;
}
function k3(n2) {
  function t4(t5) {
    var e3 = g3({}, t5);
    return delete e3.ref, n2(e3, t5.ref || null);
  }
  return t4.$$typeof = N2, t4.render = t4, t4.prototype.isReactComponent = t4.__f = true, t4.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t4;
}
function L3(n2, t4, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t4), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L3(n3, t4, e3);
  })), n2;
}
function U(n2, t4, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t4, e3);
  }), n2.__c && n2.__c.__P === t4 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D3() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F2(n2) {
  var t4 = n2.__.__c;
  return t4 && t4.__a && t4.__a(n2);
}
function M3(n2) {
  var e3, r3, u3;
  function o3(o4) {
    if (e3 || (e3 = n2()).then(function(n3) {
      r3 = n3.default || n3;
    }, function(n3) {
      u3 = n3;
    }), u3)
      throw u3;
    if (!r3)
      throw e3;
    return h(r3, o4);
  }
  return o3.displayName = "Lazy", o3.__f = true, o3;
}
function V2() {
  this.u = null, this.o = null;
}
function P3(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    P(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t4) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), P(h(P3, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = h($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
function Y2(n2, t4, e3) {
  return null == t4.__k && (t4.textContent = ""), P(n2, t4), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
function q3(n2, t4, e3) {
  return S2(n2, t4), "function" == typeof e3 && e3(), n2 ? n2.__c : null;
}
function J() {
}
function K3() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
function on(n2) {
  return h.bind(null, n2);
}
function ln(n2) {
  return !!n2 && n2.$$typeof === z3;
}
function cn(n2) {
  return ln(n2) ? q.apply(null, arguments) : n2;
}
function fn(n2) {
  return !!n2.__k && (P(null, n2), true);
}
function an(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
function dn(n2) {
  n2();
}
function pn(n2) {
  return n2;
}
function mn() {
  return [false, dn];
}
function _n(n2, t4) {
  var e3 = t4(), r3 = p3({ h: { __: e3, v: t4 } }), u3 = r3[0].h, o3 = r3[1];
  return s2(function() {
    u3.__ = e3, u3.v = t4, E(u3.__, t4()) || o3({ h: u3 });
  }, [n2, e3, t4]), h2(function() {
    return E(u3.__, u3.v()) || o3({ h: u3 }), n2(function() {
      E(u3.__, u3.v()) || o3({ h: u3 });
    });
  }, [n2]), e3;
}
var x3, N2, A4, O2, T3, I3, W, z3, B3, H2, Z2, G, X2, nn, tn, en, rn, un, sn, hn, vn2, yn, bn;
var init_compat_module = __esm({
  "node_modules/.pnpm/preact@10.11.3/node_modules/preact/compat/dist/compat.module.js"() {
    init_preact_module();
    init_preact_module();
    init_hooks_module();
    init_hooks_module();
    (w3.prototype = new d()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t4) {
      return C2(this.props, n2) || C2(this.state, t4);
    };
    x3 = l.__b;
    l.__b = function(n2) {
      n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
    };
    N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
    A4 = function(n2, t4) {
      return null == n2 ? null : x(x(n2).map(t4));
    };
    O2 = { map: A4, forEach: A4, count: function(n2) {
      return n2 ? x(n2).length : 0;
    }, only: function(n2) {
      var t4 = x(n2);
      if (1 !== t4.length)
        throw "Children.only";
      return t4[0];
    }, toArray: x };
    T3 = l.__e;
    l.__e = function(n2, t4, e3, r3) {
      if (n2.then) {
        for (var u3, o3 = t4; o3 = o3.__; )
          if ((u3 = o3.__c) && u3.__c)
            return null == t4.__e && (t4.__e = e3.__e, t4.__k = e3.__k), u3.__c(n2, t4);
      }
      T3(n2, t4, e3, r3);
    };
    I3 = l.unmount;
    l.unmount = function(n2) {
      var t4 = n2.__c;
      t4 && t4.__R && t4.__R(), t4 && true === n2.__h && (n2.type = null), I3 && I3(n2);
    }, (D3.prototype = new d()).__c = function(n2, t4) {
      var e3 = t4.__c, r3 = this;
      null == r3.t && (r3.t = []), r3.t.push(e3);
      var u3 = F2(r3.__v), o3 = false, i3 = function() {
        o3 || (o3 = true, e3.__R = null, u3 ? u3(l3) : l3());
      };
      e3.__R = i3;
      var l3 = function() {
        if (!--r3.__u) {
          if (r3.state.__a) {
            var n3 = r3.state.__a;
            r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
          }
          var t5;
          for (r3.setState({ __a: r3.__b = null }); t5 = r3.t.pop(); )
            t5.forceUpdate();
        }
      }, c6 = true === t4.__h;
      r3.__u++ || c6 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
    }, D3.prototype.componentWillUnmount = function() {
      this.t = [];
    }, D3.prototype.render = function(n2, e3) {
      if (this.__b) {
        if (this.__v.__k) {
          var r3 = document.createElement("div"), o3 = this.__v.__k[0].__c;
          this.__v.__k[0] = L3(this.__b, r3, o3.__O = o3.__P);
        }
        this.__b = null;
      }
      var i3 = e3.__a && h(p2, null, n2.fallback);
      return i3 && (i3.__h = null), [h(p2, null, e3.__a ? null : n2.children), i3];
    };
    W = function(n2, t4, e3) {
      if (++e3[1] === e3[0] && n2.o.delete(t4), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
        for (e3 = n2.u; e3; ) {
          for (; e3.length > 3; )
            e3.pop()();
          if (e3[1] < e3[0])
            break;
          n2.u = e3 = e3[2];
        }
    };
    (V2.prototype = new d()).__a = function(n2) {
      var t4 = this, e3 = F2(t4.__v), r3 = t4.o.get(n2);
      return r3[0]++, function(u3) {
        var o3 = function() {
          t4.props.revealOrder ? (r3.push(u3), W(t4, n2, r3)) : u3();
        };
        e3 ? e3(o3) : o3();
      };
    }, V2.prototype.render = function(n2) {
      this.u = null, this.o = /* @__PURE__ */ new Map();
      var t4 = x(n2.children);
      n2.revealOrder && "b" === n2.revealOrder[0] && t4.reverse();
      for (var e3 = t4.length; e3--; )
        this.o.set(t4[e3], this.u = [1, 0, this.u]);
      return n2.children;
    }, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
      var n2 = this;
      this.o.forEach(function(t4, e3) {
        W(n2, e3, t4);
      });
    };
    z3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    B3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    H2 = "undefined" != typeof document;
    Z2 = function(n2) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
    };
    d.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t4) {
      Object.defineProperty(d.prototype, t4, { configurable: true, get: function() {
        return this["UNSAFE_" + t4];
      }, set: function(n2) {
        Object.defineProperty(this, t4, { configurable: true, writable: true, value: n2 });
      } });
    });
    G = l.event;
    l.event = function(n2) {
      return G && (n2 = G(n2)), n2.persist = J, n2.isPropagationStopped = K3, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
    };
    nn = { configurable: true, get: function() {
      return this.class;
    } };
    tn = l.vnode;
    l.vnode = function(n2) {
      var t4 = n2.type, e3 = n2.props, u3 = e3;
      if ("string" == typeof t4) {
        var o3 = -1 === t4.indexOf("-");
        for (var i3 in u3 = {}, e3) {
          var l3 = e3[i3];
          H2 && "children" === i3 && "noscript" === t4 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t4) && !Z2(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o3 && B3.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
        }
        "select" == t4 && u3.multiple && Array.isArray(u3.value) && (u3.value = x(e3.children).forEach(function(n3) {
          n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
        })), "select" == t4 && null != u3.defaultValue && (u3.value = x(e3.children).forEach(function(n3) {
          n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
        })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
      }
      n2.$$typeof = z3, tn && tn(n2);
    };
    en = l.__r;
    l.__r = function(n2) {
      en && en(n2), X2 = n2.__c;
    };
    rn = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
      return X2.__n[n2.__c].props.value;
    } } } };
    un = "17.0.2";
    sn = function(n2, t4) {
      return n2(t4);
    };
    hn = function(n2, t4) {
      return n2(t4);
    };
    vn2 = p2;
    yn = s2;
    bn = { useState: p3, useId: V, useReducer: y2, useEffect: h2, useLayoutEffect: s2, useInsertionEffect: yn, useTransition: mn, useDeferredValue: pn, useSyncExternalStore: _n, startTransition: dn, useRef: _2, useImperativeHandle: A3, useMemo: F, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: O2, render: Y2, hydrate: q3, unmountComponentAtNode: fn, createPortal: j3, createElement: h, createContext: B, createFactory: on, cloneElement: cn, createRef: y, Fragment: p2, isValidElement: ln, findDOMNode: an, Component: d, PureComponent: w3, memo: R, forwardRef: k3, flushSync: hn, unstable_batchedUpdates: sn, StrictMode: vn2, Suspense: D3, SuspenseList: V2, lazy: M3, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: rn };
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js
var require_use_sync_external_store_shim_production_min = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js"(exports) {
    "use strict";
    var e3 = (init_compat_module(), __toCommonJS(compat_module_exports));
    function h3(a4, b3) {
      return a4 === b3 && (0 !== a4 || 1 / a4 === 1 / b3) || a4 !== a4 && b3 !== b3;
    }
    var k5 = "function" === typeof Object.is ? Object.is : h3;
    var l3 = e3.useState;
    var m3 = e3.useEffect;
    var n2 = e3.useLayoutEffect;
    var p4 = e3.useDebugValue;
    function q4(a4, b3) {
      var d3 = b3(), f3 = l3({ inst: { value: d3, getSnapshot: b3 } }), c6 = f3[0].inst, g4 = f3[1];
      n2(function() {
        c6.value = d3;
        c6.getSnapshot = b3;
        r3(c6) && g4({ inst: c6 });
      }, [a4, d3, b3]);
      m3(function() {
        r3(c6) && g4({ inst: c6 });
        return a4(function() {
          r3(c6) && g4({ inst: c6 });
        });
      }, [a4]);
      p4(d3);
      return d3;
    }
    function r3(a4) {
      var b3 = a4.getSnapshot;
      a4 = a4.value;
      try {
        var d3 = b3();
        return !k5(a4, d3);
      } catch (f3) {
        return true;
      }
    }
    function t4(a4, b3) {
      return b3();
    }
    var u3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t4 : q4;
    exports.useSyncExternalStore = void 0 !== e3.useSyncExternalStore ? e3.useSyncExternalStore : u3;
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_use_sync_external_store_shim_production_min();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/nacl-fast.js
var gf = function(init2 = []) {
  const r3 = new Float64Array(16);
  if (init2)
    for (let i3 = 0; i3 < init2.length; i3++)
      r3[i3] = init2[i3];
  return r3;
};
var randombytes = function(x6, n2) {
  throw new Error("no PRNG");
};
var _9 = new Uint8Array(32);
_9[0] = 9;
var gf0 = gf();
var gf1 = gf([1]);
var _121665 = gf([56129, 1]);
var D = gf([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]);
var D2 = gf([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]);
var X = gf([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]);
var Y = gf([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]);
var I = gf([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function ts64(x6, i3, h3, l3) {
  x6[i3] = h3 >> 24 & 255;
  x6[i3 + 1] = h3 >> 16 & 255;
  x6[i3 + 2] = h3 >> 8 & 255;
  x6[i3 + 3] = h3 & 255;
  x6[i3 + 4] = l3 >> 24 & 255;
  x6[i3 + 5] = l3 >> 16 & 255;
  x6[i3 + 6] = l3 >> 8 & 255;
  x6[i3 + 7] = l3 & 255;
}
function vn(x6, xi, y4, yi, n2) {
  let i3, d3 = 0;
  for (i3 = 0; i3 < n2; i3++)
    d3 |= x6[xi + i3] ^ y4[yi + i3];
  return (1 & d3 - 1 >>> 8) - 1;
}
function crypto_verify_32(x6, xi, y4, yi) {
  return vn(x6, xi, y4, yi, 32);
}
var sigma = new Uint8Array([
  101,
  120,
  112,
  97,
  110,
  100,
  32,
  51,
  50,
  45,
  98,
  121,
  116,
  101,
  32,
  107
]);
function set25519(r3, a4) {
  let i3;
  for (i3 = 0; i3 < 16; i3++)
    r3[i3] = a4[i3] | 0;
}
function car25519(o3) {
  let i3, v3, c6 = 1;
  for (i3 = 0; i3 < 16; i3++) {
    v3 = o3[i3] + c6 + 65535;
    c6 = Math.floor(v3 / 65536);
    o3[i3] = v3 - c6 * 65536;
  }
  o3[0] += c6 - 1 + 37 * (c6 - 1);
}
function sel25519(p4, q4, b3) {
  let t4;
  const c6 = ~(b3 - 1);
  for (let i3 = 0; i3 < 16; i3++) {
    t4 = c6 & (p4[i3] ^ q4[i3]);
    p4[i3] ^= t4;
    q4[i3] ^= t4;
  }
}
function pack25519(o3, n2) {
  let i3, j4, b3;
  const m3 = gf(), t4 = gf();
  for (i3 = 0; i3 < 16; i3++)
    t4[i3] = n2[i3];
  car25519(t4);
  car25519(t4);
  car25519(t4);
  for (j4 = 0; j4 < 2; j4++) {
    m3[0] = t4[0] - 65517;
    for (i3 = 1; i3 < 15; i3++) {
      m3[i3] = t4[i3] - 65535 - (m3[i3 - 1] >> 16 & 1);
      m3[i3 - 1] &= 65535;
    }
    m3[15] = t4[15] - 32767 - (m3[14] >> 16 & 1);
    b3 = m3[15] >> 16 & 1;
    m3[14] &= 65535;
    sel25519(t4, m3, 1 - b3);
  }
  for (i3 = 0; i3 < 16; i3++) {
    o3[2 * i3] = t4[i3] & 255;
    o3[2 * i3 + 1] = t4[i3] >> 8;
  }
}
function neq25519(a4, b3) {
  const c6 = new Uint8Array(32), d3 = new Uint8Array(32);
  pack25519(c6, a4);
  pack25519(d3, b3);
  return crypto_verify_32(c6, 0, d3, 0);
}
function par25519(a4) {
  const d3 = new Uint8Array(32);
  pack25519(d3, a4);
  return d3[0] & 1;
}
function unpack25519(o3, n2) {
  let i3;
  for (i3 = 0; i3 < 16; i3++)
    o3[i3] = n2[2 * i3] + (n2[2 * i3 + 1] << 8);
  o3[15] &= 32767;
}
function A(o3, a4, b3) {
  for (let i3 = 0; i3 < 16; i3++)
    o3[i3] = a4[i3] + b3[i3];
}
function Z(o3, a4, b3) {
  for (let i3 = 0; i3 < 16; i3++)
    o3[i3] = a4[i3] - b3[i3];
}
function M(o3, a4, b3) {
  let v3, c6, t03 = 0, t13 = 0, t23 = 0, t32 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t132 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t232 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
  const b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11], b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
  v3 = a4[0];
  t03 += v3 * b0;
  t13 += v3 * b1;
  t23 += v3 * b22;
  t32 += v3 * b32;
  t4 += v3 * b4;
  t5 += v3 * b5;
  t6 += v3 * b6;
  t7 += v3 * b7;
  t8 += v3 * b8;
  t9 += v3 * b9;
  t10 += v3 * b10;
  t11 += v3 * b11;
  t122 += v3 * b12;
  t132 += v3 * b13;
  t14 += v3 * b14;
  t15 += v3 * b15;
  v3 = a4[1];
  t13 += v3 * b0;
  t23 += v3 * b1;
  t32 += v3 * b22;
  t4 += v3 * b32;
  t5 += v3 * b4;
  t6 += v3 * b5;
  t7 += v3 * b6;
  t8 += v3 * b7;
  t9 += v3 * b8;
  t10 += v3 * b9;
  t11 += v3 * b10;
  t122 += v3 * b11;
  t132 += v3 * b12;
  t14 += v3 * b13;
  t15 += v3 * b14;
  t16 += v3 * b15;
  v3 = a4[2];
  t23 += v3 * b0;
  t32 += v3 * b1;
  t4 += v3 * b22;
  t5 += v3 * b32;
  t6 += v3 * b4;
  t7 += v3 * b5;
  t8 += v3 * b6;
  t9 += v3 * b7;
  t10 += v3 * b8;
  t11 += v3 * b9;
  t122 += v3 * b10;
  t132 += v3 * b11;
  t14 += v3 * b12;
  t15 += v3 * b13;
  t16 += v3 * b14;
  t17 += v3 * b15;
  v3 = a4[3];
  t32 += v3 * b0;
  t4 += v3 * b1;
  t5 += v3 * b22;
  t6 += v3 * b32;
  t7 += v3 * b4;
  t8 += v3 * b5;
  t9 += v3 * b6;
  t10 += v3 * b7;
  t11 += v3 * b8;
  t122 += v3 * b9;
  t132 += v3 * b10;
  t14 += v3 * b11;
  t15 += v3 * b12;
  t16 += v3 * b13;
  t17 += v3 * b14;
  t18 += v3 * b15;
  v3 = a4[4];
  t4 += v3 * b0;
  t5 += v3 * b1;
  t6 += v3 * b22;
  t7 += v3 * b32;
  t8 += v3 * b4;
  t9 += v3 * b5;
  t10 += v3 * b6;
  t11 += v3 * b7;
  t122 += v3 * b8;
  t132 += v3 * b9;
  t14 += v3 * b10;
  t15 += v3 * b11;
  t16 += v3 * b12;
  t17 += v3 * b13;
  t18 += v3 * b14;
  t19 += v3 * b15;
  v3 = a4[5];
  t5 += v3 * b0;
  t6 += v3 * b1;
  t7 += v3 * b22;
  t8 += v3 * b32;
  t9 += v3 * b4;
  t10 += v3 * b5;
  t11 += v3 * b6;
  t122 += v3 * b7;
  t132 += v3 * b8;
  t14 += v3 * b9;
  t15 += v3 * b10;
  t16 += v3 * b11;
  t17 += v3 * b12;
  t18 += v3 * b13;
  t19 += v3 * b14;
  t20 += v3 * b15;
  v3 = a4[6];
  t6 += v3 * b0;
  t7 += v3 * b1;
  t8 += v3 * b22;
  t9 += v3 * b32;
  t10 += v3 * b4;
  t11 += v3 * b5;
  t122 += v3 * b6;
  t132 += v3 * b7;
  t14 += v3 * b8;
  t15 += v3 * b9;
  t16 += v3 * b10;
  t17 += v3 * b11;
  t18 += v3 * b12;
  t19 += v3 * b13;
  t20 += v3 * b14;
  t21 += v3 * b15;
  v3 = a4[7];
  t7 += v3 * b0;
  t8 += v3 * b1;
  t9 += v3 * b22;
  t10 += v3 * b32;
  t11 += v3 * b4;
  t122 += v3 * b5;
  t132 += v3 * b6;
  t14 += v3 * b7;
  t15 += v3 * b8;
  t16 += v3 * b9;
  t17 += v3 * b10;
  t18 += v3 * b11;
  t19 += v3 * b12;
  t20 += v3 * b13;
  t21 += v3 * b14;
  t222 += v3 * b15;
  v3 = a4[8];
  t8 += v3 * b0;
  t9 += v3 * b1;
  t10 += v3 * b22;
  t11 += v3 * b32;
  t122 += v3 * b4;
  t132 += v3 * b5;
  t14 += v3 * b6;
  t15 += v3 * b7;
  t16 += v3 * b8;
  t17 += v3 * b9;
  t18 += v3 * b10;
  t19 += v3 * b11;
  t20 += v3 * b12;
  t21 += v3 * b13;
  t222 += v3 * b14;
  t232 += v3 * b15;
  v3 = a4[9];
  t9 += v3 * b0;
  t10 += v3 * b1;
  t11 += v3 * b22;
  t122 += v3 * b32;
  t132 += v3 * b4;
  t14 += v3 * b5;
  t15 += v3 * b6;
  t16 += v3 * b7;
  t17 += v3 * b8;
  t18 += v3 * b9;
  t19 += v3 * b10;
  t20 += v3 * b11;
  t21 += v3 * b12;
  t222 += v3 * b13;
  t232 += v3 * b14;
  t24 += v3 * b15;
  v3 = a4[10];
  t10 += v3 * b0;
  t11 += v3 * b1;
  t122 += v3 * b22;
  t132 += v3 * b32;
  t14 += v3 * b4;
  t15 += v3 * b5;
  t16 += v3 * b6;
  t17 += v3 * b7;
  t18 += v3 * b8;
  t19 += v3 * b9;
  t20 += v3 * b10;
  t21 += v3 * b11;
  t222 += v3 * b12;
  t232 += v3 * b13;
  t24 += v3 * b14;
  t25 += v3 * b15;
  v3 = a4[11];
  t11 += v3 * b0;
  t122 += v3 * b1;
  t132 += v3 * b22;
  t14 += v3 * b32;
  t15 += v3 * b4;
  t16 += v3 * b5;
  t17 += v3 * b6;
  t18 += v3 * b7;
  t19 += v3 * b8;
  t20 += v3 * b9;
  t21 += v3 * b10;
  t222 += v3 * b11;
  t232 += v3 * b12;
  t24 += v3 * b13;
  t25 += v3 * b14;
  t26 += v3 * b15;
  v3 = a4[12];
  t122 += v3 * b0;
  t132 += v3 * b1;
  t14 += v3 * b22;
  t15 += v3 * b32;
  t16 += v3 * b4;
  t17 += v3 * b5;
  t18 += v3 * b6;
  t19 += v3 * b7;
  t20 += v3 * b8;
  t21 += v3 * b9;
  t222 += v3 * b10;
  t232 += v3 * b11;
  t24 += v3 * b12;
  t25 += v3 * b13;
  t26 += v3 * b14;
  t27 += v3 * b15;
  v3 = a4[13];
  t132 += v3 * b0;
  t14 += v3 * b1;
  t15 += v3 * b22;
  t16 += v3 * b32;
  t17 += v3 * b4;
  t18 += v3 * b5;
  t19 += v3 * b6;
  t20 += v3 * b7;
  t21 += v3 * b8;
  t222 += v3 * b9;
  t232 += v3 * b10;
  t24 += v3 * b11;
  t25 += v3 * b12;
  t26 += v3 * b13;
  t27 += v3 * b14;
  t28 += v3 * b15;
  v3 = a4[14];
  t14 += v3 * b0;
  t15 += v3 * b1;
  t16 += v3 * b22;
  t17 += v3 * b32;
  t18 += v3 * b4;
  t19 += v3 * b5;
  t20 += v3 * b6;
  t21 += v3 * b7;
  t222 += v3 * b8;
  t232 += v3 * b9;
  t24 += v3 * b10;
  t25 += v3 * b11;
  t26 += v3 * b12;
  t27 += v3 * b13;
  t28 += v3 * b14;
  t29 += v3 * b15;
  v3 = a4[15];
  t15 += v3 * b0;
  t16 += v3 * b1;
  t17 += v3 * b22;
  t18 += v3 * b32;
  t19 += v3 * b4;
  t20 += v3 * b5;
  t21 += v3 * b6;
  t222 += v3 * b7;
  t232 += v3 * b8;
  t24 += v3 * b9;
  t25 += v3 * b10;
  t26 += v3 * b11;
  t27 += v3 * b12;
  t28 += v3 * b13;
  t29 += v3 * b14;
  t30 += v3 * b15;
  t03 += 38 * t16;
  t13 += 38 * t17;
  t23 += 38 * t18;
  t32 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t222;
  t7 += 38 * t232;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t122 += 38 * t28;
  t132 += 38 * t29;
  t14 += 38 * t30;
  c6 = 1;
  v3 = t03 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t03 = v3 - c6 * 65536;
  v3 = t13 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t13 = v3 - c6 * 65536;
  v3 = t23 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t23 = v3 - c6 * 65536;
  v3 = t32 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t32 = v3 - c6 * 65536;
  v3 = t4 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t4 = v3 - c6 * 65536;
  v3 = t5 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t5 = v3 - c6 * 65536;
  v3 = t6 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t6 = v3 - c6 * 65536;
  v3 = t7 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t7 = v3 - c6 * 65536;
  v3 = t8 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t8 = v3 - c6 * 65536;
  v3 = t9 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t9 = v3 - c6 * 65536;
  v3 = t10 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t10 = v3 - c6 * 65536;
  v3 = t11 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t11 = v3 - c6 * 65536;
  v3 = t122 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t122 = v3 - c6 * 65536;
  v3 = t132 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t132 = v3 - c6 * 65536;
  v3 = t14 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t14 = v3 - c6 * 65536;
  v3 = t15 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t15 = v3 - c6 * 65536;
  t03 += c6 - 1 + 37 * (c6 - 1);
  c6 = 1;
  v3 = t03 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t03 = v3 - c6 * 65536;
  v3 = t13 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t13 = v3 - c6 * 65536;
  v3 = t23 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t23 = v3 - c6 * 65536;
  v3 = t32 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t32 = v3 - c6 * 65536;
  v3 = t4 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t4 = v3 - c6 * 65536;
  v3 = t5 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t5 = v3 - c6 * 65536;
  v3 = t6 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t6 = v3 - c6 * 65536;
  v3 = t7 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t7 = v3 - c6 * 65536;
  v3 = t8 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t8 = v3 - c6 * 65536;
  v3 = t9 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t9 = v3 - c6 * 65536;
  v3 = t10 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t10 = v3 - c6 * 65536;
  v3 = t11 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t11 = v3 - c6 * 65536;
  v3 = t122 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t122 = v3 - c6 * 65536;
  v3 = t132 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t132 = v3 - c6 * 65536;
  v3 = t14 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t14 = v3 - c6 * 65536;
  v3 = t15 + c6 + 65535;
  c6 = Math.floor(v3 / 65536);
  t15 = v3 - c6 * 65536;
  t03 += c6 - 1 + 37 * (c6 - 1);
  o3[0] = t03;
  o3[1] = t13;
  o3[2] = t23;
  o3[3] = t32;
  o3[4] = t4;
  o3[5] = t5;
  o3[6] = t6;
  o3[7] = t7;
  o3[8] = t8;
  o3[9] = t9;
  o3[10] = t10;
  o3[11] = t11;
  o3[12] = t122;
  o3[13] = t132;
  o3[14] = t14;
  o3[15] = t15;
}
function S(o3, a4) {
  M(o3, a4, a4);
}
function inv25519(o3, i3) {
  const c6 = gf();
  let a4;
  for (a4 = 0; a4 < 16; a4++)
    c6[a4] = i3[a4];
  for (a4 = 253; a4 >= 0; a4--) {
    S(c6, c6);
    if (a4 !== 2 && a4 !== 4)
      M(c6, c6, i3);
  }
  for (a4 = 0; a4 < 16; a4++)
    o3[a4] = c6[a4];
}
function pow2523(o3, i3) {
  const c6 = gf();
  let a4;
  for (a4 = 0; a4 < 16; a4++)
    c6[a4] = i3[a4];
  for (a4 = 250; a4 >= 0; a4--) {
    S(c6, c6);
    if (a4 !== 1)
      M(c6, c6, i3);
  }
  for (a4 = 0; a4 < 16; a4++)
    o3[a4] = c6[a4];
}
var K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function crypto_hashblocks_hl(hh, hl, m3, n2) {
  const wh = new Int32Array(16), wl = new Int32Array(16);
  let bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i3, j4, h3, l3, a4, b3, c6, d3;
  let ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
  let pos = 0;
  while (n2 >= 128) {
    for (i3 = 0; i3 < 16; i3++) {
      j4 = 8 * i3 + pos;
      wh[i3] = m3[j4 + 0] << 24 | m3[j4 + 1] << 16 | m3[j4 + 2] << 8 | m3[j4 + 3];
      wl[i3] = m3[j4 + 4] << 24 | m3[j4 + 5] << 16 | m3[j4 + 6] << 8 | m3[j4 + 7];
    }
    for (i3 = 0; i3 < 80; i3++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;
      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;
      h3 = ah7;
      l3 = al7;
      a4 = l3 & 65535;
      b3 = l3 >>> 16;
      c6 = h3 & 65535;
      d3 = h3 >>> 16;
      h3 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
      l3 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      h3 = ah4 & ah5 ^ ~ah4 & ah6;
      l3 = al4 & al5 ^ ~al4 & al6;
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      h3 = K[i3 * 2];
      l3 = K[i3 * 2 + 1];
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      h3 = wh[i3 % 16];
      l3 = wl[i3 % 16];
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      b3 += a4 >>> 16;
      c6 += b3 >>> 16;
      d3 += c6 >>> 16;
      th = c6 & 65535 | d3 << 16;
      tl = a4 & 65535 | b3 << 16;
      h3 = th;
      l3 = tl;
      a4 = l3 & 65535;
      b3 = l3 >>> 16;
      c6 = h3 & 65535;
      d3 = h3 >>> 16;
      h3 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
      l3 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      h3 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
      l3 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      b3 += a4 >>> 16;
      c6 += b3 >>> 16;
      d3 += c6 >>> 16;
      bh7 = c6 & 65535 | d3 << 16;
      bl7 = a4 & 65535 | b3 << 16;
      h3 = bh3;
      l3 = bl3;
      a4 = l3 & 65535;
      b3 = l3 >>> 16;
      c6 = h3 & 65535;
      d3 = h3 >>> 16;
      h3 = th;
      l3 = tl;
      a4 += l3 & 65535;
      b3 += l3 >>> 16;
      c6 += h3 & 65535;
      d3 += h3 >>> 16;
      b3 += a4 >>> 16;
      c6 += b3 >>> 16;
      d3 += c6 >>> 16;
      bh3 = c6 & 65535 | d3 << 16;
      bl3 = a4 & 65535 | b3 << 16;
      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;
      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;
      if (i3 % 16 === 15) {
        for (j4 = 0; j4 < 16; j4++) {
          h3 = wh[j4];
          l3 = wl[j4];
          a4 = l3 & 65535;
          b3 = l3 >>> 16;
          c6 = h3 & 65535;
          d3 = h3 >>> 16;
          h3 = wh[(j4 + 9) % 16];
          l3 = wl[(j4 + 9) % 16];
          a4 += l3 & 65535;
          b3 += l3 >>> 16;
          c6 += h3 & 65535;
          d3 += h3 >>> 16;
          th = wh[(j4 + 1) % 16];
          tl = wl[(j4 + 1) % 16];
          h3 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
          l3 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
          a4 += l3 & 65535;
          b3 += l3 >>> 16;
          c6 += h3 & 65535;
          d3 += h3 >>> 16;
          th = wh[(j4 + 14) % 16];
          tl = wl[(j4 + 14) % 16];
          h3 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
          l3 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
          a4 += l3 & 65535;
          b3 += l3 >>> 16;
          c6 += h3 & 65535;
          d3 += h3 >>> 16;
          b3 += a4 >>> 16;
          c6 += b3 >>> 16;
          d3 += c6 >>> 16;
          wh[j4] = c6 & 65535 | d3 << 16;
          wl[j4] = a4 & 65535 | b3 << 16;
        }
      }
    }
    h3 = ah0;
    l3 = al0;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[0];
    l3 = hl[0];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[0] = ah0 = c6 & 65535 | d3 << 16;
    hl[0] = al0 = a4 & 65535 | b3 << 16;
    h3 = ah1;
    l3 = al1;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[1];
    l3 = hl[1];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[1] = ah1 = c6 & 65535 | d3 << 16;
    hl[1] = al1 = a4 & 65535 | b3 << 16;
    h3 = ah2;
    l3 = al2;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[2];
    l3 = hl[2];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[2] = ah2 = c6 & 65535 | d3 << 16;
    hl[2] = al2 = a4 & 65535 | b3 << 16;
    h3 = ah3;
    l3 = al3;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[3];
    l3 = hl[3];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[3] = ah3 = c6 & 65535 | d3 << 16;
    hl[3] = al3 = a4 & 65535 | b3 << 16;
    h3 = ah4;
    l3 = al4;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[4];
    l3 = hl[4];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[4] = ah4 = c6 & 65535 | d3 << 16;
    hl[4] = al4 = a4 & 65535 | b3 << 16;
    h3 = ah5;
    l3 = al5;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[5];
    l3 = hl[5];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[5] = ah5 = c6 & 65535 | d3 << 16;
    hl[5] = al5 = a4 & 65535 | b3 << 16;
    h3 = ah6;
    l3 = al6;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[6];
    l3 = hl[6];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[6] = ah6 = c6 & 65535 | d3 << 16;
    hl[6] = al6 = a4 & 65535 | b3 << 16;
    h3 = ah7;
    l3 = al7;
    a4 = l3 & 65535;
    b3 = l3 >>> 16;
    c6 = h3 & 65535;
    d3 = h3 >>> 16;
    h3 = hh[7];
    l3 = hl[7];
    a4 += l3 & 65535;
    b3 += l3 >>> 16;
    c6 += h3 & 65535;
    d3 += h3 >>> 16;
    b3 += a4 >>> 16;
    c6 += b3 >>> 16;
    d3 += c6 >>> 16;
    hh[7] = ah7 = c6 & 65535 | d3 << 16;
    hl[7] = al7 = a4 & 65535 | b3 << 16;
    pos += 128;
    n2 -= 128;
  }
  return n2;
}
function crypto_hash(out, m3, n2) {
  const hh = new Int32Array(8);
  const hl = new Int32Array(8);
  const x6 = new Uint8Array(256);
  const b3 = n2;
  hh[0] = 1779033703;
  hh[1] = 3144134277;
  hh[2] = 1013904242;
  hh[3] = 2773480762;
  hh[4] = 1359893119;
  hh[5] = 2600822924;
  hh[6] = 528734635;
  hh[7] = 1541459225;
  hl[0] = 4089235720;
  hl[1] = 2227873595;
  hl[2] = 4271175723;
  hl[3] = 1595750129;
  hl[4] = 2917565137;
  hl[5] = 725511199;
  hl[6] = 4215389547;
  hl[7] = 327033209;
  crypto_hashblocks_hl(hh, hl, m3, n2);
  n2 %= 128;
  for (let i3 = 0; i3 < n2; i3++)
    x6[i3] = m3[b3 - n2 + i3];
  x6[n2] = 128;
  n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
  x6[n2 - 9] = 0;
  ts64(x6, n2 - 8, b3 / 536870912 | 0, b3 << 3);
  crypto_hashblocks_hl(hh, hl, x6, n2);
  for (let i3 = 0; i3 < 8; i3++)
    ts64(out, 8 * i3, hh[i3], hl[i3]);
  return 0;
}
var HashState = class {
  constructor() {
    this.hh = new Int32Array(8);
    this.hl = new Int32Array(8);
    this.next = new Uint8Array(128);
    this.p = 0;
    this.total = 0;
    this.hh[0] = 1779033703;
    this.hh[1] = 3144134277;
    this.hh[2] = 1013904242;
    this.hh[3] = 2773480762;
    this.hh[4] = 1359893119;
    this.hh[5] = 2600822924;
    this.hh[6] = 528734635;
    this.hh[7] = 1541459225;
    this.hl[0] = 4089235720;
    this.hl[1] = 2227873595;
    this.hl[2] = 4271175723;
    this.hl[3] = 1595750129;
    this.hl[4] = 2917565137;
    this.hl[5] = 725511199;
    this.hl[6] = 4215389547;
    this.hl[7] = 327033209;
  }
  update(data) {
    this.total += data.length;
    let i3 = 0;
    while (i3 < data.length) {
      const r3 = 128 - this.p;
      if (r3 > data.length - i3) {
        for (let j4 = 0; i3 + j4 < data.length; j4++) {
          this.next[this.p + j4] = data[i3 + j4];
        }
        this.p += data.length - i3;
        break;
      } else {
        for (let j4 = 0; this.p + j4 < 128; j4++) {
          this.next[this.p + j4] = data[i3 + j4];
        }
        crypto_hashblocks_hl(this.hh, this.hl, this.next, 128);
        i3 += 128 - this.p;
        this.p = 0;
      }
    }
    return this;
  }
  finish() {
    const out = new Uint8Array(64);
    let n2 = this.p;
    const x6 = new Uint8Array(256);
    const b3 = this.total;
    for (let i3 = 0; i3 < n2; i3++)
      x6[i3] = this.next[i3];
    x6[n2] = 128;
    n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
    x6[n2 - 9] = 0;
    ts64(x6, n2 - 8, b3 / 536870912 | 0, b3 << 3);
    crypto_hashblocks_hl(this.hh, this.hl, x6, n2);
    for (let i3 = 0; i3 < 8; i3++)
      ts64(out, 8 * i3, this.hh[i3], this.hl[i3]);
    return out;
  }
};
function add(p4, q4) {
  const a4 = gf(), b3 = gf(), c6 = gf(), d3 = gf(), e3 = gf(), f3 = gf(), g4 = gf(), h3 = gf(), t4 = gf();
  Z(a4, p4[1], p4[0]);
  Z(t4, q4[1], q4[0]);
  M(a4, a4, t4);
  A(b3, p4[0], p4[1]);
  A(t4, q4[0], q4[1]);
  M(b3, b3, t4);
  M(c6, p4[3], q4[3]);
  M(c6, c6, D2);
  M(d3, p4[2], q4[2]);
  A(d3, d3, d3);
  Z(e3, b3, a4);
  Z(f3, d3, c6);
  A(g4, d3, c6);
  A(h3, b3, a4);
  M(p4[0], e3, f3);
  M(p4[1], h3, g4);
  M(p4[2], g4, f3);
  M(p4[3], e3, h3);
}
function cswap(p4, q4, b3) {
  let i3;
  for (i3 = 0; i3 < 4; i3++) {
    sel25519(p4[i3], q4[i3], b3);
  }
}
function pack(r3, p4) {
  const tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p4[2]);
  M(tx, p4[0], zi);
  M(ty, p4[1], zi);
  pack25519(r3, ty);
  r3[31] ^= par25519(tx) << 7;
}
function scalarmult(p4, q4, s4) {
  let b3, i3;
  set25519(p4[0], gf0);
  set25519(p4[1], gf1);
  set25519(p4[2], gf1);
  set25519(p4[3], gf0);
  for (i3 = 255; i3 >= 0; --i3) {
    b3 = s4[i3 / 8 | 0] >> (i3 & 7) & 1;
    cswap(p4, q4, b3);
    add(q4, p4);
    add(p4, p4);
    cswap(p4, q4, b3);
  }
}
function scalarbase(p4, s4) {
  const q4 = [gf(), gf(), gf(), gf()];
  set25519(q4[0], X);
  set25519(q4[1], Y);
  set25519(q4[2], gf1);
  M(q4[3], X, Y);
  scalarmult(p4, q4, s4);
}
var L = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]);
function modL(r3, x6) {
  let carry, i3, j4, k5;
  for (i3 = 63; i3 >= 32; --i3) {
    carry = 0;
    for (j4 = i3 - 32, k5 = i3 - 12; j4 < k5; ++j4) {
      x6[j4] += carry - 16 * x6[i3] * L[j4 - (i3 - 32)];
      carry = Math.floor((x6[j4] + 128) / 256);
      x6[j4] -= carry * 256;
    }
    x6[j4] += carry;
    x6[i3] = 0;
  }
  carry = 0;
  for (j4 = 0; j4 < 32; j4++) {
    x6[j4] += carry - (x6[31] >> 4) * L[j4];
    carry = x6[j4] >> 8;
    x6[j4] &= 255;
  }
  for (j4 = 0; j4 < 32; j4++)
    x6[j4] -= carry * L[j4];
  for (i3 = 0; i3 < 32; i3++) {
    x6[i3 + 1] += x6[i3] >> 8;
    r3[i3] = x6[i3] & 255;
  }
}
function reduce(r3) {
  const x6 = new Float64Array(64);
  for (let i3 = 0; i3 < 64; i3++)
    x6[i3] = r3[i3];
  for (let i3 = 0; i3 < 64; i3++)
    r3[i3] = 0;
  modL(r3, x6);
}
function unpackpos(r3, p4) {
  const q4 = [gf(), gf(), gf(), gf()];
  if (unpackneg(q4, p4))
    return -1;
  const scalar0 = new Uint8Array(32);
  const scalar1 = new Uint8Array(32);
  scalar1[0] = 1;
  const scalarNeg1 = crypto_core_ed25519_scalar_sub(scalar0, scalar1);
  scalarmult(r3, q4, scalarNeg1);
  return 0;
}
function unpackneg(r3, p4) {
  const t4 = gf();
  const chk = gf();
  const num = gf();
  const den = gf();
  const den2 = gf();
  const den4 = gf();
  const den6 = gf();
  set25519(r3[2], gf1);
  unpack25519(r3[1], p4);
  S(num, r3[1]);
  M(den, num, D);
  Z(num, num, r3[2]);
  A(den, r3[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t4, den6, num);
  M(t4, t4, den);
  pow2523(t4, t4);
  M(t4, t4, num);
  M(t4, t4, den);
  M(t4, t4, den);
  M(r3[0], t4, den);
  S(chk, r3[0]);
  M(chk, chk, den);
  if (neq25519(chk, num))
    M(r3[0], r3[0], I);
  S(chk, r3[0]);
  M(chk, chk, den);
  if (neq25519(chk, num))
    return -1;
  if (par25519(r3[0]) === p4[31] >> 7)
    Z(r3[0], gf0, r3[0]);
  M(r3[3], r3[0], r3[1]);
  return 0;
}
function crypto_scalarmult_ed25519_base_noclamp(s4) {
  const r3 = new Uint8Array(32);
  const p4 = [gf(), gf(), gf(), gf()];
  scalarbase(p4, s4);
  pack(r3, p4);
  return r3;
}
function crypto_scalarmult_ed25519_noclamp(s4, q4) {
  const r3 = new Uint8Array(32);
  const p4 = [gf(), gf(), gf(), gf()];
  const ql = [gf(), gf(), gf(), gf()];
  if (unpackpos(ql, q4))
    throw new Error();
  scalarmult(p4, ql, s4);
  pack(r3, p4);
  return r3;
}
function crypto_sign_open(m3, sm, n2, pk) {
  let i3, mlen;
  const t4 = new Uint8Array(32), h3 = new Uint8Array(64);
  const p4 = [gf(), gf(), gf(), gf()], q4 = [gf(), gf(), gf(), gf()];
  mlen = -1;
  if (n2 < 64)
    return -1;
  if (unpackneg(q4, pk))
    return -1;
  for (i3 = 0; i3 < n2; i3++)
    m3[i3] = sm[i3];
  for (i3 = 0; i3 < 32; i3++)
    m3[i3 + 32] = pk[i3];
  crypto_hash(h3, m3, n2);
  reduce(h3);
  scalarmult(p4, q4, h3);
  scalarbase(q4, sm.subarray(32));
  add(p4, q4);
  pack(t4, p4);
  n2 -= 64;
  if (crypto_verify_32(sm, 0, t4, 0)) {
    for (i3 = 0; i3 < n2; i3++)
      m3[i3] = 0;
    return -1;
  }
  for (i3 = 0; i3 < n2; i3++)
    m3[i3] = sm[i3 + 64];
  mlen = n2;
  return mlen;
}
var crypto_sign_BYTES = 64;
var crypto_sign_PUBLICKEYBYTES = 32;
var crypto_hash_BYTES = 64;
function checkArrayTypes(...args) {
  for (let i3 = 0; i3 < args.length; i3++) {
    if (!(args[i3] instanceof Uint8Array))
      throw new TypeError("unexpected type, use Uint8Array");
  }
}
function randomBytes(n2) {
  const b3 = new Uint8Array(n2);
  randombytes(b3, n2);
  return b3;
}
function hash(msg) {
  checkArrayTypes(msg);
  const h3 = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h3, msg, msg.length);
  return h3;
}
function setPRNG(fn2) {
  randombytes = fn2;
}
function crypto_core_ed25519_scalar_reduce(x6) {
  const len = x6.length;
  const z4 = new Float64Array(64);
  for (let i3 = 0; i3 < len; i3++)
    z4[i3] = x6[i3];
  const o3 = new Uint8Array(32);
  modL(o3, z4);
  return o3;
}
function crypto_core_ed25519_scalar_sub(x6, y4) {
  const z4 = new Float64Array(64);
  for (let i3 = 0; i3 < 32; i3++) {
    z4[i3] = x6[i3] - y4[i3];
  }
  const o3 = new Uint8Array(32);
  modL(o3, z4);
  return o3;
}
function crypto_edx25519_private_key_create() {
  const seed = new Uint8Array(32);
  randombytes(seed, 32);
  return crypto_edx25519_private_key_create_from_seed(seed);
}
function crypto_edx25519_private_key_create_from_seed(seed) {
  const pk = hash(seed);
  pk[0] &= 248;
  pk[31] &= 127;
  pk[31] |= 64;
  return pk;
}
function crypto_edx25519_get_public(priv) {
  return crypto_scalarmult_ed25519_base_noclamp(priv.subarray(0, 32));
}
function crypto_edx25519_sign_detached(m3, skx, pkx) {
  const n2 = m3.length;
  const h3 = new Uint8Array(64);
  const r3 = new Uint8Array(64);
  let i3, j4;
  const x6 = new Float64Array(64);
  const p4 = [gf(), gf(), gf(), gf()];
  const sm = new Uint8Array(n2 + 64);
  for (i3 = 0; i3 < n2; i3++)
    sm[64 + i3] = m3[i3];
  for (i3 = 0; i3 < 32; i3++)
    sm[32 + i3] = skx[32 + i3];
  crypto_hash(r3, sm.subarray(32), n2 + 32);
  reduce(r3);
  scalarbase(p4, r3);
  pack(sm, p4);
  for (i3 = 32; i3 < 64; i3++)
    sm[i3] = pkx[i3 - 32];
  crypto_hash(h3, sm, n2 + 64);
  reduce(h3);
  for (i3 = 0; i3 < 64; i3++)
    x6[i3] = 0;
  for (i3 = 0; i3 < 32; i3++)
    x6[i3] = r3[i3];
  for (i3 = 0; i3 < 32; i3++) {
    for (j4 = 0; j4 < 32; j4++) {
      x6[i3 + j4] += h3[i3] * skx[j4];
    }
  }
  modL(sm.subarray(32), x6);
  return sm.subarray(0, 64);
}
function crypto_edx25519_sign_detached_verify(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error("bad signature size");
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error("bad public key size");
  const sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  const m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
  let i3;
  for (i3 = 0; i3 < crypto_sign_BYTES; i3++)
    sm[i3] = sig[i3];
  for (i3 = 0; i3 < msg.length; i3++)
    sm[i3 + crypto_sign_BYTES] = msg[i3];
  return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/prng-browser.js
function loadBrowserPrng() {
  const cr = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
  const QUOTA = 65536;
  setPRNG(function(x6, n2) {
    let i3;
    const v3 = new Uint8Array(n2);
    for (i3 = 0; i3 < n2; i3 += QUOTA) {
      cr.getRandomValues(v3.subarray(i3, i3 + Math.min(n2 - i3, QUOTA)));
    }
    for (i3 = 0; i3 < n2; i3++)
      x6[i3] = v3[i3];
    for (i3 = 0; i3 < v3.length; i3++)
      v3[i3] = 0;
  });
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/taler-error-codes.js
var TalerErrorCode;
(function(TalerErrorCode2) {
  TalerErrorCode2[TalerErrorCode2["NONE"] = 0] = "NONE";
  TalerErrorCode2[TalerErrorCode2["INVALID"] = 1] = "INVALID";
  TalerErrorCode2[TalerErrorCode2["GENERIC_CLIENT_INTERNAL_ERROR"] = 2] = "GENERIC_CLIENT_INTERNAL_ERROR";
  TalerErrorCode2[TalerErrorCode2["GENERIC_CLIENT_UNSUPPORTED_PROTOCOL_VERSION"] = 3] = "GENERIC_CLIENT_UNSUPPORTED_PROTOCOL_VERSION";
  TalerErrorCode2[TalerErrorCode2["GENERIC_INVALID_RESPONSE"] = 10] = "GENERIC_INVALID_RESPONSE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_TIMEOUT"] = 11] = "GENERIC_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["GENERIC_VERSION_MALFORMED"] = 12] = "GENERIC_VERSION_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_REPLY_MALFORMED"] = 13] = "GENERIC_REPLY_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_CONFIGURATION_INVALID"] = 14] = "GENERIC_CONFIGURATION_INVALID";
  TalerErrorCode2[TalerErrorCode2["GENERIC_UNEXPECTED_REQUEST_ERROR"] = 15] = "GENERIC_UNEXPECTED_REQUEST_ERROR";
  TalerErrorCode2[TalerErrorCode2["GENERIC_TOKEN_PERMISSION_INSUFFICIENT"] = 16] = "GENERIC_TOKEN_PERMISSION_INSUFFICIENT";
  TalerErrorCode2[TalerErrorCode2["GENERIC_METHOD_INVALID"] = 20] = "GENERIC_METHOD_INVALID";
  TalerErrorCode2[TalerErrorCode2["GENERIC_ENDPOINT_UNKNOWN"] = 21] = "GENERIC_ENDPOINT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["GENERIC_JSON_INVALID"] = 22] = "GENERIC_JSON_INVALID";
  TalerErrorCode2[TalerErrorCode2["GENERIC_HTTP_HEADERS_MALFORMED"] = 23] = "GENERIC_HTTP_HEADERS_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_PAYTO_URI_MALFORMED"] = 24] = "GENERIC_PAYTO_URI_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_PARAMETER_MISSING"] = 25] = "GENERIC_PARAMETER_MISSING";
  TalerErrorCode2[TalerErrorCode2["GENERIC_PARAMETER_MALFORMED"] = 26] = "GENERIC_PARAMETER_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_RESERVE_PUB_MALFORMED"] = 27] = "GENERIC_RESERVE_PUB_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_COMPRESSION_INVALID"] = 28] = "GENERIC_COMPRESSION_INVALID";
  TalerErrorCode2[TalerErrorCode2["GENERIC_PATH_SEGMENT_MALFORMED"] = 29] = "GENERIC_PATH_SEGMENT_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_CURRENCY_MISMATCH"] = 30] = "GENERIC_CURRENCY_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["GENERIC_URI_TOO_LONG"] = 31] = "GENERIC_URI_TOO_LONG";
  TalerErrorCode2[TalerErrorCode2["GENERIC_UPLOAD_EXCEEDS_LIMIT"] = 32] = "GENERIC_UPLOAD_EXCEEDS_LIMIT";
  TalerErrorCode2[TalerErrorCode2["GENERIC_UNAUTHORIZED"] = 40] = "GENERIC_UNAUTHORIZED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_TOKEN_UNKNOWN"] = 41] = "GENERIC_TOKEN_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["GENERIC_TOKEN_EXPIRED"] = 42] = "GENERIC_TOKEN_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_TOKEN_MALFORMED"] = 43] = "GENERIC_TOKEN_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_FORBIDDEN"] = 44] = "GENERIC_FORBIDDEN";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_SETUP_FAILED"] = 50] = "GENERIC_DB_SETUP_FAILED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_START_FAILED"] = 51] = "GENERIC_DB_START_FAILED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_STORE_FAILED"] = 52] = "GENERIC_DB_STORE_FAILED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_FETCH_FAILED"] = 53] = "GENERIC_DB_FETCH_FAILED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_COMMIT_FAILED"] = 54] = "GENERIC_DB_COMMIT_FAILED";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_SOFT_FAILURE"] = 55] = "GENERIC_DB_SOFT_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_DB_INVARIANT_FAILURE"] = 56] = "GENERIC_DB_INVARIANT_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_INTERNAL_INVARIANT_FAILURE"] = 60] = "GENERIC_INTERNAL_INVARIANT_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_FAILED_COMPUTE_JSON_HASH"] = 61] = "GENERIC_FAILED_COMPUTE_JSON_HASH";
  TalerErrorCode2[TalerErrorCode2["GENERIC_FAILED_COMPUTE_AMOUNT"] = 62] = "GENERIC_FAILED_COMPUTE_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["GENERIC_PARSER_OUT_OF_MEMORY"] = 70] = "GENERIC_PARSER_OUT_OF_MEMORY";
  TalerErrorCode2[TalerErrorCode2["GENERIC_ALLOCATION_FAILURE"] = 71] = "GENERIC_ALLOCATION_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_JSON_ALLOCATION_FAILURE"] = 72] = "GENERIC_JSON_ALLOCATION_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_CURL_ALLOCATION_FAILURE"] = 73] = "GENERIC_CURL_ALLOCATION_FAILURE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_FAILED_TO_LOAD_TEMPLATE"] = 74] = "GENERIC_FAILED_TO_LOAD_TEMPLATE";
  TalerErrorCode2[TalerErrorCode2["GENERIC_FAILED_TO_EXPAND_TEMPLATE"] = 75] = "GENERIC_FAILED_TO_EXPAND_TEMPLATE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_BAD_CONFIGURATION"] = 1e3] = "EXCHANGE_GENERIC_BAD_CONFIGURATION";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_OPERATION_UNKNOWN"] = 1001] = "EXCHANGE_GENERIC_OPERATION_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_WRONG_NUMBER_OF_SEGMENTS"] = 1002] = "EXCHANGE_GENERIC_WRONG_NUMBER_OF_SEGMENTS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_COIN_CONFLICTING_DENOMINATION_KEY"] = 1003] = "EXCHANGE_GENERIC_COIN_CONFLICTING_DENOMINATION_KEY";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_COINS_INVALID_COIN_PUB"] = 1004] = "EXCHANGE_GENERIC_COINS_INVALID_COIN_PUB";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_DENOMINATION_KEY_UNKNOWN"] = 1005] = "EXCHANGE_GENERIC_DENOMINATION_KEY_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DENOMINATION_SIGNATURE_INVALID"] = 1006] = "EXCHANGE_DENOMINATION_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_KEYS_MISSING"] = 1007] = "EXCHANGE_GENERIC_KEYS_MISSING";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_DENOMINATION_VALIDITY_IN_FUTURE"] = 1008] = "EXCHANGE_GENERIC_DENOMINATION_VALIDITY_IN_FUTURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_DENOMINATION_EXPIRED"] = 1009] = "EXCHANGE_GENERIC_DENOMINATION_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_DENOMINATION_REVOKED"] = 1010] = "EXCHANGE_GENERIC_DENOMINATION_REVOKED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_SECMOD_TIMEOUT"] = 1011] = "EXCHANGE_GENERIC_SECMOD_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_INSUFFICIENT_FUNDS"] = 1012] = "EXCHANGE_GENERIC_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_COIN_HISTORY_COMPUTATION_FAILED"] = 1013] = "EXCHANGE_GENERIC_COIN_HISTORY_COMPUTATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_HISTORY_DB_ERROR_INSUFFICIENT_FUNDS"] = 1014] = "EXCHANGE_GENERIC_HISTORY_DB_ERROR_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_COIN_CONFLICTING_AGE_HASH"] = 1015] = "EXCHANGE_GENERIC_COIN_CONFLICTING_AGE_HASH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_INVALID_DENOMINATION_CIPHER_FOR_OPERATION"] = 1016] = "EXCHANGE_GENERIC_INVALID_DENOMINATION_CIPHER_FOR_OPERATION";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_CIPHER_MISMATCH"] = 1017] = "EXCHANGE_GENERIC_CIPHER_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_NEW_DENOMS_ARRAY_SIZE_EXCESSIVE"] = 1018] = "EXCHANGE_GENERIC_NEW_DENOMS_ARRAY_SIZE_EXCESSIVE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_COIN_UNKNOWN"] = 1019] = "EXCHANGE_GENERIC_COIN_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_CLOCK_SKEW"] = 1020] = "EXCHANGE_GENERIC_CLOCK_SKEW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AMOUNT_EXCEEDS_DENOMINATION_VALUE"] = 1021] = "EXCHANGE_GENERIC_AMOUNT_EXCEEDS_DENOMINATION_VALUE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_GLOBAL_FEES_MISSING"] = 1022] = "EXCHANGE_GENERIC_GLOBAL_FEES_MISSING";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_WIRE_FEES_MISSING"] = 1023] = "EXCHANGE_GENERIC_WIRE_FEES_MISSING";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_PURSE_PUB_MALFORMED"] = 1024] = "EXCHANGE_GENERIC_PURSE_PUB_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_PURSE_UNKNOWN"] = 1025] = "EXCHANGE_GENERIC_PURSE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_PURSE_EXPIRED"] = 1026] = "EXCHANGE_GENERIC_PURSE_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_RESERVE_UNKNOWN"] = 1027] = "EXCHANGE_GENERIC_RESERVE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_KYC_REQUIRED"] = 1028] = "EXCHANGE_GENERIC_KYC_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_COIN_CONFLICTING_ATTEST_VS_AGE_COMMITMENT"] = 1029] = "EXCHANGE_PURSE_DEPOSIT_COIN_CONFLICTING_ATTEST_VS_AGE_COMMITMENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_COIN_AGE_ATTESTATION_FAILURE"] = 1030] = "EXCHANGE_PURSE_DEPOSIT_COIN_AGE_ATTESTATION_FAILURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_PURSE_DELETED"] = 1031] = "EXCHANGE_GENERIC_PURSE_DELETED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AML_OFFICER_PUB_MALFORMED"] = 1032] = "EXCHANGE_GENERIC_AML_OFFICER_PUB_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AML_OFFICER_GET_SIGNATURE_INVALID"] = 1033] = "EXCHANGE_GENERIC_AML_OFFICER_GET_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AML_OFFICER_ACCESS_DENIED"] = 1034] = "EXCHANGE_GENERIC_AML_OFFICER_ACCESS_DENIED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AML_PENDING"] = 1035] = "EXCHANGE_GENERIC_AML_PENDING";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_AML_FROZEN"] = 1036] = "EXCHANGE_GENERIC_AML_FROZEN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GENERIC_KYC_CONVERTER_FAILED"] = 1037] = "EXCHANGE_GENERIC_KYC_CONVERTER_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_NOT_FOUND"] = 1100] = "EXCHANGE_DEPOSITS_GET_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_INVALID_H_WIRE"] = 1101] = "EXCHANGE_DEPOSITS_GET_INVALID_H_WIRE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_INVALID_MERCHANT_PUB"] = 1102] = "EXCHANGE_DEPOSITS_GET_INVALID_MERCHANT_PUB";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_INVALID_H_CONTRACT_TERMS"] = 1103] = "EXCHANGE_DEPOSITS_GET_INVALID_H_CONTRACT_TERMS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_INVALID_COIN_PUB"] = 1104] = "EXCHANGE_DEPOSITS_GET_INVALID_COIN_PUB";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_INVALID_SIGNATURE_BY_EXCHANGE"] = 1105] = "EXCHANGE_DEPOSITS_GET_INVALID_SIGNATURE_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_GET_MERCHANT_SIGNATURE_INVALID"] = 1106] = "EXCHANGE_DEPOSITS_GET_MERCHANT_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSITS_POLICY_NOT_ACCEPTED"] = 1107] = "EXCHANGE_DEPOSITS_POLICY_NOT_ACCEPTED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_INSUFFICIENT_FUNDS"] = 1150] = "EXCHANGE_WITHDRAW_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_INSUFFICIENT_FUNDS"] = 1151] = "EXCHANGE_AGE_WITHDRAW_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_AMOUNT_FEE_OVERFLOW"] = 1152] = "EXCHANGE_WITHDRAW_AMOUNT_FEE_OVERFLOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_SIGNATURE_FAILED"] = 1153] = "EXCHANGE_WITHDRAW_SIGNATURE_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_RESERVE_SIGNATURE_INVALID"] = 1154] = "EXCHANGE_WITHDRAW_RESERVE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVE_HISTORY_ERROR_INSUFFICIENT_FUNDS"] = 1155] = "EXCHANGE_RESERVE_HISTORY_ERROR_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_GET_RESERVE_HISTORY_ERROR_INSUFFICIENT_BALANCE"] = 1156] = "EXCHANGE_GET_RESERVE_HISTORY_ERROR_INSUFFICIENT_BALANCE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_DENOMINATION_KEY_LOST"] = 1158] = "EXCHANGE_WITHDRAW_DENOMINATION_KEY_LOST";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_UNBLIND_FAILURE"] = 1159] = "EXCHANGE_WITHDRAW_UNBLIND_FAILURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_NONCE_REUSE"] = 1160] = "EXCHANGE_WITHDRAW_NONCE_REUSE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_COMMITMENT_UNKNOWN"] = 1161] = "EXCHANGE_AGE_WITHDRAW_COMMITMENT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_AMOUNT_OVERFLOW"] = 1162] = "EXCHANGE_AGE_WITHDRAW_AMOUNT_OVERFLOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_AMOUNT_INCORRECT"] = 1163] = "EXCHANGE_AGE_WITHDRAW_AMOUNT_INCORRECT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_REVEAL_INVALID_HASH"] = 1164] = "EXCHANGE_AGE_WITHDRAW_REVEAL_INVALID_HASH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AGE_WITHDRAW_MAXIMUM_AGE_TOO_LARGE"] = 1165] = "EXCHANGE_AGE_WITHDRAW_MAXIMUM_AGE_TOO_LARGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WITHDRAW_BATCH_IDEMPOTENT_PLANCHET"] = 1175] = "EXCHANGE_WITHDRAW_BATCH_IDEMPOTENT_PLANCHET";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_COIN_SIGNATURE_INVALID"] = 1205] = "EXCHANGE_DEPOSIT_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_CONFLICTING_CONTRACT"] = 1206] = "EXCHANGE_DEPOSIT_CONFLICTING_CONTRACT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_NEGATIVE_VALUE_AFTER_FEE"] = 1207] = "EXCHANGE_DEPOSIT_NEGATIVE_VALUE_AFTER_FEE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_REFUND_DEADLINE_AFTER_WIRE_DEADLINE"] = 1208] = "EXCHANGE_DEPOSIT_REFUND_DEADLINE_AFTER_WIRE_DEADLINE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_WIRE_DEADLINE_IS_NEVER"] = 1209] = "EXCHANGE_DEPOSIT_WIRE_DEADLINE_IS_NEVER";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_INVALID_WIRE_FORMAT_JSON"] = 1210] = "EXCHANGE_DEPOSIT_INVALID_WIRE_FORMAT_JSON";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_INVALID_WIRE_FORMAT_CONTRACT_HASH_CONFLICT"] = 1211] = "EXCHANGE_DEPOSIT_INVALID_WIRE_FORMAT_CONTRACT_HASH_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_INVALID_SIGNATURE_BY_EXCHANGE"] = 1221] = "EXCHANGE_DEPOSIT_INVALID_SIGNATURE_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DEPOSIT_FEE_ABOVE_AMOUNT"] = 1222] = "EXCHANGE_DEPOSIT_FEE_ABOVE_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_EXTENSIONS_INVALID_FULFILLMENT"] = 1240] = "EXCHANGE_EXTENSIONS_INVALID_FULFILLMENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_COIN_HISTORY_BAD_SIGNATURE"] = 1251] = "EXCHANGE_COIN_HISTORY_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVE_HISTORY_BAD_SIGNATURE"] = 1252] = "EXCHANGE_RESERVE_HISTORY_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MELT_FEES_EXCEED_CONTRIBUTION"] = 1302] = "EXCHANGE_MELT_FEES_EXCEED_CONTRIBUTION";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MELT_COIN_SIGNATURE_INVALID"] = 1303] = "EXCHANGE_MELT_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MELT_COIN_EXPIRED_NO_ZOMBIE"] = 1305] = "EXCHANGE_MELT_COIN_EXPIRED_NO_ZOMBIE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MELT_INVALID_SIGNATURE_BY_EXCHANGE"] = 1306] = "EXCHANGE_MELT_INVALID_SIGNATURE_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_COMMITMENT_VIOLATION"] = 1353] = "EXCHANGE_REFRESHES_REVEAL_COMMITMENT_VIOLATION";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_SIGNING_ERROR"] = 1354] = "EXCHANGE_REFRESHES_REVEAL_SIGNING_ERROR";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_SESSION_UNKNOWN"] = 1355] = "EXCHANGE_REFRESHES_REVEAL_SESSION_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_CNC_TRANSFER_ARRAY_SIZE_INVALID"] = 1356] = "EXCHANGE_REFRESHES_REVEAL_CNC_TRANSFER_ARRAY_SIZE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_NEW_DENOMS_ARRAY_SIZE_MISMATCH"] = 1358] = "EXCHANGE_REFRESHES_REVEAL_NEW_DENOMS_ARRAY_SIZE_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_COST_CALCULATION_OVERFLOW"] = 1359] = "EXCHANGE_REFRESHES_REVEAL_COST_CALCULATION_OVERFLOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_AMOUNT_INSUFFICIENT"] = 1360] = "EXCHANGE_REFRESHES_REVEAL_AMOUNT_INSUFFICIENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_LINK_SIGNATURE_INVALID"] = 1361] = "EXCHANGE_REFRESHES_REVEAL_LINK_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_INVALID_RCH"] = 1362] = "EXCHANGE_REFRESHES_REVEAL_INVALID_RCH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_OPERATION_INVALID"] = 1363] = "EXCHANGE_REFRESHES_REVEAL_OPERATION_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_AGE_RESTRICTION_NOT_SUPPORTED"] = 1364] = "EXCHANGE_REFRESHES_REVEAL_AGE_RESTRICTION_NOT_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFRESHES_REVEAL_AGE_RESTRICTION_COMMITMENT_INVALID"] = 1365] = "EXCHANGE_REFRESHES_REVEAL_AGE_RESTRICTION_COMMITMENT_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_LINK_COIN_UNKNOWN"] = 1400] = "EXCHANGE_LINK_COIN_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_TRANSFERS_GET_WTID_MALFORMED"] = 1450] = "EXCHANGE_TRANSFERS_GET_WTID_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_TRANSFERS_GET_WTID_NOT_FOUND"] = 1451] = "EXCHANGE_TRANSFERS_GET_WTID_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_TRANSFERS_GET_WIRE_FEE_NOT_FOUND"] = 1452] = "EXCHANGE_TRANSFERS_GET_WIRE_FEE_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_TRANSFERS_GET_WIRE_FEE_INCONSISTENT"] = 1453] = "EXCHANGE_TRANSFERS_GET_WIRE_FEE_INCONSISTENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSES_INVALID_WAIT_TARGET"] = 1475] = "EXCHANGE_PURSES_INVALID_WAIT_TARGET";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSES_GET_INVALID_SIGNATURE_BY_EXCHANGE"] = 1476] = "EXCHANGE_PURSES_GET_INVALID_SIGNATURE_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_COIN_NOT_FOUND"] = 1500] = "EXCHANGE_REFUND_COIN_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_CONFLICT_DEPOSIT_INSUFFICIENT"] = 1501] = "EXCHANGE_REFUND_CONFLICT_DEPOSIT_INSUFFICIENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_DEPOSIT_NOT_FOUND"] = 1502] = "EXCHANGE_REFUND_DEPOSIT_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_MERCHANT_ALREADY_PAID"] = 1503] = "EXCHANGE_REFUND_MERCHANT_ALREADY_PAID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_FEE_TOO_LOW"] = 1504] = "EXCHANGE_REFUND_FEE_TOO_LOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_FEE_ABOVE_AMOUNT"] = 1505] = "EXCHANGE_REFUND_FEE_ABOVE_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_MERCHANT_SIGNATURE_INVALID"] = 1506] = "EXCHANGE_REFUND_MERCHANT_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_MERCHANT_SIGNING_FAILED"] = 1507] = "EXCHANGE_REFUND_MERCHANT_SIGNING_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_INVALID_SIGNATURE_BY_EXCHANGE"] = 1508] = "EXCHANGE_REFUND_INVALID_SIGNATURE_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_INVALID_FAILURE_PROOF_BY_EXCHANGE"] = 1509] = "EXCHANGE_REFUND_INVALID_FAILURE_PROOF_BY_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_REFUND_INCONSISTENT_AMOUNT"] = 1510] = "EXCHANGE_REFUND_INCONSISTENT_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_SIGNATURE_INVALID"] = 1550] = "EXCHANGE_RECOUP_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_WITHDRAW_NOT_FOUND"] = 1551] = "EXCHANGE_RECOUP_WITHDRAW_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_COIN_BALANCE_ZERO"] = 1552] = "EXCHANGE_RECOUP_COIN_BALANCE_ZERO";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_BLINDING_FAILED"] = 1553] = "EXCHANGE_RECOUP_BLINDING_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_COIN_BALANCE_NEGATIVE"] = 1554] = "EXCHANGE_RECOUP_COIN_BALANCE_NEGATIVE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_NOT_ELIGIBLE"] = 1555] = "EXCHANGE_RECOUP_NOT_ELIGIBLE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_REFRESH_SIGNATURE_INVALID"] = 1575] = "EXCHANGE_RECOUP_REFRESH_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_REFRESH_MELT_NOT_FOUND"] = 1576] = "EXCHANGE_RECOUP_REFRESH_MELT_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_REFRESH_BLINDING_FAILED"] = 1578] = "EXCHANGE_RECOUP_REFRESH_BLINDING_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RECOUP_REFRESH_NOT_ELIGIBLE"] = 1580] = "EXCHANGE_RECOUP_REFRESH_NOT_ELIGIBLE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KEYS_TIMETRAVEL_FORBIDDEN"] = 1600] = "EXCHANGE_KEYS_TIMETRAVEL_FORBIDDEN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WIRE_SIGNATURE_INVALID"] = 1650] = "EXCHANGE_WIRE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WIRE_NO_ACCOUNTS_CONFIGURED"] = 1651] = "EXCHANGE_WIRE_NO_ACCOUNTS_CONFIGURED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WIRE_INVALID_PAYTO_CONFIGURED"] = 1652] = "EXCHANGE_WIRE_INVALID_PAYTO_CONFIGURED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_WIRE_FEES_NOT_CONFIGURED"] = 1653] = "EXCHANGE_WIRE_FEES_NOT_CONFIGURED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_CREATE_CONFLICTING_META_DATA"] = 1675] = "EXCHANGE_RESERVES_PURSE_CREATE_CONFLICTING_META_DATA";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_MERGE_CONFLICTING_META_DATA"] = 1676] = "EXCHANGE_RESERVES_PURSE_MERGE_CONFLICTING_META_DATA";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_CREATE_INSUFFICIENT_FUNDS"] = 1677] = "EXCHANGE_RESERVES_PURSE_CREATE_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_FEE_TOO_LOW"] = 1678] = "EXCHANGE_RESERVES_PURSE_FEE_TOO_LOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DELETE_ALREADY_DECIDED"] = 1679] = "EXCHANGE_PURSE_DELETE_ALREADY_DECIDED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DELETE_SIGNATURE_INVALID"] = 1680] = "EXCHANGE_PURSE_DELETE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_AGE_RESTRICTION_REQUIRED"] = 1681] = "EXCHANGE_RESERVES_AGE_RESTRICTION_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DENOMINATION_HELPER_UNAVAILABLE"] = 1700] = "EXCHANGE_DENOMINATION_HELPER_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DENOMINATION_HELPER_BUG"] = 1701] = "EXCHANGE_DENOMINATION_HELPER_BUG";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_DENOMINATION_HELPER_TOO_EARLY"] = 1702] = "EXCHANGE_DENOMINATION_HELPER_TOO_EARLY";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_EXCHANGE_SIGNATURE_INVALID"] = 1725] = "EXCHANGE_PURSE_DEPOSIT_EXCHANGE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_SIGNKEY_HELPER_UNAVAILABLE"] = 1750] = "EXCHANGE_SIGNKEY_HELPER_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_SIGNKEY_HELPER_BUG"] = 1751] = "EXCHANGE_SIGNKEY_HELPER_BUG";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_SIGNKEY_HELPER_TOO_EARLY"] = 1752] = "EXCHANGE_SIGNKEY_HELPER_TOO_EARLY";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_EXPIRATION_BEFORE_NOW"] = 1775] = "EXCHANGE_RESERVES_PURSE_EXPIRATION_BEFORE_NOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_EXPIRATION_IS_NEVER"] = 1776] = "EXCHANGE_RESERVES_PURSE_EXPIRATION_IS_NEVER";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_PURSE_MERGE_SIGNATURE_INVALID"] = 1777] = "EXCHANGE_RESERVES_PURSE_MERGE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_RESERVE_MERGE_SIGNATURE_INVALID"] = 1778] = "EXCHANGE_RESERVES_RESERVE_MERGE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_OPEN_BAD_SIGNATURE"] = 1785] = "EXCHANGE_RESERVES_OPEN_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_CLOSE_BAD_SIGNATURE"] = 1786] = "EXCHANGE_RESERVES_CLOSE_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_ATTEST_BAD_SIGNATURE"] = 1787] = "EXCHANGE_RESERVES_ATTEST_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_CLOSE_NO_TARGET_ACCOUNT"] = 1788] = "EXCHANGE_RESERVES_CLOSE_NO_TARGET_ACCOUNT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_RESERVES_OPEN_INSUFFICIENT_FUNDS"] = 1789] = "EXCHANGE_RESERVES_OPEN_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_AUDITOR_NOT_FOUND"] = 1800] = "EXCHANGE_MANAGEMENT_AUDITOR_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_AUDITOR_MORE_RECENT_PRESENT"] = 1801] = "EXCHANGE_MANAGEMENT_AUDITOR_MORE_RECENT_PRESENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_AUDITOR_ADD_SIGNATURE_INVALID"] = 1802] = "EXCHANGE_MANAGEMENT_AUDITOR_ADD_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_AUDITOR_DEL_SIGNATURE_INVALID"] = 1803] = "EXCHANGE_MANAGEMENT_AUDITOR_DEL_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_DENOMINATION_REVOKE_SIGNATURE_INVALID"] = 1804] = "EXCHANGE_MANAGEMENT_DENOMINATION_REVOKE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_SIGNKEY_REVOKE_SIGNATURE_INVALID"] = 1805] = "EXCHANGE_MANAGEMENT_SIGNKEY_REVOKE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_MORE_RECENT_PRESENT"] = 1806] = "EXCHANGE_MANAGEMENT_WIRE_MORE_RECENT_PRESENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_KEYS_SIGNKEY_UNKNOWN"] = 1807] = "EXCHANGE_MANAGEMENT_KEYS_SIGNKEY_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_DETAILS_SIGNATURE_INVALID"] = 1808] = "EXCHANGE_MANAGEMENT_WIRE_DETAILS_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_ADD_SIGNATURE_INVALID"] = 1809] = "EXCHANGE_MANAGEMENT_WIRE_ADD_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_DEL_SIGNATURE_INVALID"] = 1810] = "EXCHANGE_MANAGEMENT_WIRE_DEL_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_NOT_FOUND"] = 1811] = "EXCHANGE_MANAGEMENT_WIRE_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_FEE_SIGNATURE_INVALID"] = 1812] = "EXCHANGE_MANAGEMENT_WIRE_FEE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_WIRE_FEE_MISMATCH"] = 1813] = "EXCHANGE_MANAGEMENT_WIRE_FEE_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_KEYS_DENOMKEY_ADD_SIGNATURE_INVALID"] = 1814] = "EXCHANGE_MANAGEMENT_KEYS_DENOMKEY_ADD_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_KEYS_SIGNKEY_ADD_SIGNATURE_INVALID"] = 1815] = "EXCHANGE_MANAGEMENT_KEYS_SIGNKEY_ADD_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_GLOBAL_FEE_MISMATCH"] = 1816] = "EXCHANGE_MANAGEMENT_GLOBAL_FEE_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_GLOBAL_FEE_SIGNATURE_INVALID"] = 1817] = "EXCHANGE_MANAGEMENT_GLOBAL_FEE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_DRAIN_PROFITS_SIGNATURE_INVALID"] = 1818] = "EXCHANGE_MANAGEMENT_DRAIN_PROFITS_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AML_DECISION_ADD_SIGNATURE_INVALID"] = 1825] = "EXCHANGE_AML_DECISION_ADD_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AML_DECISION_INVALID_OFFICER"] = 1826] = "EXCHANGE_AML_DECISION_INVALID_OFFICER";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AML_DECISION_MORE_RECENT_PRESENT"] = 1827] = "EXCHANGE_AML_DECISION_MORE_RECENT_PRESENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AML_DECISION_UNKNOWN_CHECK"] = 1828] = "EXCHANGE_AML_DECISION_UNKNOWN_CHECK";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_UPDATE_AML_OFFICER_SIGNATURE_INVALID"] = 1830] = "EXCHANGE_MANAGEMENT_UPDATE_AML_OFFICER_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_AML_OFFICERS_MORE_RECENT_PRESENT"] = 1831] = "EXCHANGE_MANAGEMENT_AML_OFFICERS_MORE_RECENT_PRESENT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_CONFLICTING_META_DATA"] = 1850] = "EXCHANGE_PURSE_CREATE_CONFLICTING_META_DATA";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_CONFLICTING_CONTRACT_STORED"] = 1851] = "EXCHANGE_PURSE_CREATE_CONFLICTING_CONTRACT_STORED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_COIN_SIGNATURE_INVALID"] = 1852] = "EXCHANGE_PURSE_CREATE_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_EXPIRATION_BEFORE_NOW"] = 1853] = "EXCHANGE_PURSE_CREATE_EXPIRATION_BEFORE_NOW";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_EXPIRATION_IS_NEVER"] = 1854] = "EXCHANGE_PURSE_CREATE_EXPIRATION_IS_NEVER";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_SIGNATURE_INVALID"] = 1855] = "EXCHANGE_PURSE_CREATE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_ECONTRACT_SIGNATURE_INVALID"] = 1856] = "EXCHANGE_PURSE_ECONTRACT_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_CREATE_EXCHANGE_SIGNATURE_INVALID"] = 1857] = "EXCHANGE_PURSE_CREATE_EXCHANGE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_CONFLICTING_META_DATA"] = 1858] = "EXCHANGE_PURSE_DEPOSIT_CONFLICTING_META_DATA";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_ECONTRACT_CONFLICTING_META_DATA"] = 1859] = "EXCHANGE_PURSE_ECONTRACT_CONFLICTING_META_DATA";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CREATE_PURSE_NEGATIVE_VALUE_AFTER_FEE"] = 1860] = "EXCHANGE_CREATE_PURSE_NEGATIVE_VALUE_AFTER_FEE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_MERGE_INVALID_MERGE_SIGNATURE"] = 1876] = "EXCHANGE_PURSE_MERGE_INVALID_MERGE_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_MERGE_INVALID_RESERVE_SIGNATURE"] = 1877] = "EXCHANGE_PURSE_MERGE_INVALID_RESERVE_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_NOT_FULL"] = 1878] = "EXCHANGE_PURSE_NOT_FULL";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_MERGE_EXCHANGE_SIGNATURE_INVALID"] = 1879] = "EXCHANGE_PURSE_MERGE_EXCHANGE_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MERGE_PURSE_PARTNER_UNKNOWN"] = 1880] = "EXCHANGE_MERGE_PURSE_PARTNER_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_ADD_PARTNER_SIGNATURE_INVALID"] = 1890] = "EXCHANGE_MANAGEMENT_ADD_PARTNER_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_MANAGEMENT_ADD_PARTNER_DATA_CONFLICT"] = 1891] = "EXCHANGE_MANAGEMENT_ADD_PARTNER_DATA_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AUDITORS_AUDITOR_SIGNATURE_INVALID"] = 1900] = "EXCHANGE_AUDITORS_AUDITOR_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AUDITORS_AUDITOR_UNKNOWN"] = 1901] = "EXCHANGE_AUDITORS_AUDITOR_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_AUDITORS_AUDITOR_INACTIVE"] = 1902] = "EXCHANGE_AUDITORS_AUDITOR_INACTIVE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_WALLET_SIGNATURE_INVALID"] = 1925] = "EXCHANGE_KYC_WALLET_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_PROOF_BACKEND_INVALID_RESPONSE"] = 1926] = "EXCHANGE_KYC_PROOF_BACKEND_INVALID_RESPONSE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_PROOF_BACKEND_ERROR"] = 1927] = "EXCHANGE_KYC_PROOF_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_PROOF_BACKEND_AUTHORIZATION_FAILED"] = 1928] = "EXCHANGE_KYC_PROOF_BACKEND_AUTHORIZATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_PROOF_REQUEST_UNKNOWN"] = 1929] = "EXCHANGE_KYC_PROOF_REQUEST_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_CHECK_AUTHORIZATION_FAILED"] = 1930] = "EXCHANGE_KYC_CHECK_AUTHORIZATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_LOGIC_UNKNOWN"] = 1931] = "EXCHANGE_KYC_GENERIC_LOGIC_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_LOGIC_GONE"] = 1932] = "EXCHANGE_KYC_GENERIC_LOGIC_GONE";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_LOGIC_BUG"] = 1933] = "EXCHANGE_KYC_GENERIC_LOGIC_BUG";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_PROVIDER_ACCESS_REFUSED"] = 1934] = "EXCHANGE_KYC_GENERIC_PROVIDER_ACCESS_REFUSED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_PROVIDER_TIMEOUT"] = 1935] = "EXCHANGE_KYC_GENERIC_PROVIDER_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_PROVIDER_UNEXPECTED_REPLY"] = 1936] = "EXCHANGE_KYC_GENERIC_PROVIDER_UNEXPECTED_REPLY";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_GENERIC_PROVIDER_RATE_LIMIT_EXCEEDED"] = 1937] = "EXCHANGE_KYC_GENERIC_PROVIDER_RATE_LIMIT_EXCEEDED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_WEBHOOK_UNAUTHORIZED"] = 1938] = "EXCHANGE_KYC_WEBHOOK_UNAUTHORIZED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_CHECK_REQUEST_UNKNOWN"] = 1939] = "EXCHANGE_KYC_CHECK_REQUEST_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_CHECK_AUTHORIZATION_KEY_UNKNOWN"] = 1940] = "EXCHANGE_KYC_CHECK_AUTHORIZATION_KEY_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_FORM_ALREADY_UPLOADED"] = 1941] = "EXCHANGE_KYC_FORM_ALREADY_UPLOADED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_MEASURES_MALFORMED"] = 1942] = "EXCHANGE_KYC_MEASURES_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_MEASURE_INDEX_INVALID"] = 1943] = "EXCHANGE_KYC_MEASURE_INDEX_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_KYC_INVALID_LOGIC_TO_CHECK"] = 1944] = "EXCHANGE_KYC_INVALID_LOGIC_TO_CHECK";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CONTRACTS_UNKNOWN"] = 1950] = "EXCHANGE_CONTRACTS_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CONTRACTS_INVALID_CONTRACT_PUB"] = 1951] = "EXCHANGE_CONTRACTS_INVALID_CONTRACT_PUB";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CONTRACTS_DECRYPTION_FAILED"] = 1952] = "EXCHANGE_CONTRACTS_DECRYPTION_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CONTRACTS_SIGNATURE_INVALID"] = 1953] = "EXCHANGE_CONTRACTS_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_CONTRACTS_DECODING_FAILED"] = 1954] = "EXCHANGE_CONTRACTS_DECODING_FAILED";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_COIN_SIGNATURE_INVALID"] = 1975] = "EXCHANGE_PURSE_DEPOSIT_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_PURSE_DEPOSIT_DECIDED_ALREADY"] = 1976] = "EXCHANGE_PURSE_DEPOSIT_DECIDED_ALREADY";
  TalerErrorCode2[TalerErrorCode2["EXCHANGE_TOTP_KEY_INVALID"] = 1980] = "EXCHANGE_TOTP_KEY_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_INSTANCE_UNKNOWN"] = 2e3] = "MERCHANT_GENERIC_INSTANCE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_HOLE_IN_WIRE_FEE_STRUCTURE"] = 2001] = "MERCHANT_GENERIC_HOLE_IN_WIRE_FEE_STRUCTURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_WIRE_REQUEST_FAILED"] = 2002] = "MERCHANT_GENERIC_EXCHANGE_WIRE_REQUEST_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_CATEGORY_UNKNOWN"] = 2003] = "MERCHANT_GENERIC_CATEGORY_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_ORDER_UNKNOWN"] = 2005] = "MERCHANT_GENERIC_ORDER_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_PRODUCT_UNKNOWN"] = 2006] = "MERCHANT_GENERIC_PRODUCT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_REWARD_ID_UNKNOWN"] = 2007] = "MERCHANT_GENERIC_REWARD_ID_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_DB_CONTRACT_CONTENT_INVALID"] = 2008] = "MERCHANT_GENERIC_DB_CONTRACT_CONTENT_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_CONTRACT_HASH_DOES_NOT_MATCH_ORDER"] = 2009] = "MERCHANT_GENERIC_CONTRACT_HASH_DOES_NOT_MATCH_ORDER";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_KEYS_FAILURE"] = 2010] = "MERCHANT_GENERIC_EXCHANGE_KEYS_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_TIMEOUT"] = 2011] = "MERCHANT_GENERIC_EXCHANGE_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_CONNECT_FAILURE"] = 2012] = "MERCHANT_GENERIC_EXCHANGE_CONNECT_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_REPLY_MALFORMED"] = 2013] = "MERCHANT_GENERIC_EXCHANGE_REPLY_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_EXCHANGE_UNEXPECTED_STATUS"] = 2014] = "MERCHANT_GENERIC_EXCHANGE_UNEXPECTED_STATUS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_UNAUTHORIZED"] = 2015] = "MERCHANT_GENERIC_UNAUTHORIZED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_INSTANCE_DELETED"] = 2016] = "MERCHANT_GENERIC_INSTANCE_DELETED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_TRANSFER_UNKNOWN"] = 2017] = "MERCHANT_GENERIC_TRANSFER_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_TEMPLATE_UNKNOWN"] = 2018] = "MERCHANT_GENERIC_TEMPLATE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_WEBHOOK_UNKNOWN"] = 2019] = "MERCHANT_GENERIC_WEBHOOK_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_PENDING_WEBHOOK_UNKNOWN"] = 2020] = "MERCHANT_GENERIC_PENDING_WEBHOOK_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_OTP_DEVICE_UNKNOWN"] = 2021] = "MERCHANT_GENERIC_OTP_DEVICE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_ACCOUNT_UNKNOWN"] = 2022] = "MERCHANT_GENERIC_ACCOUNT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_H_WIRE_MALFORMED"] = 2023] = "MERCHANT_GENERIC_H_WIRE_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GENERIC_CURRENCY_MISMATCH"] = 2024] = "MERCHANT_GENERIC_CURRENCY_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GET_ORDERS_EXCHANGE_TRACKING_FAILURE"] = 2100] = "MERCHANT_GET_ORDERS_EXCHANGE_TRACKING_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GET_ORDERS_ID_EXCHANGE_REQUEST_FAILURE"] = 2103] = "MERCHANT_GET_ORDERS_ID_EXCHANGE_REQUEST_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GET_ORDERS_ID_EXCHANGE_LOOKUP_START_FAILURE"] = 2104] = "MERCHANT_GET_ORDERS_ID_EXCHANGE_LOOKUP_START_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GET_ORDERS_ID_INVALID_TOKEN"] = 2105] = "MERCHANT_GET_ORDERS_ID_INVALID_TOKEN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_GET_ORDERS_ID_INVALID_CONTRACT_HASH"] = 2106] = "MERCHANT_GET_ORDERS_ID_INVALID_CONTRACT_HASH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_INSUFFICIENT_FUNDS"] = 2150] = "MERCHANT_POST_ORDERS_ID_PAY_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_KEY_NOT_FOUND"] = 2151] = "MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_KEY_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_KEY_AUDITOR_FAILURE"] = 2152] = "MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_KEY_AUDITOR_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_AMOUNT_OVERFLOW"] = 2153] = "MERCHANT_POST_ORDERS_ID_PAY_AMOUNT_OVERFLOW";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_FEES_EXCEED_PAYMENT"] = 2154] = "MERCHANT_POST_ORDERS_ID_PAY_FEES_EXCEED_PAYMENT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_INSUFFICIENT_DUE_TO_FEES"] = 2155] = "MERCHANT_POST_ORDERS_ID_PAY_INSUFFICIENT_DUE_TO_FEES";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_PAYMENT_INSUFFICIENT"] = 2156] = "MERCHANT_POST_ORDERS_ID_PAY_PAYMENT_INSUFFICIENT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_COIN_SIGNATURE_INVALID"] = 2157] = "MERCHANT_POST_ORDERS_ID_PAY_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_LOOKUP_FAILED"] = 2158] = "MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_LOOKUP_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_REFUND_DEADLINE_PAST_WIRE_TRANSFER_DEADLINE"] = 2159] = "MERCHANT_POST_ORDERS_ID_PAY_REFUND_DEADLINE_PAST_WIRE_TRANSFER_DEADLINE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_ALREADY_PAID"] = 2160] = "MERCHANT_POST_ORDERS_ID_PAY_ALREADY_PAID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_OFFER_EXPIRED"] = 2161] = "MERCHANT_POST_ORDERS_ID_PAY_OFFER_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_MERCHANT_FIELD_MISSING"] = 2162] = "MERCHANT_POST_ORDERS_ID_PAY_MERCHANT_FIELD_MISSING";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_WIRE_HASH_UNKNOWN"] = 2163] = "MERCHANT_POST_ORDERS_ID_PAY_WIRE_HASH_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_DEPOSIT_EXPIRED"] = 2165] = "MERCHANT_POST_ORDERS_ID_PAY_DENOMINATION_DEPOSIT_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_WIRE_FEE_ADDITION_FAILED"] = 2166] = "MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_WIRE_FEE_ADDITION_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_REFUNDED"] = 2167] = "MERCHANT_POST_ORDERS_ID_PAY_REFUNDED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_REFUNDS_EXCEED_PAYMENTS"] = 2168] = "MERCHANT_POST_ORDERS_ID_PAY_REFUNDS_EXCEED_PAYMENTS";
  TalerErrorCode2[TalerErrorCode2["DEAD_QQQ_PAY_MERCHANT_POST_ORDERS_ID_ABORT_REFUND_REFUSED_PAYMENT_COMPLETE"] = 2169] = "DEAD_QQQ_PAY_MERCHANT_POST_ORDERS_ID_ABORT_REFUND_REFUSED_PAYMENT_COMPLETE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_FAILED"] = 2170] = "MERCHANT_POST_ORDERS_ID_PAY_EXCHANGE_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_MISSING"] = 2171] = "MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_MISSING";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_SIZE_MISMATCH"] = 2172] = "MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_SIZE_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_AGE_VERIFICATION_FAILED"] = 2173] = "MERCHANT_POST_ORDERS_ID_PAY_AGE_VERIFICATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_HASH_MISSING"] = 2174] = "MERCHANT_POST_ORDERS_ID_PAY_AGE_COMMITMENT_HASH_MISSING";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_WIRE_METHOD_UNSUPPORTED"] = 2175] = "MERCHANT_POST_ORDERS_ID_PAY_WIRE_METHOD_UNSUPPORTED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_CHOICE_INDEX_MISSING"] = 2176] = "MERCHANT_POST_ORDERS_ID_PAY_CHOICE_INDEX_MISSING";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_CHOICE_INDEX_OUT_OF_BOUNDS"] = 2177] = "MERCHANT_POST_ORDERS_ID_PAY_CHOICE_INDEX_OUT_OF_BOUNDS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_INPUT_TOKENS_MISMATCH"] = 2178] = "MERCHANT_POST_ORDERS_ID_PAY_INPUT_TOKENS_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_TOKEN_ISSUE_SIG_INVALID"] = 2179] = "MERCHANT_POST_ORDERS_ID_PAY_TOKEN_ISSUE_SIG_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_TOKEN_USE_SIG_INVALID"] = 2180] = "MERCHANT_POST_ORDERS_ID_PAY_TOKEN_USE_SIG_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_TOKEN_COUNT_MISMATCH"] = 2181] = "MERCHANT_POST_ORDERS_ID_PAY_TOKEN_COUNT_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_TOKEN_ENVELOPE_COUNT_MISMATCH"] = 2182] = "MERCHANT_POST_ORDERS_ID_PAY_TOKEN_ENVELOPE_COUNT_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAY_TOKEN_INVALID"] = 2183] = "MERCHANT_POST_ORDERS_ID_PAY_TOKEN_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAID_CONTRACT_HASH_MISMATCH"] = 2200] = "MERCHANT_POST_ORDERS_ID_PAID_CONTRACT_HASH_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_PAID_COIN_SIGNATURE_INVALID"] = 2201] = "MERCHANT_POST_ORDERS_ID_PAID_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_TOKEN_FAMILY_CONFLICT"] = 2225] = "MERCHANT_POST_TOKEN_FAMILY_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PATCH_TOKEN_FAMILY_NOT_FOUND"] = 2226] = "MERCHANT_PATCH_TOKEN_FAMILY_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_EXCHANGE_REFUND_FAILED"] = 2251] = "MERCHANT_POST_ORDERS_ID_ABORT_EXCHANGE_REFUND_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_EXCHANGE_LOOKUP_FAILED"] = 2252] = "MERCHANT_POST_ORDERS_ID_ABORT_EXCHANGE_LOOKUP_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_CONTRACT_NOT_FOUND"] = 2253] = "MERCHANT_POST_ORDERS_ID_ABORT_CONTRACT_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_REFUND_REFUSED_PAYMENT_COMPLETE"] = 2254] = "MERCHANT_POST_ORDERS_ID_ABORT_REFUND_REFUSED_PAYMENT_COMPLETE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_CONTRACT_HASH_MISSMATCH"] = 2255] = "MERCHANT_POST_ORDERS_ID_ABORT_CONTRACT_HASH_MISSMATCH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_ABORT_COINS_ARRAY_EMPTY"] = 2256] = "MERCHANT_POST_ORDERS_ID_ABORT_COINS_ARRAY_EMPTY";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_AWAITING_KEYS"] = 2258] = "MERCHANT_EXCHANGE_TRANSFERS_AWAITING_KEYS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_AWAITING_LIST"] = 2259] = "MERCHANT_EXCHANGE_TRANSFERS_AWAITING_LIST";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_FATAL_NO_EXCHANGE"] = 2260] = "MERCHANT_EXCHANGE_TRANSFERS_FATAL_NO_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_FATAL_NOT_FOUND"] = 2261] = "MERCHANT_EXCHANGE_TRANSFERS_FATAL_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_RATE_LIMITED"] = 2262] = "MERCHANT_EXCHANGE_TRANSFERS_RATE_LIMITED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_TRANSIENT_FAILURE"] = 2263] = "MERCHANT_EXCHANGE_TRANSFERS_TRANSIENT_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_HARD_FAILURE"] = 2264] = "MERCHANT_EXCHANGE_TRANSFERS_HARD_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_CLAIM_NOT_FOUND"] = 2300] = "MERCHANT_POST_ORDERS_ID_CLAIM_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_CLAIM_ALREADY_CLAIMED"] = 2301] = "MERCHANT_POST_ORDERS_ID_CLAIM_ALREADY_CLAIMED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_CLAIM_CLIENT_INTERNAL_FAILURE"] = 2302] = "MERCHANT_POST_ORDERS_ID_CLAIM_CLIENT_INTERNAL_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_ORDERS_ID_REFUND_SIGNATURE_FAILED"] = 2350] = "MERCHANT_POST_ORDERS_ID_REFUND_SIGNATURE_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_UNBLIND_FAILURE"] = 2400] = "MERCHANT_REWARD_PICKUP_UNBLIND_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_EXCHANGE_ERROR"] = 2403] = "MERCHANT_REWARD_PICKUP_EXCHANGE_ERROR";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_SUMMATION_FAILED"] = 2404] = "MERCHANT_REWARD_PICKUP_SUMMATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_HAS_EXPIRED"] = 2405] = "MERCHANT_REWARD_PICKUP_HAS_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_AMOUNT_EXCEEDS_REWARD_REMAINING"] = 2406] = "MERCHANT_REWARD_PICKUP_AMOUNT_EXCEEDS_REWARD_REMAINING";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_REWARD_PICKUP_DENOMINATION_UNKNOWN"] = 2407] = "MERCHANT_REWARD_PICKUP_DENOMINATION_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_INSTANCE_CONFIGURATION_LACKS_WIRE"] = 2500] = "MERCHANT_PRIVATE_POST_ORDERS_INSTANCE_CONFIGURATION_LACKS_WIRE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_NO_LOCALTIME"] = 2501] = "MERCHANT_PRIVATE_POST_ORDERS_NO_LOCALTIME";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_PROPOSAL_PARSE_ERROR"] = 2502] = "MERCHANT_PRIVATE_POST_ORDERS_PROPOSAL_PARSE_ERROR";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_ALREADY_EXISTS"] = 2503] = "MERCHANT_PRIVATE_POST_ORDERS_ALREADY_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_REFUND_AFTER_WIRE_DEADLINE"] = 2504] = "MERCHANT_PRIVATE_POST_ORDERS_REFUND_AFTER_WIRE_DEADLINE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_DELIVERY_DATE_IN_PAST"] = 2505] = "MERCHANT_PRIVATE_POST_ORDERS_DELIVERY_DATE_IN_PAST";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_WIRE_DEADLINE_IS_NEVER"] = 2506] = "MERCHANT_PRIVATE_POST_ORDERS_WIRE_DEADLINE_IS_NEVER";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_PAY_DEADLINE_IN_PAST"] = 2507] = "MERCHANT_PRIVATE_POST_ORDERS_PAY_DEADLINE_IN_PAST";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_REFUND_DEADLINE_IN_PAST"] = 2508] = "MERCHANT_PRIVATE_POST_ORDERS_REFUND_DEADLINE_IN_PAST";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_NO_EXCHANGES_FOR_WIRE_METHOD"] = 2509] = "MERCHANT_PRIVATE_POST_ORDERS_NO_EXCHANGES_FOR_WIRE_METHOD";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_ORDERS_ID_FORGET_PATH_SYNTAX_INCORRECT"] = 2510] = "MERCHANT_PRIVATE_PATCH_ORDERS_ID_FORGET_PATH_SYNTAX_INCORRECT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_ORDERS_ID_FORGET_PATH_NOT_FORGETTABLE"] = 2511] = "MERCHANT_PRIVATE_PATCH_ORDERS_ID_FORGET_PATH_NOT_FORGETTABLE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_DELETE_ORDERS_AWAITING_PAYMENT"] = 2520] = "MERCHANT_PRIVATE_DELETE_ORDERS_AWAITING_PAYMENT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_DELETE_ORDERS_ALREADY_PAID"] = 2521] = "MERCHANT_PRIVATE_DELETE_ORDERS_ALREADY_PAID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_INCONSISTENT_AMOUNT"] = 2530] = "MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_INCONSISTENT_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_ORDER_UNPAID"] = 2531] = "MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_ORDER_UNPAID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_NOT_ALLOWED_BY_CONTRACT"] = 2532] = "MERCHANT_PRIVATE_POST_ORDERS_ID_REFUND_NOT_ALLOWED_BY_CONTRACT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_TOKEN_FAMILY_SLUG_UNKNOWN"] = 2533] = "MERCHANT_PRIVATE_POST_ORDERS_TOKEN_FAMILY_SLUG_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_ORDERS_TOKEN_FAMILY_NOT_VALID"] = 2534] = "MERCHANT_PRIVATE_POST_ORDERS_TOKEN_FAMILY_NOT_VALID";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_EXCHANGE_UNKNOWN"] = 2550] = "MERCHANT_PRIVATE_POST_TRANSFERS_EXCHANGE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_REQUEST_ERROR"] = 2551] = "MERCHANT_PRIVATE_POST_TRANSFERS_REQUEST_ERROR";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_TRANSFERS"] = 2552] = "MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_TRANSFERS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_REPORTS"] = 2553] = "MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_REPORTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_BAD_WIRE_FEE"] = 2554] = "MERCHANT_PRIVATE_POST_TRANSFERS_BAD_WIRE_FEE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_ACCOUNT_NOT_FOUND"] = 2555] = "MERCHANT_PRIVATE_POST_TRANSFERS_ACCOUNT_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_DELETE_TRANSFERS_ALREADY_CONFIRMED"] = 2556] = "MERCHANT_PRIVATE_DELETE_TRANSFERS_ALREADY_CONFIRMED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_SUBMISSION"] = 2557] = "MERCHANT_PRIVATE_POST_TRANSFERS_CONFLICTING_SUBMISSION";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_EXCHANGE_TRANSFERS_CONFLICTING_TRANSFERS"] = 2563] = "MERCHANT_EXCHANGE_TRANSFERS_CONFLICTING_TRANSFERS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_INSTANCES_ALREADY_EXISTS"] = 2600] = "MERCHANT_PRIVATE_POST_INSTANCES_ALREADY_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_INSTANCES_BAD_AUTH"] = 2601] = "MERCHANT_PRIVATE_POST_INSTANCES_BAD_AUTH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_INSTANCE_AUTH_BAD_AUTH"] = 2602] = "MERCHANT_PRIVATE_POST_INSTANCE_AUTH_BAD_AUTH";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_INSTANCES_PURGE_REQUIRED"] = 2603] = "MERCHANT_PRIVATE_POST_INSTANCES_PURGE_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_INSTANCES_PURGE_REQUIRED"] = 2625] = "MERCHANT_PRIVATE_PATCH_INSTANCES_PURGE_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_ACCOUNT_DELETE_UNKNOWN_ACCOUNT"] = 2626] = "MERCHANT_PRIVATE_ACCOUNT_DELETE_UNKNOWN_ACCOUNT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_ACCOUNT_EXISTS"] = 2627] = "MERCHANT_PRIVATE_ACCOUNT_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_PRODUCTS_CONFLICT_PRODUCT_EXISTS"] = 2650] = "MERCHANT_PRIVATE_POST_PRODUCTS_CONFLICT_PRODUCT_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_CATEGORIES_CONFLICT_CATEGORY_EXISTS"] = 2651] = "MERCHANT_PRIVATE_POST_CATEGORIES_CONFLICT_CATEGORY_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_LOST_REDUCED"] = 2660] = "MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_LOST_REDUCED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_LOST_EXCEEDS_STOCKS"] = 2661] = "MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_LOST_EXCEEDS_STOCKS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_STOCKED_REDUCED"] = 2662] = "MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_STOCKED_REDUCED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_SOLD_REDUCED"] = 2663] = "MERCHANT_PRIVATE_PATCH_PRODUCTS_TOTAL_SOLD_REDUCED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_PRODUCTS_LOCK_INSUFFICIENT_STOCKS"] = 2670] = "MERCHANT_PRIVATE_POST_PRODUCTS_LOCK_INSUFFICIENT_STOCKS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_DELETE_PRODUCTS_CONFLICTING_LOCK"] = 2680] = "MERCHANT_PRIVATE_DELETE_PRODUCTS_CONFLICTING_LOCK";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_RESERVES_UNSUPPORTED_WIRE_METHOD"] = 2700] = "MERCHANT_PRIVATE_POST_RESERVES_UNSUPPORTED_WIRE_METHOD";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_RESERVES_REWARDS_NOT_ALLOWED"] = 2701] = "MERCHANT_PRIVATE_POST_RESERVES_REWARDS_NOT_ALLOWED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_DELETE_RESERVES_NO_SUCH_RESERVE"] = 2710] = "MERCHANT_PRIVATE_DELETE_RESERVES_NO_SUCH_RESERVE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_EXPIRED"] = 2750] = "MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_UNKNOWN"] = 2751] = "MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_INSUFFICIENT_FUNDS"] = 2752] = "MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_INSUFFICIENT_FUNDS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_NOT_FOUND"] = 2753] = "MERCHANT_PRIVATE_POST_REWARD_AUTHORIZE_RESERVE_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_GET_ORDERS_ID_AMOUNT_ARITHMETIC_FAILURE"] = 2800] = "MERCHANT_PRIVATE_GET_ORDERS_ID_AMOUNT_ARITHMETIC_FAILURE";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_TEMPLATES_CONFLICT_TEMPLATE_EXISTS"] = 2850] = "MERCHANT_PRIVATE_POST_TEMPLATES_CONFLICT_TEMPLATE_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_OTP_DEVICES_CONFLICT_OTP_DEVICE_EXISTS"] = 2851] = "MERCHANT_PRIVATE_POST_OTP_DEVICES_CONFLICT_OTP_DEVICE_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_USING_TEMPLATES_AMOUNT_CONFLICT_TEMPLATES_CONTRACT_AMOUNT"] = 2860] = "MERCHANT_POST_USING_TEMPLATES_AMOUNT_CONFLICT_TEMPLATES_CONTRACT_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_USING_TEMPLATES_SUMMARY_CONFLICT_TEMPLATES_CONTRACT_SUBJECT"] = 2861] = "MERCHANT_POST_USING_TEMPLATES_SUMMARY_CONFLICT_TEMPLATES_CONTRACT_SUBJECT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_USING_TEMPLATES_NO_AMOUNT"] = 2862] = "MERCHANT_POST_USING_TEMPLATES_NO_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_POST_USING_TEMPLATES_NO_SUMMARY"] = 2863] = "MERCHANT_POST_USING_TEMPLATES_NO_SUMMARY";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_WEBHOOKS_CONFLICT_WEBHOOK_EXISTS"] = 2900] = "MERCHANT_PRIVATE_POST_WEBHOOKS_CONFLICT_WEBHOOK_EXISTS";
  TalerErrorCode2[TalerErrorCode2["MERCHANT_PRIVATE_POST_PENDING_WEBHOOKS_CONFLICT_PENDING_WEBHOOK_EXISTS"] = 2910] = "MERCHANT_PRIVATE_POST_PENDING_WEBHOOKS_CONFLICT_PENDING_WEBHOOK_EXISTS";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_GENERIC_UNAUTHORIZED"] = 3001] = "AUDITOR_GENERIC_UNAUTHORIZED";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_GENERIC_METHOD_NOT_ALLOWED"] = 3002] = "AUDITOR_GENERIC_METHOD_NOT_ALLOWED";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_DEPOSIT_CONFIRMATION_SIGNATURE_INVALID"] = 3100] = "AUDITOR_DEPOSIT_CONFIRMATION_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_EXCHANGE_SIGNING_KEY_REVOKED"] = 3101] = "AUDITOR_EXCHANGE_SIGNING_KEY_REVOKED";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_RESOURCE_NOT_FOUND"] = 3102] = "AUDITOR_RESOURCE_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["AUDITOR_URI_MISSING_PATH_COMPONENT"] = 3103] = "AUDITOR_URI_MISSING_PATH_COMPONENT";
  TalerErrorCode2[TalerErrorCode2["BANK_SAME_ACCOUNT"] = 5101] = "BANK_SAME_ACCOUNT";
  TalerErrorCode2[TalerErrorCode2["BANK_UNALLOWED_DEBIT"] = 5102] = "BANK_UNALLOWED_DEBIT";
  TalerErrorCode2[TalerErrorCode2["BANK_NEGATIVE_NUMBER_AMOUNT"] = 5103] = "BANK_NEGATIVE_NUMBER_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["BANK_NUMBER_TOO_BIG"] = 5104] = "BANK_NUMBER_TOO_BIG";
  TalerErrorCode2[TalerErrorCode2["BANK_UNKNOWN_ACCOUNT"] = 5106] = "BANK_UNKNOWN_ACCOUNT";
  TalerErrorCode2[TalerErrorCode2["BANK_TRANSACTION_NOT_FOUND"] = 5107] = "BANK_TRANSACTION_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["BANK_BAD_FORMAT_AMOUNT"] = 5108] = "BANK_BAD_FORMAT_AMOUNT";
  TalerErrorCode2[TalerErrorCode2["BANK_REJECT_NO_RIGHTS"] = 5109] = "BANK_REJECT_NO_RIGHTS";
  TalerErrorCode2[TalerErrorCode2["BANK_UNMANAGED_EXCEPTION"] = 5110] = "BANK_UNMANAGED_EXCEPTION";
  TalerErrorCode2[TalerErrorCode2["BANK_SOFT_EXCEPTION"] = 5111] = "BANK_SOFT_EXCEPTION";
  TalerErrorCode2[TalerErrorCode2["BANK_TRANSFER_REQUEST_UID_REUSED"] = 5112] = "BANK_TRANSFER_REQUEST_UID_REUSED";
  TalerErrorCode2[TalerErrorCode2["BANK_WITHDRAWAL_OPERATION_RESERVE_SELECTION_CONFLICT"] = 5113] = "BANK_WITHDRAWAL_OPERATION_RESERVE_SELECTION_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["BANK_DUPLICATE_RESERVE_PUB_SUBJECT"] = 5114] = "BANK_DUPLICATE_RESERVE_PUB_SUBJECT";
  TalerErrorCode2[TalerErrorCode2["BANK_ANCIENT_TRANSACTION_GONE"] = 5115] = "BANK_ANCIENT_TRANSACTION_GONE";
  TalerErrorCode2[TalerErrorCode2["BANK_ABORT_CONFIRM_CONFLICT"] = 5116] = "BANK_ABORT_CONFIRM_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["BANK_CONFIRM_ABORT_CONFLICT"] = 5117] = "BANK_CONFIRM_ABORT_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["BANK_REGISTER_CONFLICT"] = 5118] = "BANK_REGISTER_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["BANK_POST_WITHDRAWAL_OPERATION_REQUIRED"] = 5119] = "BANK_POST_WITHDRAWAL_OPERATION_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["BANK_RESERVED_USERNAME_CONFLICT"] = 5120] = "BANK_RESERVED_USERNAME_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["BANK_REGISTER_USERNAME_REUSE"] = 5121] = "BANK_REGISTER_USERNAME_REUSE";
  TalerErrorCode2[TalerErrorCode2["BANK_REGISTER_PAYTO_URI_REUSE"] = 5122] = "BANK_REGISTER_PAYTO_URI_REUSE";
  TalerErrorCode2[TalerErrorCode2["BANK_ACCOUNT_BALANCE_NOT_ZERO"] = 5123] = "BANK_ACCOUNT_BALANCE_NOT_ZERO";
  TalerErrorCode2[TalerErrorCode2["BANK_UNKNOWN_CREDITOR"] = 5124] = "BANK_UNKNOWN_CREDITOR";
  TalerErrorCode2[TalerErrorCode2["BANK_UNKNOWN_DEBTOR"] = 5125] = "BANK_UNKNOWN_DEBTOR";
  TalerErrorCode2[TalerErrorCode2["BANK_ACCOUNT_IS_EXCHANGE"] = 5126] = "BANK_ACCOUNT_IS_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["BANK_ACCOUNT_IS_NOT_EXCHANGE"] = 5127] = "BANK_ACCOUNT_IS_NOT_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["BANK_BAD_CONVERSION"] = 5128] = "BANK_BAD_CONVERSION";
  TalerErrorCode2[TalerErrorCode2["BANK_MISSING_TAN_INFO"] = 5129] = "BANK_MISSING_TAN_INFO";
  TalerErrorCode2[TalerErrorCode2["BANK_CONFIRM_INCOMPLETE"] = 5130] = "BANK_CONFIRM_INCOMPLETE";
  TalerErrorCode2[TalerErrorCode2["BANK_TAN_RATE_LIMITED"] = 5131] = "BANK_TAN_RATE_LIMITED";
  TalerErrorCode2[TalerErrorCode2["BANK_TAN_CHANNEL_NOT_SUPPORTED"] = 5132] = "BANK_TAN_CHANNEL_NOT_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["BANK_TAN_CHANNEL_SCRIPT_FAILED"] = 5133] = "BANK_TAN_CHANNEL_SCRIPT_FAILED";
  TalerErrorCode2[TalerErrorCode2["BANK_TAN_CHALLENGE_FAILED"] = 5134] = "BANK_TAN_CHALLENGE_FAILED";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_PATCH_LEGAL_NAME"] = 5135] = "BANK_NON_ADMIN_PATCH_LEGAL_NAME";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_PATCH_DEBT_LIMIT"] = 5136] = "BANK_NON_ADMIN_PATCH_DEBT_LIMIT";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_PATCH_MISSING_OLD_PASSWORD"] = 5137] = "BANK_NON_ADMIN_PATCH_MISSING_OLD_PASSWORD";
  TalerErrorCode2[TalerErrorCode2["BANK_PATCH_BAD_OLD_PASSWORD"] = 5138] = "BANK_PATCH_BAD_OLD_PASSWORD";
  TalerErrorCode2[TalerErrorCode2["BANK_PATCH_ADMIN_EXCHANGE"] = 5139] = "BANK_PATCH_ADMIN_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_PATCH_CASHOUT"] = 5140] = "BANK_NON_ADMIN_PATCH_CASHOUT";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_PATCH_CONTACT"] = 5141] = "BANK_NON_ADMIN_PATCH_CONTACT";
  TalerErrorCode2[TalerErrorCode2["BANK_ADMIN_CREDITOR"] = 5142] = "BANK_ADMIN_CREDITOR";
  TalerErrorCode2[TalerErrorCode2["BANK_CHALLENGE_NOT_FOUND"] = 5143] = "BANK_CHALLENGE_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["BANK_TAN_CHALLENGE_EXPIRED"] = 5144] = "BANK_TAN_CHALLENGE_EXPIRED";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_SET_TAN_CHANNEL"] = 5145] = "BANK_NON_ADMIN_SET_TAN_CHANNEL";
  TalerErrorCode2[TalerErrorCode2["BANK_NON_ADMIN_SET_MIN_CASHOUT"] = 5146] = "BANK_NON_ADMIN_SET_MIN_CASHOUT";
  TalerErrorCode2[TalerErrorCode2["BANK_CONVERSION_AMOUNT_TO_SMALL"] = 5147] = "BANK_CONVERSION_AMOUNT_TO_SMALL";
  TalerErrorCode2[TalerErrorCode2["BANK_AMOUNT_DIFFERS"] = 5148] = "BANK_AMOUNT_DIFFERS";
  TalerErrorCode2[TalerErrorCode2["BANK_AMOUNT_REQUIRED"] = 5149] = "BANK_AMOUNT_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["SYNC_ACCOUNT_UNKNOWN"] = 6100] = "SYNC_ACCOUNT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["SYNC_BAD_IF_NONE_MATCH"] = 6101] = "SYNC_BAD_IF_NONE_MATCH";
  TalerErrorCode2[TalerErrorCode2["SYNC_BAD_IF_MATCH"] = 6102] = "SYNC_BAD_IF_MATCH";
  TalerErrorCode2[TalerErrorCode2["SYNC_BAD_SYNC_SIGNATURE"] = 6103] = "SYNC_BAD_SYNC_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["SYNC_INVALID_SIGNATURE"] = 6104] = "SYNC_INVALID_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["SYNC_MALFORMED_CONTENT_LENGTH"] = 6105] = "SYNC_MALFORMED_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["SYNC_EXCESSIVE_CONTENT_LENGTH"] = 6106] = "SYNC_EXCESSIVE_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["SYNC_OUT_OF_MEMORY_ON_CONTENT_LENGTH"] = 6107] = "SYNC_OUT_OF_MEMORY_ON_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["SYNC_INVALID_UPLOAD"] = 6108] = "SYNC_INVALID_UPLOAD";
  TalerErrorCode2[TalerErrorCode2["SYNC_PAYMENT_GENERIC_TIMEOUT"] = 6109] = "SYNC_PAYMENT_GENERIC_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["SYNC_PAYMENT_CREATE_BACKEND_ERROR"] = 6110] = "SYNC_PAYMENT_CREATE_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["SYNC_PREVIOUS_BACKUP_UNKNOWN"] = 6111] = "SYNC_PREVIOUS_BACKUP_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["SYNC_MISSING_CONTENT_LENGTH"] = 6112] = "SYNC_MISSING_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["SYNC_GENERIC_BACKEND_ERROR"] = 6113] = "SYNC_GENERIC_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["SYNC_GENERIC_BACKEND_TIMEOUT"] = 6114] = "SYNC_GENERIC_BACKEND_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_PROTOCOL_VERSION_INCOMPATIBLE"] = 7e3] = "WALLET_EXCHANGE_PROTOCOL_VERSION_INCOMPATIBLE";
  TalerErrorCode2[TalerErrorCode2["WALLET_UNEXPECTED_EXCEPTION"] = 7001] = "WALLET_UNEXPECTED_EXCEPTION";
  TalerErrorCode2[TalerErrorCode2["WALLET_RECEIVED_MALFORMED_RESPONSE"] = 7002] = "WALLET_RECEIVED_MALFORMED_RESPONSE";
  TalerErrorCode2[TalerErrorCode2["WALLET_NETWORK_ERROR"] = 7003] = "WALLET_NETWORK_ERROR";
  TalerErrorCode2[TalerErrorCode2["WALLET_HTTP_REQUEST_THROTTLED"] = 7004] = "WALLET_HTTP_REQUEST_THROTTLED";
  TalerErrorCode2[TalerErrorCode2["WALLET_UNEXPECTED_REQUEST_ERROR"] = 7005] = "WALLET_UNEXPECTED_REQUEST_ERROR";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_DENOMINATIONS_INSUFFICIENT"] = 7006] = "WALLET_EXCHANGE_DENOMINATIONS_INSUFFICIENT";
  TalerErrorCode2[TalerErrorCode2["WALLET_CORE_API_OPERATION_UNKNOWN"] = 7007] = "WALLET_CORE_API_OPERATION_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["WALLET_INVALID_TALER_PAY_URI"] = 7008] = "WALLET_INVALID_TALER_PAY_URI";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_COIN_SIGNATURE_INVALID"] = 7009] = "WALLET_EXCHANGE_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_WITHDRAW_RESERVE_UNKNOWN_AT_EXCHANGE"] = 7010] = "WALLET_EXCHANGE_WITHDRAW_RESERVE_UNKNOWN_AT_EXCHANGE";
  TalerErrorCode2[TalerErrorCode2["WALLET_CORE_NOT_AVAILABLE"] = 7011] = "WALLET_CORE_NOT_AVAILABLE";
  TalerErrorCode2[TalerErrorCode2["WALLET_WITHDRAWAL_OPERATION_ABORTED_BY_BANK"] = 7012] = "WALLET_WITHDRAWAL_OPERATION_ABORTED_BY_BANK";
  TalerErrorCode2[TalerErrorCode2["WALLET_HTTP_REQUEST_GENERIC_TIMEOUT"] = 7013] = "WALLET_HTTP_REQUEST_GENERIC_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["WALLET_ORDER_ALREADY_CLAIMED"] = 7014] = "WALLET_ORDER_ALREADY_CLAIMED";
  TalerErrorCode2[TalerErrorCode2["WALLET_WITHDRAWAL_GROUP_INCOMPLETE"] = 7015] = "WALLET_WITHDRAWAL_GROUP_INCOMPLETE";
  TalerErrorCode2[TalerErrorCode2["WALLET_REWARD_COIN_SIGNATURE_INVALID"] = 7016] = "WALLET_REWARD_COIN_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["WALLET_BANK_INTEGRATION_PROTOCOL_VERSION_INCOMPATIBLE"] = 7017] = "WALLET_BANK_INTEGRATION_PROTOCOL_VERSION_INCOMPATIBLE";
  TalerErrorCode2[TalerErrorCode2["WALLET_CONTRACT_TERMS_BASE_URL_MISMATCH"] = 7018] = "WALLET_CONTRACT_TERMS_BASE_URL_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["WALLET_CONTRACT_TERMS_SIGNATURE_INVALID"] = 7019] = "WALLET_CONTRACT_TERMS_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["WALLET_CONTRACT_TERMS_MALFORMED"] = 7020] = "WALLET_CONTRACT_TERMS_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["WALLET_PENDING_OPERATION_FAILED"] = 7021] = "WALLET_PENDING_OPERATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["WALLET_PAY_MERCHANT_SERVER_ERROR"] = 7022] = "WALLET_PAY_MERCHANT_SERVER_ERROR";
  TalerErrorCode2[TalerErrorCode2["WALLET_CRYPTO_WORKER_ERROR"] = 7023] = "WALLET_CRYPTO_WORKER_ERROR";
  TalerErrorCode2[TalerErrorCode2["WALLET_CRYPTO_WORKER_BAD_REQUEST"] = 7024] = "WALLET_CRYPTO_WORKER_BAD_REQUEST";
  TalerErrorCode2[TalerErrorCode2["WALLET_WITHDRAWAL_KYC_REQUIRED"] = 7025] = "WALLET_WITHDRAWAL_KYC_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["WALLET_DEPOSIT_GROUP_INSUFFICIENT_BALANCE"] = 7026] = "WALLET_DEPOSIT_GROUP_INSUFFICIENT_BALANCE";
  TalerErrorCode2[TalerErrorCode2["WALLET_PEER_PUSH_PAYMENT_INSUFFICIENT_BALANCE"] = 7027] = "WALLET_PEER_PUSH_PAYMENT_INSUFFICIENT_BALANCE";
  TalerErrorCode2[TalerErrorCode2["WALLET_PEER_PULL_PAYMENT_INSUFFICIENT_BALANCE"] = 7028] = "WALLET_PEER_PULL_PAYMENT_INSUFFICIENT_BALANCE";
  TalerErrorCode2[TalerErrorCode2["WALLET_REFRESH_GROUP_INCOMPLETE"] = 7029] = "WALLET_REFRESH_GROUP_INCOMPLETE";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_BASE_URL_MISMATCH"] = 7030] = "WALLET_EXCHANGE_BASE_URL_MISMATCH";
  TalerErrorCode2[TalerErrorCode2["WALLET_ORDER_ALREADY_PAID"] = 7031] = "WALLET_ORDER_ALREADY_PAID";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_UNAVAILABLE"] = 7032] = "WALLET_EXCHANGE_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_ENTRY_USED"] = 7033] = "WALLET_EXCHANGE_ENTRY_USED";
  TalerErrorCode2[TalerErrorCode2["WALLET_DB_UNAVAILABLE"] = 7034] = "WALLET_DB_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["WALLET_TALER_URI_MALFORMED"] = 7035] = "WALLET_TALER_URI_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["WALLET_CORE_REQUEST_CANCELLED"] = 7036] = "WALLET_CORE_REQUEST_CANCELLED";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_TOS_NOT_ACCEPTED"] = 7037] = "WALLET_EXCHANGE_TOS_NOT_ACCEPTED";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_ENTRY_UPDATE_CONFLICT"] = 7038] = "WALLET_EXCHANGE_ENTRY_UPDATE_CONFLICT";
  TalerErrorCode2[TalerErrorCode2["WALLET_EXCHANGE_ENTRY_OUTDATED"] = 7039] = "WALLET_EXCHANGE_ENTRY_OUTDATED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_BACKEND_TIMEOUT"] = 8e3] = "ANASTASIS_GENERIC_BACKEND_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_INVALID_PAYMENT_REQUEST"] = 8001] = "ANASTASIS_GENERIC_INVALID_PAYMENT_REQUEST";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_BACKEND_ERROR"] = 8002] = "ANASTASIS_GENERIC_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_MISSING_CONTENT_LENGTH"] = 8003] = "ANASTASIS_GENERIC_MISSING_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_MALFORMED_CONTENT_LENGTH"] = 8004] = "ANASTASIS_GENERIC_MALFORMED_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_ORDER_CREATE_BACKEND_ERROR"] = 8005] = "ANASTASIS_GENERIC_ORDER_CREATE_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_PAYMENT_CHECK_UNAUTHORIZED"] = 8006] = "ANASTASIS_GENERIC_PAYMENT_CHECK_UNAUTHORIZED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_PAYMENT_CHECK_START_FAILED"] = 8007] = "ANASTASIS_GENERIC_PAYMENT_CHECK_START_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_GENERIC_PROVIDER_UNREACHABLE"] = 8008] = "ANASTASIS_GENERIC_PROVIDER_UNREACHABLE";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_PAYMENT_GENERIC_TIMEOUT"] = 8009] = "ANASTASIS_PAYMENT_GENERIC_TIMEOUT";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_UNKNOWN"] = 8108] = "ANASTASIS_TRUTH_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_AUTHORIZATION_METHOD_NO_LONGER_SUPPORTED"] = 8109] = "ANASTASIS_TRUTH_AUTHORIZATION_METHOD_NO_LONGER_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_CHALLENGE_RESPONSE_REQUIRED"] = 8110] = "ANASTASIS_TRUTH_CHALLENGE_RESPONSE_REQUIRED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_CHALLENGE_FAILED"] = 8111] = "ANASTASIS_TRUTH_CHALLENGE_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_CHALLENGE_UNKNOWN"] = 8112] = "ANASTASIS_TRUTH_CHALLENGE_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_AUTHORIZATION_START_FAILED"] = 8114] = "ANASTASIS_TRUTH_AUTHORIZATION_START_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_KEY_SHARE_GONE"] = 8115] = "ANASTASIS_TRUTH_KEY_SHARE_GONE";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_ORDER_DISAPPEARED"] = 8116] = "ANASTASIS_TRUTH_ORDER_DISAPPEARED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_BACKEND_EXCHANGE_BAD"] = 8117] = "ANASTASIS_TRUTH_BACKEND_EXCHANGE_BAD";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_UNEXPECTED_PAYMENT_STATUS"] = 8118] = "ANASTASIS_TRUTH_UNEXPECTED_PAYMENT_STATUS";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_PAYMENT_CREATE_BACKEND_ERROR"] = 8119] = "ANASTASIS_TRUTH_PAYMENT_CREATE_BACKEND_ERROR";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_DECRYPTION_FAILED"] = 8120] = "ANASTASIS_TRUTH_DECRYPTION_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_RATE_LIMITED"] = 8121] = "ANASTASIS_TRUTH_RATE_LIMITED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_CHALLENGE_WRONG_METHOD"] = 8123] = "ANASTASIS_TRUTH_CHALLENGE_WRONG_METHOD";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_UPLOAD_UUID_EXISTS"] = 8150] = "ANASTASIS_TRUTH_UPLOAD_UUID_EXISTS";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TRUTH_UPLOAD_METHOD_NOT_SUPPORTED"] = 8151] = "ANASTASIS_TRUTH_UPLOAD_METHOD_NOT_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_SMS_PHONE_INVALID"] = 8200] = "ANASTASIS_SMS_PHONE_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_SMS_HELPER_EXEC_FAILED"] = 8201] = "ANASTASIS_SMS_HELPER_EXEC_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_SMS_HELPER_COMMAND_FAILED"] = 8202] = "ANASTASIS_SMS_HELPER_COMMAND_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_EMAIL_INVALID"] = 8210] = "ANASTASIS_EMAIL_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_EMAIL_HELPER_EXEC_FAILED"] = 8211] = "ANASTASIS_EMAIL_HELPER_EXEC_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_EMAIL_HELPER_COMMAND_FAILED"] = 8212] = "ANASTASIS_EMAIL_HELPER_COMMAND_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POST_INVALID"] = 8220] = "ANASTASIS_POST_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POST_HELPER_EXEC_FAILED"] = 8221] = "ANASTASIS_POST_HELPER_EXEC_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POST_HELPER_COMMAND_FAILED"] = 8222] = "ANASTASIS_POST_HELPER_COMMAND_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_IBAN_INVALID"] = 8230] = "ANASTASIS_IBAN_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_IBAN_MISSING_TRANSFER"] = 8231] = "ANASTASIS_IBAN_MISSING_TRANSFER";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TOTP_KEY_MISSING"] = 8240] = "ANASTASIS_TOTP_KEY_MISSING";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_TOTP_KEY_INVALID"] = 8241] = "ANASTASIS_TOTP_KEY_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_BAD_IF_NONE_MATCH"] = 8301] = "ANASTASIS_POLICY_BAD_IF_NONE_MATCH";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_OUT_OF_MEMORY_ON_CONTENT_LENGTH"] = 8304] = "ANASTASIS_POLICY_OUT_OF_MEMORY_ON_CONTENT_LENGTH";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_BAD_SIGNATURE"] = 8305] = "ANASTASIS_POLICY_BAD_SIGNATURE";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_BAD_IF_MATCH"] = 8306] = "ANASTASIS_POLICY_BAD_IF_MATCH";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_INVALID_UPLOAD"] = 8307] = "ANASTASIS_POLICY_INVALID_UPLOAD";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_POLICY_NOT_FOUND"] = 8350] = "ANASTASIS_POLICY_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_ACTION_INVALID"] = 8400] = "ANASTASIS_REDUCER_ACTION_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_STATE_INVALID"] = 8401] = "ANASTASIS_REDUCER_STATE_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_INPUT_INVALID"] = 8402] = "ANASTASIS_REDUCER_INPUT_INVALID";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_AUTHENTICATION_METHOD_NOT_SUPPORTED"] = 8403] = "ANASTASIS_REDUCER_AUTHENTICATION_METHOD_NOT_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_INPUT_INVALID_FOR_STATE"] = 8404] = "ANASTASIS_REDUCER_INPUT_INVALID_FOR_STATE";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_BACKEND_FAILURE"] = 8405] = "ANASTASIS_REDUCER_BACKEND_FAILURE";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_RESOURCE_MALFORMED"] = 8406] = "ANASTASIS_REDUCER_RESOURCE_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_RESOURCE_MISSING"] = 8407] = "ANASTASIS_REDUCER_RESOURCE_MISSING";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_INPUT_REGEX_FAILED"] = 8408] = "ANASTASIS_REDUCER_INPUT_REGEX_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_INPUT_VALIDATION_FAILED"] = 8409] = "ANASTASIS_REDUCER_INPUT_VALIDATION_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_POLICY_LOOKUP_FAILED"] = 8410] = "ANASTASIS_REDUCER_POLICY_LOOKUP_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_BACKUP_PROVIDER_FAILED"] = 8411] = "ANASTASIS_REDUCER_BACKUP_PROVIDER_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_PROVIDER_CONFIG_FAILED"] = 8412] = "ANASTASIS_REDUCER_PROVIDER_CONFIG_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_POLICY_MALFORMED"] = 8413] = "ANASTASIS_REDUCER_POLICY_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_NETWORK_FAILED"] = 8414] = "ANASTASIS_REDUCER_NETWORK_FAILED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_SECRET_MALFORMED"] = 8415] = "ANASTASIS_REDUCER_SECRET_MALFORMED";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_CHALLENGE_DATA_TOO_BIG"] = 8416] = "ANASTASIS_REDUCER_CHALLENGE_DATA_TOO_BIG";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_SECRET_TOO_BIG"] = 8417] = "ANASTASIS_REDUCER_SECRET_TOO_BIG";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_PROVIDER_INVALID_CONFIG"] = 8418] = "ANASTASIS_REDUCER_PROVIDER_INVALID_CONFIG";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_INTERNAL_ERROR"] = 8419] = "ANASTASIS_REDUCER_INTERNAL_ERROR";
  TalerErrorCode2[TalerErrorCode2["ANASTASIS_REDUCER_PROVIDERS_ALREADY_SYNCED"] = 8420] = "ANASTASIS_REDUCER_PROVIDERS_ALREADY_SYNCED";
  TalerErrorCode2[TalerErrorCode2["DONAU_GENERIC_KEYS_MISSING"] = 8607] = "DONAU_GENERIC_KEYS_MISSING";
  TalerErrorCode2[TalerErrorCode2["DONAU_CHARITY_SIGNATURE_INVALID"] = 8608] = "DONAU_CHARITY_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["DONAU_CHARITY_NOT_FOUND"] = 8609] = "DONAU_CHARITY_NOT_FOUND";
  TalerErrorCode2[TalerErrorCode2["DONAU_EXCEEDING_DONATION_LIMIT"] = 8610] = "DONAU_EXCEEDING_DONATION_LIMIT";
  TalerErrorCode2[TalerErrorCode2["DONAU_GENERIC_DONATION_UNIT_UNKNOWN"] = 8611] = "DONAU_GENERIC_DONATION_UNIT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["DONAU_DONATION_UNIT_HELPER_UNAVAILABLE"] = 8612] = "DONAU_DONATION_UNIT_HELPER_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["DONAU_SIGNKEY_HELPER_UNAVAILABLE"] = 8613] = "DONAU_SIGNKEY_HELPER_UNAVAILABLE";
  TalerErrorCode2[TalerErrorCode2["DONAU_SIGNKEY_HELPER_BUG"] = 8614] = "DONAU_SIGNKEY_HELPER_BUG";
  TalerErrorCode2[TalerErrorCode2["DONAU_GENERIC_WRONG_NUMBER_OF_SEGMENTS"] = 8615] = "DONAU_GENERIC_WRONG_NUMBER_OF_SEGMENTS";
  TalerErrorCode2[TalerErrorCode2["DONAU_DONATION_RECEIPT_SIGNATURE_INVALID"] = 8616] = "DONAU_DONATION_RECEIPT_SIGNATURE_INVALID";
  TalerErrorCode2[TalerErrorCode2["DONAU_DONOR_IDENTIFIER_NONCE_REUSE"] = 8617] = "DONAU_DONOR_IDENTIFIER_NONCE_REUSE";
  TalerErrorCode2[TalerErrorCode2["LIBEUFIN_NEXUS_GENERIC_ERROR"] = 9e3] = "LIBEUFIN_NEXUS_GENERIC_ERROR";
  TalerErrorCode2[TalerErrorCode2["LIBEUFIN_NEXUS_UNCAUGHT_EXCEPTION"] = 9001] = "LIBEUFIN_NEXUS_UNCAUGHT_EXCEPTION";
  TalerErrorCode2[TalerErrorCode2["LIBEUFIN_SANDBOX_GENERIC_ERROR"] = 9500] = "LIBEUFIN_SANDBOX_GENERIC_ERROR";
  TalerErrorCode2[TalerErrorCode2["LIBEUFIN_SANDBOX_UNCAUGHT_EXCEPTION"] = 9501] = "LIBEUFIN_SANDBOX_UNCAUGHT_EXCEPTION";
  TalerErrorCode2[TalerErrorCode2["TALDIR_METHOD_NOT_SUPPORTED"] = 9600] = "TALDIR_METHOD_NOT_SUPPORTED";
  TalerErrorCode2[TalerErrorCode2["TALDIR_REGISTER_RATE_LIMITED"] = 9601] = "TALDIR_REGISTER_RATE_LIMITED";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_GENERIC_CLIENT_UNKNOWN"] = 9750] = "CHALLENGER_GENERIC_CLIENT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_GENERIC_CLIENT_FORBIDDEN_BAD_REDIRECT_URI"] = 9751] = "CHALLENGER_GENERIC_CLIENT_FORBIDDEN_BAD_REDIRECT_URI";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_HELPER_EXEC_FAILED"] = 9752] = "CHALLENGER_HELPER_EXEC_FAILED";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_GRANT_UNKNOWN"] = 9753] = "CHALLENGER_GRANT_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_CLIENT_FORBIDDEN_BAD_CODE"] = 9754] = "CHALLENGER_CLIENT_FORBIDDEN_BAD_CODE";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_GENERIC_VALIDATION_UNKNOWN"] = 9755] = "CHALLENGER_GENERIC_VALIDATION_UNKNOWN";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_CLIENT_FORBIDDEN_INVALID_CODE"] = 9756] = "CHALLENGER_CLIENT_FORBIDDEN_INVALID_CODE";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_TOO_MANY_ATTEMPTS"] = 9757] = "CHALLENGER_TOO_MANY_ATTEMPTS";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_INVALID_PIN"] = 9758] = "CHALLENGER_INVALID_PIN";
  TalerErrorCode2[TalerErrorCode2["CHALLENGER_MISSING_ADDRESS"] = 9759] = "CHALLENGER_MISSING_ADDRESS";
  TalerErrorCode2[TalerErrorCode2["END"] = 9999] = "END";
})(TalerErrorCode || (TalerErrorCode = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/CancellationToken.js
var NOOP = () => {
};
var CancellationToken = class _CancellationToken {
  /**
   * Whether the token has been cancelled.
   */
  get isCancelled() {
    return this._isCancelled;
  }
  /**
   * Whether the token can be cancelled.
   */
  get canBeCancelled() {
    return this._canBeCancelled;
  }
  /**
   * Why this token has been cancelled.
   */
  get reason() {
    if (this.isCancelled) {
      return this._reason;
    } else {
      throw new Error("This token is not cancelled.");
    }
  }
  /**
   * Make a promise that resolves when the async operation resolves,
   * or rejects when the operation is rejected or this token is cancelled.
   */
  racePromise(asyncOperation) {
    if (!this.canBeCancelled) {
      return asyncOperation;
    }
    return new Promise((resolve, reject) => {
      const unregister = this.onCancelled((reason) => reject(new _CancellationToken.CancellationError(reason)));
      asyncOperation.then((value) => {
        resolve(value);
        unregister();
      }, (err) => {
        reject(err);
        unregister();
      });
    });
  }
  /**
   * Throw a {CancellationToken.CancellationError} if this token is cancelled.
   */
  throwIfCancelled() {
    if (this._isCancelled) {
      throw new _CancellationToken.CancellationError(this._reason);
    }
  }
  /**
   * Invoke the callback when this token is cancelled.
   * If this token is already cancelled, the callback is invoked immediately.
   * Returns a function that unregisters the cancellation callback.
   */
  onCancelled(cb) {
    if (!this.canBeCancelled) {
      return NOOP;
    }
    if (this.isCancelled) {
      cb(this.reason);
      return NOOP;
    }
    this._callbacks?.add(cb);
    return () => this._callbacks?.delete(cb);
  }
  constructor(_isCancelled, _canBeCancelled) {
    this._isCancelled = _isCancelled;
    this._canBeCancelled = _canBeCancelled;
    this._callbacks = /* @__PURE__ */ new Set();
  }
  /**
   * Create a {CancellationTokenSource}.
   */
  static create() {
    const token = new _CancellationToken(false, true);
    const cancel = (reason) => {
      if (token._isCancelled)
        return;
      token._isCancelled = true;
      token._reason = reason;
      token._callbacks?.forEach((cb) => cb(reason));
      dispose();
    };
    const dispose = () => {
      token._canBeCancelled = token.isCancelled;
      delete token._callbacks;
    };
    return { token, cancel, dispose };
  }
  /**
   * Create a {CancellationTokenSource}.
   * The token will be cancelled automatically after the specified timeout in milliseconds.
   */
  static timeout(ms) {
    const { token, cancel: originalCancel, dispose: originalDispose } = _CancellationToken.create();
    let timer3;
    timer3 = setTimeout(() => originalCancel(`CancellationToken.timeout ${ms}`), ms);
    const disposeTimer = () => {
      if (timer3 == null)
        return;
      clearTimeout(timer3);
      timer3 = null;
    };
    const cancel = (reason) => {
      disposeTimer();
      originalCancel(reason);
    };
    const dispose = () => {
      disposeTimer();
      originalDispose();
    };
    return { token, cancel, dispose };
  }
  /**
   * Create a {CancellationToken} that is cancelled when all of the given tokens are cancelled.
   *
   * This is like {Promise<T>.all} for {CancellationToken}s.
   */
  static all(...tokens) {
    if (tokens.some((token) => !token.canBeCancelled)) {
      return _CancellationToken.CONTINUE;
    }
    const combined = _CancellationToken.create();
    let countdown = tokens.length;
    const handleNextTokenCancelled = () => {
      if (--countdown === 0) {
        const reasons = tokens.map((token) => token._reason);
        combined.cancel(reasons);
      }
    };
    tokens.forEach((token) => token.onCancelled(handleNextTokenCancelled));
    return combined.token;
  }
  /**
   * Create a {CancellationToken} that is cancelled when at least one of the given tokens is cancelled.
   *
   * This is like {Promise<T>.race} for {CancellationToken}s.
   */
  static race(...tokens) {
    for (const token of tokens) {
      if (token._isCancelled) {
        return token;
      }
    }
    const combined = _CancellationToken.create();
    let unregistrations;
    const handleAnyTokenCancelled = (reason) => {
      unregistrations.forEach((unregister) => unregister());
      combined.cancel(reason);
    };
    unregistrations = tokens.map((token) => token.onCancelled(handleAnyTokenCancelled));
    return combined.token;
  }
};
CancellationToken.CANCELLED = new CancellationToken(true, true);
CancellationToken.CONTINUE = new CancellationToken(false, false);
(function(CancellationToken2) {
  class CancellationError extends Error {
    constructor(reason) {
      super("Operation cancelled");
      this.reason = reason;
      Object.setPrototypeOf(this, CancellationError.prototype);
    }
  }
  CancellationToken2.CancellationError = CancellationError;
})(CancellationToken || (CancellationToken = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/amounts.js
var amountFractionalBase = 1e8;
var amountFractionalLength = 8;
var amountMaxValue = 2 ** 52;
var FRAC_SEPARATOR = ".";
var Amount = class _Amount {
  static from(a4) {
    return new _Amount(Amounts.parseOrThrow(a4), 0);
  }
  static zeroOfCurrency(currency) {
    return new _Amount(Amounts.zeroOfCurrency(currency), 0);
  }
  add(...a4) {
    if (this.saturated) {
      return this;
    }
    const r3 = Amounts.add(this.val, ...a4);
    return new _Amount(r3.amount, r3.saturated ? 1 : 0);
  }
  mult(n2) {
    if (this.saturated) {
      return this;
    }
    const r3 = Amounts.mult(this, n2);
    return new _Amount(r3.amount, r3.saturated ? 1 : 0);
  }
  toJson() {
    return { ...this.val };
  }
  toString() {
    return Amounts.stringify(this.val);
  }
  constructor(val, saturated) {
    this.val = val;
    this.saturated = saturated;
  }
};
function codecForAmountString() {
  return {
    decode(x6, c6) {
      if (typeof x6 !== "string") {
        throw new DecodingError(`expected string at ${renderContext(c6)} but got ${typeof x6}`);
      }
      if (Amounts.parse(x6) === void 0) {
        throw new DecodingError(`invalid amount at ${renderContext(c6)} got "${x6}"`);
      }
      return x6;
    }
  };
}
var Amounts = class _Amounts {
  constructor() {
    throw Error("not instantiable");
  }
  static currencyOf(amount) {
    const amt = _Amounts.parseOrThrow(amount);
    return amt.currency;
  }
  static zeroOfAmount(amount) {
    const amt = _Amounts.parseOrThrow(amount);
    return {
      currency: amt.currency,
      fraction: 0,
      value: 0
    };
  }
  /**
   * Get an amount that represents zero units of a currency.
   */
  static zeroOfCurrency(currency) {
    return {
      currency,
      fraction: 0,
      value: 0
    };
  }
  static jsonifyAmount(amt) {
    if (typeof amt === "string") {
      return _Amounts.parseOrThrow(amt);
    }
    if (amt instanceof Amount) {
      return amt.toJson();
    }
    return amt;
  }
  static divmod(a1, a22) {
    const am1 = _Amounts.jsonifyAmount(a1);
    const am2 = _Amounts.jsonifyAmount(a22);
    if (am1.currency != am2.currency) {
      throw Error(`incompatible currency (${am1.currency} vs${am2.currency})`);
    }
    const x12 = BigInt(am1.value) * BigInt(amountFractionalBase) + BigInt(am1.fraction);
    const x22 = BigInt(am2.value) * BigInt(amountFractionalBase) + BigInt(am2.fraction);
    const quotient = x12 / x22;
    const remainderScaled = x12 % x22;
    return {
      quotient: Number(quotient),
      remainder: {
        currency: am1.currency,
        value: Number(remainderScaled / BigInt(amountFractionalBase)),
        fraction: Number(remainderScaled % BigInt(amountFractionalBase))
      }
    };
  }
  static sum(amounts) {
    if (amounts.length <= 0) {
      throw Error("can't sum zero amounts");
    }
    const jsonAmounts = amounts.map((x6) => _Amounts.jsonifyAmount(x6));
    return _Amounts.add(jsonAmounts[0], ...jsonAmounts.slice(1));
  }
  static sumOrZero(currency, amounts) {
    if (amounts.length <= 0) {
      return {
        amount: _Amounts.zeroOfCurrency(currency),
        saturated: false
      };
    }
    const jsonAmounts = amounts.map((x6) => _Amounts.jsonifyAmount(x6));
    return _Amounts.add(jsonAmounts[0], ...jsonAmounts.slice(1));
  }
  /**
   * Add two amounts.  Return the result and whether
   * the addition overflowed.  The overflow is always handled
   * by saturating and never by wrapping.
   *
   * Throws when currencies don't match.
   */
  static add(first2, ...rest) {
    const firstJ = _Amounts.jsonifyAmount(first2);
    const currency = firstJ.currency;
    let value = firstJ.value + Math.floor(firstJ.fraction / amountFractionalBase);
    if (value > amountMaxValue) {
      return {
        amount: {
          currency,
          value: amountMaxValue,
          fraction: amountFractionalBase - 1
        },
        saturated: true
      };
    }
    let fraction = firstJ.fraction % amountFractionalBase;
    for (const x6 of rest) {
      const xJ = _Amounts.jsonifyAmount(x6);
      if (xJ.currency.toUpperCase() !== currency.toUpperCase()) {
        throw Error(`Mismatched currency: ${xJ.currency} and ${currency}`);
      }
      value = value + xJ.value + Math.floor((fraction + xJ.fraction) / amountFractionalBase);
      fraction = Math.floor((fraction + xJ.fraction) % amountFractionalBase);
      if (value > amountMaxValue) {
        return {
          amount: {
            currency,
            value: amountMaxValue,
            fraction: amountFractionalBase - 1
          },
          saturated: true
        };
      }
    }
    return { amount: { currency, value, fraction }, saturated: false };
  }
  /**
   * Subtract two amounts.  Return the result and whether
   * the subtraction overflowed.  The overflow is always handled
   * by saturating and never by wrapping.
   *
   * Throws when currencies don't match.
   */
  static sub(a4, ...rest) {
    const aJ = _Amounts.jsonifyAmount(a4);
    const currency = aJ.currency;
    let value = aJ.value;
    let fraction = aJ.fraction;
    for (const b3 of rest) {
      const bJ = _Amounts.jsonifyAmount(b3);
      if (bJ.currency.toUpperCase() !== aJ.currency.toUpperCase()) {
        throw Error(`Mismatched currency: ${bJ.currency} and ${currency}`);
      }
      if (fraction < bJ.fraction) {
        if (value < 1) {
          return {
            amount: { currency, value: 0, fraction: 0 },
            saturated: true
          };
        }
        value--;
        fraction += amountFractionalBase;
      }
      console.assert(fraction >= bJ.fraction);
      fraction -= bJ.fraction;
      if (value < bJ.value) {
        return { amount: { currency, value: 0, fraction: 0 }, saturated: true };
      }
      value -= bJ.value;
    }
    return { amount: { currency, value, fraction }, saturated: false };
  }
  /**
   * Compare two amounts.  Returns 0 when equal, -1 when a < b
   * and +1 when a > b.  Throws when currencies don't match.
   */
  static cmp(a4, b3) {
    a4 = _Amounts.jsonifyAmount(a4);
    b3 = _Amounts.jsonifyAmount(b3);
    if (a4.currency !== b3.currency) {
      throw Error(`Mismatched currency: ${a4.currency} and ${b3.currency}`);
    }
    const av = a4.value + Math.floor(a4.fraction / amountFractionalBase);
    const af = a4.fraction % amountFractionalBase;
    const bv = b3.value + Math.floor(b3.fraction / amountFractionalBase);
    const bf = b3.fraction % amountFractionalBase;
    switch (true) {
      case av < bv:
        return -1;
      case av > bv:
        return 1;
      case af < bf:
        return -1;
      case af > bf:
        return 1;
      case af === bf:
        return 0;
      default:
        throw Error("assertion failed");
    }
  }
  /**
   * Create a copy of an amount.
   */
  static copy(a4) {
    return {
      currency: a4.currency,
      fraction: a4.fraction,
      value: a4.value
    };
  }
  /**
   * Divide an amount.  Throws on division by zero.
   */
  static divide(a4, n2) {
    if (n2 === 0) {
      throw Error(`Division by 0`);
    }
    if (n2 === 1) {
      return { value: a4.value, fraction: a4.fraction, currency: a4.currency };
    }
    const r3 = a4.value % n2;
    return {
      currency: a4.currency,
      fraction: Math.floor((r3 * amountFractionalBase + a4.fraction) / n2),
      value: Math.floor(a4.value / n2)
    };
  }
  /**
   * Check if an amount is non-zero.
   */
  static isNonZero(a4) {
    a4 = _Amounts.jsonifyAmount(a4);
    return a4.value > 0 || a4.fraction > 0;
  }
  static isZero(a4) {
    a4 = _Amounts.jsonifyAmount(a4);
    return a4.value === 0 && a4.fraction === 0;
  }
  /**
   * Check whether a string is a valid currency for a Taler amount.
   */
  static isCurrency(s4) {
    return /^[a-zA-Z]{1,11}$/.test(s4);
  }
  /**
   * Parse an amount like 'EUR:20.5' for 20 Euros and 50 ct.
   *
   * Currency name size limit is 11 of ASCII letters
   * Fraction size limit is 8
   */
  static parse(s4) {
    const res = s4.match(/^([a-zA-Z]{1,11}):([0-9]+)([.][0-9]{1,8})?$/);
    if (!res) {
      return void 0;
    }
    const tail = res[3] || FRAC_SEPARATOR + "0";
    if (tail.length > amountFractionalLength + 1) {
      return void 0;
    }
    const value = Number.parseInt(res[2]);
    if (value > amountMaxValue) {
      return void 0;
    }
    return {
      currency: res[1].toUpperCase(),
      fraction: Math.round(amountFractionalBase * Number.parseFloat(tail)),
      value
    };
  }
  /**
   * Parse amount in standard string form (like 'EUR:20.5'),
   * throw if the input is not a valid amount.
   */
  static parseOrThrow(s4) {
    if (s4 instanceof Amount) {
      return s4.toJson();
    }
    if (typeof s4 === "object") {
      if (typeof s4.currency !== "string") {
        throw Error("invalid amount object");
      }
      if (typeof s4.value !== "number") {
        throw Error("invalid amount object");
      }
      if (typeof s4.fraction !== "number") {
        throw Error("invalid amount object");
      }
      return { currency: s4.currency, value: s4.value, fraction: s4.fraction };
    } else if (typeof s4 === "string") {
      const res = _Amounts.parse(s4);
      if (!res) {
        throw Error(`Can't parse amount: "${s4}"`);
      }
      return res;
    } else {
      throw Error("invalid amount (illegal type)");
    }
  }
  static min(a4, b3) {
    const cr = _Amounts.cmp(a4, b3);
    if (cr >= 0) {
      return _Amounts.jsonifyAmount(b3);
    } else {
      return _Amounts.jsonifyAmount(a4);
    }
  }
  static max(a4, b3) {
    const cr = _Amounts.cmp(a4, b3);
    if (cr >= 0) {
      return _Amounts.jsonifyAmount(a4);
    } else {
      return _Amounts.jsonifyAmount(b3);
    }
  }
  static mult(a4, n2) {
    a4 = this.jsonifyAmount(a4);
    if (!Number.isInteger(n2)) {
      throw Error("amount can only be multiplied by an integer");
    }
    if (n2 < 0) {
      throw Error("amount can only be multiplied by a positive integer");
    }
    if (n2 == 0) {
      return {
        amount: _Amounts.zeroOfCurrency(a4.currency),
        saturated: false
      };
    }
    let x6 = a4;
    let acc = _Amounts.zeroOfCurrency(a4.currency);
    while (n2 > 1) {
      if (n2 % 2 == 0) {
        n2 = n2 / 2;
      } else {
        n2 = (n2 - 1) / 2;
        const r23 = _Amounts.add(acc, x6);
        if (r23.saturated) {
          return r23;
        }
        acc = r23.amount;
      }
      const r22 = _Amounts.add(x6, x6);
      if (r22.saturated) {
        return r22;
      }
      x6 = r22.amount;
    }
    return _Amounts.add(acc, x6);
  }
  /**
   * Check if the argument is a valid amount in string form.
   */
  static check(a4) {
    if (typeof a4 !== "string") {
      return false;
    }
    try {
      const parsedAmount = _Amounts.parse(a4);
      return !!parsedAmount;
    } catch {
      return false;
    }
  }
  /**
   * Convert to standard human-readable string representation that's
   * also used in JSON formats.
   */
  static stringify(a4) {
    a4 = _Amounts.jsonifyAmount(a4);
    const s4 = this.stringifyValue(a4);
    return `${a4.currency}:${s4}`;
  }
  static amountHasSameCurrency(a1, a22) {
    const x12 = this.jsonifyAmount(a1);
    const x22 = this.jsonifyAmount(a22);
    return x12.currency.toUpperCase() === x22.currency.toUpperCase();
  }
  static isSameCurrency(curr1, curr2) {
    return curr1.toLowerCase() === curr2.toLowerCase();
  }
  static stringifyValue(a4, minFractional = 0) {
    const aJ = _Amounts.jsonifyAmount(a4);
    const av = aJ.value + Math.floor(aJ.fraction / amountFractionalBase);
    const af = aJ.fraction % amountFractionalBase;
    let s4 = av.toString();
    if (af || minFractional) {
      s4 = s4 + FRAC_SEPARATOR;
      let n2 = af;
      for (let i3 = 0; i3 < amountFractionalLength; i3++) {
        if (!n2 && i3 >= minFractional) {
          break;
        }
        s4 = s4 + Math.floor(n2 / amountFractionalBase * 10).toString();
        n2 = n2 * 10 % amountFractionalBase;
      }
    }
    return s4;
  }
  /**
   * Number of fractional digits needed to fully represent the amount
   * @param a amount
   * @returns
   */
  static maxFractionalDigits(a4) {
    if (a4.fraction === 0)
      return 0;
    if (a4.fraction < 0) {
      console.error("amount fraction can not be negative", a4);
      return 0;
    }
    let i3 = 0;
    let check = true;
    let rest = a4.fraction;
    while (rest > 0 && check) {
      check = rest % 10 === 0;
      rest = rest / 10;
      i3++;
    }
    return amountFractionalLength - i3 + 1;
  }
  static stringifyValueWithSpec(value, spec) {
    const strValue = _Amounts.stringifyValue(value);
    const pos = strValue.indexOf(FRAC_SEPARATOR);
    const originalPosition = pos < 0 ? strValue.length : pos;
    let currency = value.currency;
    const names = Object.keys(spec.alt_unit_names);
    let FRAC_POS_NEW_POSITION = originalPosition;
    if (names.length > 0) {
      let unitIndex = "0";
      names.forEach((index2) => {
        const i3 = Number.parseInt(index2, 10);
        if (Number.isNaN(i3))
          return;
        if (originalPosition - i3 <= 0)
          return;
        if (originalPosition - i3 < FRAC_POS_NEW_POSITION) {
          FRAC_POS_NEW_POSITION = originalPosition - i3;
          unitIndex = index2;
        }
      });
      currency = spec.alt_unit_names[unitIndex];
    }
    if (originalPosition === FRAC_POS_NEW_POSITION) {
      const { normal: normal2, small: small2 } = splitNormalAndSmall(strValue, originalPosition, spec);
      return { currency, normal: normal2, small: small2 };
    }
    const intPart = strValue.substring(0, originalPosition);
    const fracPArt = strValue.substring(originalPosition + 1);
    const newValue = intPart.substring(0, FRAC_POS_NEW_POSITION) + FRAC_SEPARATOR + intPart.substring(FRAC_POS_NEW_POSITION) + fracPArt;
    const { normal, small } = splitNormalAndSmall(newValue, FRAC_POS_NEW_POSITION, spec);
    return { currency, normal, small };
  }
};
function splitNormalAndSmall(decimal, fracSeparatorIndex, spec) {
  let normal;
  let small;
  if (decimal.length - fracSeparatorIndex - 1 > spec.num_fractional_normal_digits) {
    const limit = fracSeparatorIndex + spec.num_fractional_normal_digits + 1;
    normal = decimal.substring(0, limit);
    small = decimal.substring(limit);
  } else {
    normal = decimal;
    small = void 0;
  }
  return { normal, small };
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/punycode.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map(array2, fn2) {
  const result = [];
  let length3 = array2.length;
  while (length3--) {
    result[length3] = fn2(array2[length3]);
  }
  return result;
}
function mapDomain(string2, fn2) {
  const parts = string2.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string2 = parts[1];
  }
  string2 = string2.replace(regexSeparators, ".");
  const labels = string2.split(".");
  const encoded = map(labels, fn2).join(".");
  return result + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter2 = 0;
  const length3 = string2.length;
  while (counter2 < length3) {
    const value = string2.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length3) {
      const extra = string2.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (array2) => String.fromCodePoint(...array2);
var basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k5 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (
    ;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1;
    k5 += base
  ) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k5 + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i3 = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic2 = input.lastIndexOf(delimiter);
  if (basic2 < 0) {
    basic2 = 0;
  }
  for (let j4 = 0; j4 < basic2; ++j4) {
    if (input.charCodeAt(j4) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j4));
  }
  for (let index2 = basic2 > 0 ? basic2 + 1 : 0; index2 < inputLength; ) {
    let oldi = i3;
    for (let w4 = 1, k5 = base; ; k5 += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base || digit > floor((maxInt - i3) / w4)) {
        error("overflow");
      }
      i3 += digit * w4;
      const t4 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
      if (digit < t4) {
        break;
      }
      const baseMinusT = base - t4;
      if (w4 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w4 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i3 - oldi, out, oldi == 0);
    if (floor(i3 / out) > maxInt - n2) {
      error("overflow");
    }
    n2 += floor(i3 / out);
    i3 %= out;
    output.splice(i3++, 0, n2);
  }
  return String.fromCodePoint(...output);
};
var encode = function(inputArg) {
  const output = [];
  let input = ucs2decode(inputArg);
  let inputLength = input.length;
  let n2 = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m3 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m3) {
        m3 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m3 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m3 - n2) * handledCPCountPlusOne;
    n2 = m3;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        let q4 = delta;
        for (let k5 = base; ; k5 += base) {
          const t4 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
          if (q4 < t4) {
            break;
          }
          const qMinusT = q4 - t4;
          const baseMinusT = base - t4;
          output.push(stringFromCharCode(digitToBasic(t4 + qMinusT % baseMinusT, 0)));
          q4 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q4, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ucs2decode,
    encode: ucs2encode
  },
  decode,
  encode,
  toASCII,
  toUnicode
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/whatwg-url.js
var utf8Encoder = new TextEncoder();
var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
function utf8Encode(string2) {
  return utf8Encoder.encode(string2);
}
function utf8DecodeWithoutBOM(bytes) {
  return utf8Decoder.decode(bytes);
}
function parseUrlencoded(input) {
  const sequences = strictlySplitByteSequence(input, p("&"));
  const output = [];
  for (const bytes of sequences) {
    if (bytes.length === 0) {
      continue;
    }
    let name, value;
    const indexOfEqual = bytes.indexOf(p("="));
    if (indexOfEqual >= 0) {
      name = bytes.slice(0, indexOfEqual);
      value = bytes.slice(indexOfEqual + 1);
    } else {
      name = bytes;
      value = new Uint8Array(0);
    }
    name = replaceByteInByteSequence(name, 43, 32);
    value = replaceByteInByteSequence(value, 43, 32);
    const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
    const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
    output.push([nameString, valueString]);
  }
  return output;
}
function parseUrlencodedString(input) {
  return parseUrlencoded(utf8Encode(input));
}
function serializeUrlencoded(tuples, encodingOverride = void 0) {
  let encoding = "utf-8";
  if (encodingOverride !== void 0) {
    encoding = encodingOverride;
  }
  let output = "";
  for (const [i3, tuple] of tuples.entries()) {
    const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
    let value = tuple[1];
    if (tuple.length > 2 && tuple[2] !== void 0) {
      if (tuple[2] === "hidden" && name === "_charset_") {
        value = encoding;
      } else if (tuple[2] === "file") {
        value = value.name;
      }
    }
    value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
    if (i3 !== 0) {
      output += "&";
    }
    output += `${name}=${value}`;
  }
  return output;
}
function strictlySplitByteSequence(buf, cp) {
  const list = [];
  let last = 0;
  let i3 = buf.indexOf(cp);
  while (i3 >= 0) {
    list.push(buf.slice(last, i3));
    last = i3 + 1;
    i3 = buf.indexOf(cp, last);
  }
  if (last !== buf.length) {
    list.push(buf.slice(last));
  }
  return list;
}
function replaceByteInByteSequence(buf, from, to) {
  let i3 = buf.indexOf(from);
  while (i3 >= 0) {
    buf[i3] = to;
    i3 = buf.indexOf(from, i3 + 1);
  }
  return buf;
}
function p(char) {
  return char.codePointAt(0);
}
function percentEncode(c6) {
  let hex2 = c6.toString(16).toUpperCase();
  if (hex2.length === 1) {
    hex2 = `0${hex2}`;
  }
  return `%${hex2}`;
}
function percentDecodeBytes(input) {
  const output = new Uint8Array(input.byteLength);
  let outputIndex = 0;
  for (let i3 = 0; i3 < input.byteLength; ++i3) {
    const byte = input[i3];
    if (byte !== 37) {
      output[outputIndex++] = byte;
    } else if (byte === 37 && (!isASCIIHex(input[i3 + 1]) || !isASCIIHex(input[i3 + 2]))) {
      output[outputIndex++] = byte;
    } else {
      const bytePoint = parseInt(String.fromCodePoint(input[i3 + 1], input[i3 + 2]), 16);
      output[outputIndex++] = bytePoint;
      i3 += 2;
    }
  }
  return output.slice(0, outputIndex);
}
function percentDecodeString(input) {
  const bytes = utf8Encode(input);
  return percentDecodeBytes(bytes);
}
function isC0ControlPercentEncode(c6) {
  return c6 <= 31 || c6 > 126;
}
var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([
  p(" "),
  p('"'),
  p("<"),
  p(">"),
  p("`")
]);
function isFragmentPercentEncode(c6) {
  return isC0ControlPercentEncode(c6) || extraFragmentPercentEncodeSet.has(c6);
}
var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([
  p(" "),
  p('"'),
  p("#"),
  p("<"),
  p(">")
]);
function isQueryPercentEncode(c6) {
  return isC0ControlPercentEncode(c6) || extraQueryPercentEncodeSet.has(c6);
}
function isSpecialQueryPercentEncode(c6) {
  return isQueryPercentEncode(c6) || c6 === p("'");
}
var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}")]);
function isPathPercentEncode(c6) {
  return isQueryPercentEncode(c6) || extraPathPercentEncodeSet.has(c6);
}
var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([
  p("/"),
  p(":"),
  p(";"),
  p("="),
  p("@"),
  p("["),
  p("\\"),
  p("]"),
  p("^"),
  p("|")
]);
function isUserinfoPercentEncode(c6) {
  return isPathPercentEncode(c6) || extraUserinfoPercentEncodeSet.has(c6);
}
var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([
  p("$"),
  p("%"),
  p("&"),
  p("+"),
  p(",")
]);
function isComponentPercentEncode(c6) {
  return isUserinfoPercentEncode(c6) || extraComponentPercentEncodeSet.has(c6);
}
var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([
  p("!"),
  p("'"),
  p("("),
  p(")"),
  p("~")
]);
function isURLEncodedPercentEncode(c6) {
  return isComponentPercentEncode(c6) || extraURLEncodedPercentEncodeSet.has(c6);
}
function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
  const bytes = utf8Encode(codePoint);
  let output = "";
  for (const byte of bytes) {
    if (!percentEncodePredicate(byte)) {
      output += String.fromCharCode(byte);
    } else {
      output += percentEncode(byte);
    }
  }
  return output;
}
function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
  return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
}
function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
  let output = "";
  for (const codePoint of input) {
    if (spaceAsPlus && codePoint === " ") {
      output += "+";
    } else {
      output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
    }
  }
  return output;
}
function isASCIIDigit(c6) {
  return c6 >= 48 && c6 <= 57;
}
function isASCIIAlpha(c6) {
  return c6 >= 65 && c6 <= 90 || c6 >= 97 && c6 <= 122;
}
function isASCIIAlphanumeric(c6) {
  return isASCIIAlpha(c6) || isASCIIDigit(c6);
}
function isASCIIHex(c6) {
  return isASCIIDigit(c6) || c6 >= 65 && c6 <= 70 || c6 >= 97 && c6 <= 102;
}
var URLSearchParamsImpl = class {
  constructor(init2, { doNotStripQMark = false } = {}) {
    this._list = [];
    this._url = null;
    if (!doNotStripQMark && typeof init2 === "string" && init2[0] === "?") {
      init2 = init2.slice(1);
    }
    if (Array.isArray(init2)) {
      for (const pair2 of init2) {
        if (pair2.length !== 2) {
          throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
        }
        this._list.push([pair2[0], pair2[1]]);
      }
    } else if (typeof init2 === "object" && Object.getPrototypeOf(init2) === null) {
      for (const name of Object.keys(init2)) {
        const value = init2[name];
        this._list.push([name, value]);
      }
    } else {
      this._list = parseUrlencodedString(init2);
    }
  }
  _updateSteps() {
    if (this._url !== null) {
      let query = serializeUrlencoded(this._list);
      if (query === "") {
        query = null;
      }
      this._url._url.query = query;
    }
  }
  append(name, value) {
    this._list.push([name, value]);
    this._updateSteps();
  }
  delete(name) {
    let i3 = 0;
    while (i3 < this._list.length) {
      if (this._list[i3][0] === name) {
        this._list.splice(i3, 1);
      } else {
        i3++;
      }
    }
    this._updateSteps();
  }
  get(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return tuple[1];
      }
    }
    return null;
  }
  getAll(name) {
    const output = [];
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        output.push(tuple[1]);
      }
    }
    return output;
  }
  entries() {
    return [...this._list.map((x6) => [x6[0], x6[1]])];
  }
  forEach(callbackfn, thisArg) {
    for (const tuple of this._list) {
      callbackfn.call(thisArg, tuple[1], tuple[0], this);
    }
  }
  has(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return true;
      }
    }
    return false;
  }
  set(name, value) {
    let found = false;
    let i3 = 0;
    while (i3 < this._list.length) {
      if (this._list[i3][0] === name) {
        if (found) {
          this._list.splice(i3, 1);
        } else {
          found = true;
          this._list[i3][1] = value;
          i3++;
        }
      } else {
        i3++;
      }
    }
    if (!found) {
      this._list.push([name, value]);
    }
    this._updateSteps();
  }
  sort() {
    this._list.sort((a4, b3) => {
      if (a4[0] < b3[0]) {
        return -1;
      }
      if (a4[0] > b3[0]) {
        return 1;
      }
      return 0;
    });
    this._updateSteps();
  }
  [Symbol.iterator]() {
    return this._list[Symbol.iterator]();
  }
  toString() {
    return serializeUrlencoded(this._list);
  }
};
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var failure = Symbol("failure");
function countSymbols(str) {
  return [...str].length;
}
function at(input, idx) {
  const c6 = input[idx];
  return isNaN(c6) ? void 0 : String.fromCodePoint(c6);
}
function isSingleDot(buffer) {
  return buffer === "." || buffer.toLowerCase() === "%2e";
}
function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}
function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
}
function isWindowsDriveLetterString(string2) {
  return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
}
function isNormalizedWindowsDriveLetterString(string2) {
  return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
}
function containsForbiddenHostCodePoint(string2) {
  return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
}
function containsForbiddenDomainCodePoint(string2) {
  return containsForbiddenHostCodePoint(string2) || string2.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
}
function isSpecialScheme(scheme28) {
  return specialSchemes[scheme28] !== void 0;
}
function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}
function isNotSpecial(url) {
  return !isSpecialScheme(url.scheme);
}
function defaultPort(scheme28) {
  return specialSchemes[scheme28];
}
function parseIPv4Number(input) {
  if (input === "") {
    return failure;
  }
  let R2 = 10;
  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
    input = input.substring(2);
    R2 = 16;
  } else if (input.length >= 2 && input.charAt(0) === "0") {
    input = input.substring(1);
    R2 = 8;
  }
  if (input === "") {
    return 0;
  }
  let regex = /[^0-7]/u;
  if (R2 === 10) {
    regex = /[^0-9]/u;
  }
  if (R2 === 16) {
    regex = /[^0-9A-Fa-f]/u;
  }
  if (regex.test(input)) {
    return failure;
  }
  return parseInt(input, R2);
}
function parseIPv4(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length > 1) {
      parts.pop();
    }
  }
  if (parts.length > 4) {
    return failure;
  }
  const numbers2 = [];
  for (const part of parts) {
    const n2 = parseIPv4Number(part);
    if (n2 === failure) {
      return failure;
    }
    numbers2.push(n2);
  }
  for (let i3 = 0; i3 < numbers2.length - 1; ++i3) {
    if (numbers2[i3] > 255) {
      return failure;
    }
  }
  if (numbers2[numbers2.length - 1] >= 256 ** (5 - numbers2.length)) {
    return failure;
  }
  let ipv4 = numbers2.pop();
  let counter2 = 0;
  for (const n2 of numbers2) {
    ipv4 += n2 * 256 ** (3 - counter2);
    ++counter2;
  }
  return ipv4;
}
function serializeIPv4(address) {
  let output = "";
  let n2 = address;
  for (let i3 = 1; i3 <= 4; ++i3) {
    output = String(n2 % 256) + output;
    if (i3 !== 4) {
      output = `.${output}`;
    }
    n2 = Math.floor(n2 / 256);
  }
  return output;
}
function parseIPv6(inputArg) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer2 = 0;
  const input = Array.from(inputArg, (c6) => c6.codePointAt(0));
  if (input[pointer2] === p(":")) {
    if (input[pointer2 + 1] !== p(":")) {
      return failure;
    }
    pointer2 += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }
  while (pointer2 < input.length) {
    if (pieceIndex === 8) {
      return failure;
    }
    if (input[pointer2] === p(":")) {
      if (compress !== null) {
        return failure;
      }
      ++pointer2;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }
    let value = 0;
    let length3 = 0;
    while (length3 < 4 && isASCIIHex(input[pointer2])) {
      value = value * 16 + parseInt(at(input, pointer2), 16);
      ++pointer2;
      ++length3;
    }
    if (input[pointer2] === p(".")) {
      if (length3 === 0) {
        return failure;
      }
      pointer2 -= length3;
      if (pieceIndex > 6) {
        return failure;
      }
      let numbersSeen = 0;
      while (input[pointer2] !== void 0) {
        let ipv4Piece = null;
        if (numbersSeen > 0) {
          if (input[pointer2] === p(".") && numbersSeen < 4) {
            ++pointer2;
          } else {
            return failure;
          }
        }
        if (!isASCIIDigit(input[pointer2])) {
          return failure;
        }
        while (isASCIIDigit(input[pointer2])) {
          const number6 = parseInt(at(input, pointer2));
          if (ipv4Piece === null) {
            ipv4Piece = number6;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number6;
          }
          if (ipv4Piece > 255) {
            return failure;
          }
          ++pointer2;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        ++numbersSeen;
        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }
      if (numbersSeen !== 4) {
        return failure;
      }
      break;
    } else if (input[pointer2] === p(":")) {
      ++pointer2;
      if (input[pointer2] === void 0) {
        return failure;
      }
    } else if (input[pointer2] !== void 0) {
      return failure;
    }
    address[pieceIndex] = value;
    ++pieceIndex;
  }
  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null && pieceIndex !== 8) {
    return failure;
  }
  return address;
}
function serializeIPv6(address) {
  let output = "";
  const compress = findLongestZeroSequence(address);
  let ignore0 = false;
  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
    if (ignore0 && address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }
    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    }
    output += address[pieceIndex].toString(16);
    if (pieceIndex !== 7) {
      output += ":";
    }
  }
  return output;
}
function parseHost(input, isNotSpecialArg = false) {
  if (input[0] === "[") {
    if (input[input.length - 1] !== "]") {
      return failure;
    }
    return parseIPv6(input.substring(1, input.length - 1));
  }
  if (isNotSpecialArg) {
    return parseOpaqueHost(input);
  }
  const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
  const asciiDomain = domainToASCII(domain);
  if (asciiDomain === failure) {
    return failure;
  }
  if (containsForbiddenDomainCodePoint(asciiDomain)) {
    return failure;
  }
  if (endsInANumber(asciiDomain)) {
    return parseIPv4(asciiDomain);
  }
  return asciiDomain;
}
function endsInANumber(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length === 1) {
      return false;
    }
    parts.pop();
  }
  const last = parts[parts.length - 1];
  if (parseIPv4Number(last) !== failure) {
    return true;
  }
  if (/^[0-9]+$/u.test(last)) {
    return true;
  }
  return false;
}
function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePoint(input)) {
    return failure;
  }
  return utf8PercentEncodeString(input, isC0ControlPercentEncode);
}
function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1;
  let currStart = null;
  let currLen = 0;
  for (let i3 = 0; i3 < arr.length; ++i3) {
    if (arr[i3] !== 0) {
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i3;
      }
      ++currLen;
    }
  }
  if (currLen > maxLen) {
    return currStart;
  }
  return maxIdx;
}
function serializeHost(host) {
  if (typeof host === "number") {
    return serializeIPv4(host);
  }
  if (host instanceof Array) {
    return `[${serializeIPv6(host)}]`;
  }
  return host;
}
function domainToASCII(domain, beStrict = false) {
  let result;
  try {
    result = punycode.toASCII(domain);
  } catch (e3) {
    return failure;
  }
  if (result === null || result === "") {
    return failure;
  }
  return result;
}
function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/gu, "");
}
function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/gu, "");
}
function shortenPath(url) {
  const { path: path2 } = url;
  if (path2.length === 0) {
    return;
  }
  if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
    return;
  }
  path2.pop();
}
function includesCredentials(url) {
  return url.username !== "" || url.password !== "";
}
function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === "" || url.scheme === "file";
}
function hasAnOpaquePath(url) {
  return typeof url.path === "string";
}
function isNormalizedWindowsDriveLetter(string2) {
  return /^[A-Za-z]:$/u.test(string2);
}
var URLStateMachine = class {
  constructor(input, base2, encodingOverride, url, stateOverride) {
    this.table = {
      "parse scheme start": this.parseSchemeStart,
      "parse scheme": this.parseScheme,
      "parse no scheme": this.parseNoScheme,
      "parse special relative or authority": this.parseSpecialRelativeOrAuthority,
      "parse path or authority": this.parsePathOrAuthority,
      "parse relative": this.parseRelative,
      "parse relative slash": this.parseRelativeSlash,
      "parse special authority slashes": this.parseSpecialAuthoritySlashes,
      "parse special authority ignore slashes": this.parseSpecialAuthorityIgnoreSlashes,
      "parse authority": this.parseAuthority,
      "parse host": this.parseHostName,
      "parse hostname": this.parseHostName,
      "parse port": this.parsePort,
      "parse file": this.parseFile,
      "parse file slash": this.parseFileSlash,
      "parse file host": this.parseFileHost,
      "parse path start": this.parsePathStart,
      "parse path": this.parsePath,
      "parse opaque path": this.parseOpaquePath,
      "parse query": this.parseQuery,
      "parse fragment": this.parseFragment
    };
    this.pointer = 0;
    this.base = base2 || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(input);
      if (res2 !== input) {
        this.parseError = true;
      }
      input = res2;
    }
    const res = trimTabAndNewline(input);
    if (res !== input) {
      this.parseError = true;
    }
    input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(input, (c6) => c6.codePointAt(0));
    for (; this.pointer <= this.input.length; ++this.pointer) {
      const c6 = this.input[this.pointer];
      const cStr = isNaN(c6) ? void 0 : String.fromCodePoint(c6);
      const ret = this.table[`parse ${this.state}`].call(this, c6, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  parseSchemeStart(c6, cStr) {
    if (isASCIIAlpha(c6)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  }
  parseScheme(c6, cStr) {
    if (isASCIIAlphanumeric(c6) || c6 === p("+") || c6 === p("-") || c6 === p(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c6 === p(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = [""];
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  }
  parseNoScheme(c6) {
    if (this.base === null || hasAnOpaquePath(this.base) && c6 !== p("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c6 === p("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  }
  parseSpecialRelativeOrAuthority(c6) {
    if (c6 === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  }
  parsePathOrAuthority(c6) {
    if (c6 === p("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  }
  parseRelative(c6) {
    this.url.scheme = this.base.scheme;
    if (c6 === p("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c6 === p("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c6 === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c6 === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c6)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  }
  parseRelativeSlash(c6) {
    if (isSpecial(this.url) && (c6 === p("/") || c6 === p("\\"))) {
      if (c6 === p("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c6 === p("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  }
  parseSpecialAuthoritySlashes(c6) {
    if (c6 === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  }
  parseSpecialAuthorityIgnoreSlashes(c6) {
    if (c6 !== p("/") && c6 !== p("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  }
  parseAuthority(c6, cStr) {
    if (c6 === p("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer2 = 0; pointer2 < len; ++pointer2) {
        const codePoint = this.buffer.codePointAt(pointer2);
        if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c6) || c6 === p("/") || c6 === p("?") || c6 === p("#") || isSpecial(this.url) && c6 === p("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  }
  parseHostName(c6, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c6 === p(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c6) || c6 === p("/") || c6 === p("?") || c6 === p("#") || isSpecial(this.url) && c6 === p("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c6 === p("[")) {
        this.arrFlag = true;
      } else if (c6 === p("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  }
  parsePort(c6, cStr) {
    if (isASCIIDigit(c6)) {
      this.buffer += cStr;
    } else if (isNaN(c6) || c6 === p("/") || c6 === p("?") || c6 === p("#") || isSpecial(this.url) && c6 === p("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  }
  parseFile(c6) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c6 === p("/") || c6 === p("\\")) {
      if (c6 === p("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c6 === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c6 === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c6)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  }
  parseFileSlash(c6) {
    if (c6 === p("/") || c6 === p("\\")) {
      if (c6 === p("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  }
  parseFileHost(c6, cStr) {
    if (isNaN(c6) || c6 === p("/") || c6 === p("\\") || c6 === p("?") || c6 === p("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  }
  parsePathStart(c6) {
    if (isSpecial(this.url)) {
      if (c6 === p("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c6 !== p("/") && c6 !== p("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c6 === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c6 === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c6 !== void 0) {
      this.state = "path";
      if (c6 !== p("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  }
  parsePath(c6) {
    if (isNaN(c6) || c6 === p("/") || isSpecial(this.url) && c6 === p("\\") || !this.stateOverride && (c6 === p("?") || c6 === p("#"))) {
      if (isSpecial(this.url) && c6 === p("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c6 !== p("/") && !(isSpecial(this.url) && c6 === p("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c6 !== p("/") && !(isSpecial(this.url) && c6 === p("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c6 === p("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c6 === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c6 === p("%") && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint(c6, isPathPercentEncode);
    }
    return true;
  }
  parseOpaquePath(c6) {
    if (c6 === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c6 === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c6) && c6 !== p("%")) {
        this.parseError = true;
      }
      if (c6 === p("%") && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c6)) {
        this.url.path += utf8PercentEncodeCodePoint(c6, isC0ControlPercentEncode);
      }
    }
    return true;
  }
  parseQuery(c6, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c6 === p("#") || isNaN(c6)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
      this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c6 === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c6)) {
      if (c6 === p("%") && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  }
  parseFragment(c6) {
    if (!isNaN(c6)) {
      if (c6 === p("%") && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint(c6, isFragmentPercentEncode);
    }
    return true;
  }
};
var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p("/"), p("\\"), p("?"), p("#")]);
function startsWithWindowsDriveLetter(input, pointer2) {
  const length3 = input.length - pointer2;
  return length3 >= 2 && isWindowsDriveLetterCodePoints(input[pointer2], input[pointer2 + 1]) && (length3 === 2 || fileOtherwiseCodePoints.has(input[pointer2 + 2]));
}
function serializeURL(url, excludeFragment) {
  let output = `${url.scheme}:`;
  if (url.host !== null) {
    output += "//";
    if (url.username !== "" || url.password !== "") {
      output += url.username;
      if (url.password !== "") {
        output += `:${url.password}`;
      }
      output += "@";
    }
    output += serializeHost(url.host);
    if (url.port !== null) {
      output += `:${url.port}`;
    }
  }
  if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
    output += "/.";
  }
  output += serializePath(url);
  if (url.query !== null) {
    output += `?${url.query}`;
  }
  if (!excludeFragment && url.fragment !== null) {
    output += `#${url.fragment}`;
  }
  return output;
}
function serializeOrigin(tuple) {
  let result = `${tuple.scheme}://`;
  result += serializeHost(tuple.host);
  if (tuple.port !== null) {
    result += `:${tuple.port}`;
  }
  return result;
}
function serializePath(url) {
  if (typeof url.path === "string") {
    return url.path;
  }
  let output = "";
  for (const segment of url.path) {
    output += `/${segment}`;
  }
  return output;
}
function serializeURLOrigin(url) {
  switch (url.scheme) {
    case "blob":
      try {
        return serializeURLOrigin(parseURL(serializePath(url)));
      } catch (e3) {
        return "null";
      }
    case "ftp":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case "file":
      return "null";
    default:
      return "null";
  }
}
function basicURLParse(input, options) {
  if (options === void 0) {
    options = {};
  }
  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return null;
  }
  return usm.url;
}
function setTheUsername(url, username) {
  url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
}
function setThePassword(url, password) {
  url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
}
function serializeInteger(integer) {
  return String(integer);
}
function parseURL(input, options) {
  if (options === void 0) {
    options = {};
  }
  return basicURLParse(input, {
    baseURL: options.baseURL,
    encodingOverride: options.encodingOverride
  });
}
var URLImpl = class {
  //Include URL type for "url" and "base" params.
  constructor(url, base2) {
    let parsedBase = null;
    if (base2 !== void 0) {
      if (base2 instanceof URL) {
        base2 = base2.href;
      }
      parsedBase = basicURLParse(base2);
      if (parsedBase === null) {
        throw new TypeError(`Invalid base URL: ${base2}`);
      }
    }
    if (url instanceof URL) {
      url = url.href;
    }
    const parsedURL = basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === null) {
      throw new TypeError(`Invalid URL: ${url}`);
    }
    const query = parsedURL.query !== null ? parsedURL.query : "";
    this._url = parsedURL;
    this._query = new URLSearchParamsImpl(query, {
      doNotStripQMark: true
    });
    this._query._url = this;
  }
  get href() {
    return serializeURL(this._url);
  }
  set href(v3) {
    const parsedURL = basicURLParse(v3);
    if (parsedURL === null) {
      throw new TypeError(`Invalid URL: ${v3}`);
    }
    this._url = parsedURL;
    this._query._list.splice(0);
    const { query } = parsedURL;
    if (query !== null) {
      this._query._list = parseUrlencodedString(query);
    }
  }
  get origin() {
    return serializeURLOrigin(this._url);
  }
  get protocol() {
    return `${this._url.scheme}:`;
  }
  set protocol(v3) {
    basicURLParse(`${v3}:`, {
      url: this._url,
      stateOverride: "scheme start"
    });
  }
  get username() {
    return this._url.username;
  }
  set username(v3) {
    if (cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    setTheUsername(this._url, v3);
  }
  get password() {
    return this._url.password;
  }
  set password(v3) {
    if (cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    setThePassword(this._url, v3);
  }
  get host() {
    const url = this._url;
    if (url.host === null) {
      return "";
    }
    if (url.port === null) {
      return serializeHost(url.host);
    }
    return `${serializeHost(url.host)}:${serializeInteger(url.port)}`;
  }
  set host(v3) {
    if (hasAnOpaquePath(this._url)) {
      return;
    }
    basicURLParse(v3, { url: this._url, stateOverride: "host" });
  }
  get hostname() {
    if (this._url.host === null) {
      return "";
    }
    return serializeHost(this._url.host);
  }
  set hostname(v3) {
    if (hasAnOpaquePath(this._url)) {
      return;
    }
    basicURLParse(v3, { url: this._url, stateOverride: "hostname" });
  }
  get port() {
    if (this._url.port === null) {
      return "";
    }
    return serializeInteger(this._url.port);
  }
  set port(v3) {
    if (cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }
    if (v3 === "") {
      this._url.port = null;
    } else {
      basicURLParse(v3, { url: this._url, stateOverride: "port" });
    }
  }
  get pathname() {
    return serializePath(this._url);
  }
  set pathname(v3) {
    if (hasAnOpaquePath(this._url)) {
      return;
    }
    this._url.path = [];
    basicURLParse(v3, { url: this._url, stateOverride: "path start" });
  }
  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }
    return `?${this._url.query}`;
  }
  set search(v3) {
    const url = this._url;
    if (v3 === "") {
      url.query = null;
      this._query._list = [];
      return;
    }
    const input = v3[0] === "?" ? v3.substring(1) : v3;
    url.query = "";
    basicURLParse(input, { url, stateOverride: "query" });
    this._query._list = parseUrlencodedString(input);
  }
  get searchParams() {
    return this._query;
  }
  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }
    return `#${this._url.fragment}`;
  }
  set hash(v3) {
    if (v3 === "") {
      this._url.fragment = null;
      return;
    }
    const input = v3[0] === "#" ? v3.substring(1) : v3;
    this._url.fragment = "";
    basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }
  toJSON() {
    return this.href;
  }
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/url.js
(function() {
  if (typeof globalThis === "object")
    return;
  Object.defineProperty(Object.prototype, "__magic__", {
    get: function() {
      return this;
    },
    configurable: true
    // This makes it possible to `delete` the getter later.
  });
  __magic__.globalThis = __magic__;
  delete Object.prototype.__magic__;
})();
var useOwnUrlImp = true;
var _URL = globalThis.URL;
if (useOwnUrlImp || !_URL) {
  globalThis.URL = _URL = URLImpl;
  _URL = URLImpl;
}
var URL2 = _URL;
var _URLSearchParams = globalThis.URLSearchParams;
if (useOwnUrlImp || !_URLSearchParams) {
  globalThis.URLSearchParams = URLSearchParamsImpl;
  _URLSearchParams = URLSearchParamsImpl;
}
var URLSearchParams2 = _URLSearchParams;

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/helpers.js
function canonicalizeBaseUrl(url) {
  if (!url.startsWith("http") && !url.startsWith("https")) {
    url = "https://" + url;
  }
  const x6 = new URL2(url);
  if (!x6.pathname.endsWith("/")) {
    x6.pathname = x6.pathname + "/";
  }
  x6.search = "";
  x6.hash = "";
  return x6.href;
}
function canonicalJson(obj) {
  obj = JSON.parse(JSON.stringify(obj));
  if (typeof obj === "string") {
    return JSON.stringify(obj);
  }
  if (typeof obj === "number" || typeof obj === "boolean" || obj === null) {
    return JSON.stringify(obj);
  }
  if (Array.isArray(obj)) {
    const objs = obj.map((e3) => canonicalJson(e3));
    return `[${objs.join(",")}]`;
  }
  const keys = [];
  for (const key in obj) {
    keys.push(key);
  }
  keys.sort();
  let s4 = "{";
  for (let i3 = 0; i3 < keys.length; i3++) {
    const key = keys[i3];
    s4 += JSON.stringify(key) + ":" + canonicalJson(obj[key]);
    if (i3 !== keys.length - 1) {
      s4 += ",";
    }
  }
  return s4 + "}";
}
function strcmp(s1, s22) {
  if (s1 < s22) {
    return -1;
  }
  if (s1 > s22) {
    return 1;
  }
  return 0;
}
function j2s(x6) {
  return JSON.stringify(x6, void 0, 2);
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/logging.js
var isNode = typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node";
var LogLevel;
(function(LogLevel2) {
  LogLevel2["Trace"] = "trace";
  LogLevel2["Message"] = "message";
  LogLevel2["Info"] = "info";
  LogLevel2["Warn"] = "warn";
  LogLevel2["Error"] = "error";
  LogLevel2["None"] = "none";
})(LogLevel || (LogLevel = {}));
var globalLogLevel = LogLevel.Info;
var byTagLogLevel = {};
var nativeLogging = false;
Error.prototype.toString = function() {
  if (this === null || typeof this !== "object" && typeof this !== "function") {
    throw new TypeError();
  }
  let name = this.name;
  name = name === void 0 ? "Error" : `${name}`;
  let msg = this.message;
  msg = msg === void 0 ? "" : `${msg}`;
  let cause = "";
  if ("cause" in this) {
    cause = `
 Caused by: ${this.cause}`;
  }
  return `${name}: ${msg}${cause}`;
};
function writeNativeLog(message, tag, level, args) {
  const logFn = globalThis.__nativeLog;
  if (logFn) {
    let m3;
    if (args.length == 0) {
      m3 = message;
    } else {
      m3 = message + " " + args.toString();
    }
    logFn(level, tag, message);
  }
}
function writeNodeLog(message, tag, level, args) {
  try {
    let msg = `${(/* @__PURE__ */ new Date()).toISOString()} ${tag} ${level} ${message}`;
    if (args.length != 0) {
      msg += ` ${JSON.stringify(args, void 0, 2)}
`;
    } else {
      msg += `
`;
    }
    process.stderr.write(msg);
  } catch (e3) {
    let msg = `${(/* @__PURE__ */ new Date()).toISOString()} (logger) FATAL `;
    if (e3 instanceof Error) {
      msg += `failed to write log: ${e3.message}
`;
    } else {
      msg += "failed to write log\n";
    }
    process.stderr.write(msg);
  }
}
var Logger = class {
  constructor(tag) {
    this.tag = tag;
  }
  shouldLogTrace() {
    const level = byTagLogLevel[this.tag] ?? globalLogLevel;
    switch (level) {
      case LogLevel.Trace:
        return true;
      case LogLevel.Message:
      case LogLevel.Info:
      case LogLevel.Warn:
      case LogLevel.Error:
      case LogLevel.None:
        return false;
    }
  }
  shouldLogInfo() {
    const level = byTagLogLevel[this.tag] ?? globalLogLevel;
    switch (level) {
      case LogLevel.Trace:
      case LogLevel.Message:
      case LogLevel.Info:
        return true;
      case LogLevel.Warn:
      case LogLevel.Error:
      case LogLevel.None:
        return false;
    }
  }
  shouldLogWarn() {
    const level = byTagLogLevel[this.tag] ?? globalLogLevel;
    switch (level) {
      case LogLevel.Trace:
      case LogLevel.Message:
      case LogLevel.Info:
      case LogLevel.Warn:
        return true;
      case LogLevel.Error:
      case LogLevel.None:
        return false;
    }
  }
  shouldLogError() {
    const level = byTagLogLevel[this.tag] ?? globalLogLevel;
    switch (level) {
      case LogLevel.Trace:
      case LogLevel.Message:
      case LogLevel.Info:
      case LogLevel.Warn:
      case LogLevel.Error:
        return true;
      case LogLevel.None:
        return false;
    }
  }
  info(message, ...args) {
    if (!this.shouldLogInfo()) {
      return;
    }
    if (nativeLogging) {
      writeNativeLog(message, this.tag, 2, args);
      return;
    }
    if (isNode) {
      writeNodeLog(message, this.tag, "INFO", args);
    } else {
      console.info(`${(/* @__PURE__ */ new Date()).toISOString()} ${this.tag} INFO ` + message, ...args);
    }
  }
  warn(message, ...args) {
    if (!this.shouldLogWarn()) {
      return;
    }
    if (nativeLogging) {
      writeNativeLog(message, this.tag, 3, args);
      return;
    }
    if (isNode) {
      writeNodeLog(message, this.tag, "WARN", args);
    } else {
      console.warn(`${(/* @__PURE__ */ new Date()).toISOString()} ${this.tag} INFO ` + message, ...args);
    }
  }
  error(message, ...args) {
    if (!this.shouldLogError()) {
      return;
    }
    if (nativeLogging) {
      writeNativeLog(message, this.tag, 4, args);
      return;
    }
    if (isNode) {
      writeNodeLog(message, this.tag, "ERROR", args);
    } else {
      console.info(`${(/* @__PURE__ */ new Date()).toISOString()} ${this.tag} ERROR ` + message, ...args);
    }
  }
  trace(message, ...args) {
    if (!this.shouldLogTrace()) {
      return;
    }
    if (nativeLogging) {
      writeNativeLog(message, this.tag, 1, args);
      return;
    }
    if (isNode) {
      writeNodeLog(message, this.tag, "TRACE", args);
    } else {
      console.info(`${(/* @__PURE__ */ new Date()).toISOString()} ${this.tag} TRACE ` + message, ...args);
    }
  }
  reportBreak() {
    if (!this.shouldLogError()) {
      return;
    }
    const location2 = new Error("programming error");
    this.error(`assertion failed: ${location2.stack}`);
  }
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/codec.js
var logger = new Logger("codec.ts");
var DecodingError = class _DecodingError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _DecodingError.prototype);
    this.name = "DecodingError";
  }
};
function renderContext(c6) {
  const p4 = c6?.path;
  if (p4) {
    return p4.join(".");
  } else {
    return "(unknown)";
  }
}
function joinContext(c6, part) {
  const path2 = c6?.path ?? [];
  return {
    path: path2.concat([part])
  };
}
var ObjectCodecBuilder = class {
  constructor() {
    this.propList = [];
  }
  /**
   * Define a property for the object.
   */
  property(x6, codec) {
    if (!codec) {
      throw Error("inner codec must be defined");
    }
    this.propList.push({ name: x6, codec });
    return this;
  }
  /**
   * Return the built codec.
   *
   * @param objectDisplayName name of the object that this codec operates on,
   *   used in error messages.
   */
  build(objectDisplayName) {
    const propList = this.propList;
    return {
      decode(x6, c6) {
        if (!c6) {
          c6 = {
            path: [`(${objectDisplayName})`]
          };
        }
        if (typeof x6 !== "object") {
          throw new DecodingError(`expected object for ${objectDisplayName} at ${renderContext(c6)} but got ${typeof x6}`);
        }
        const obj = {};
        for (const prop of propList) {
          const propRawVal = x6[prop.name];
          const propVal = prop.codec.decode(propRawVal, joinContext(c6, prop.name));
          obj[prop.name] = propVal;
        }
        return obj;
      }
    };
  }
};
function buildCodecForObject() {
  return new ObjectCodecBuilder();
}
function codecForMap(innerCodec) {
  if (!innerCodec) {
    throw Error("inner codec must be defined");
  }
  return {
    decode(x6, c6) {
      const map4 = {};
      if (typeof x6 !== "object") {
        throw new DecodingError(`expected object at ${renderContext(c6)}`);
      }
      for (const i3 in x6) {
        map4[i3] = innerCodec.decode(x6[i3], joinContext(c6, `[${i3}]`));
      }
      return map4;
    }
  };
}
function codecForList(innerCodec) {
  if (!innerCodec) {
    throw Error("inner codec must be defined");
  }
  return {
    decode(x6, c6) {
      const arr = [];
      if (!Array.isArray(x6)) {
        throw new DecodingError(`expected array at ${renderContext(c6)}`);
      }
      for (const i3 in x6) {
        arr.push(innerCodec.decode(x6[i3], joinContext(c6, `[${i3}]`)));
      }
      return arr;
    }
  };
}
function codecForNumber() {
  return {
    decode(x6, c6) {
      if (typeof x6 === "number") {
        return x6;
      }
      throw new DecodingError(`expected number at ${renderContext(c6)} but got ${typeof x6}`);
    }
  };
}
function codecForString() {
  return {
    decode(x6, c6) {
      if (typeof x6 === "string") {
        return x6;
      }
      throw new DecodingError(`expected string at ${renderContext(c6)} but got ${typeof x6}`);
    }
  };
}
function codecForAny() {
  return {
    decode(x6, c6) {
      return x6;
    }
  };
}
function codecForConstString(s4) {
  return {
    decode(x6, c6) {
      if (x6 === s4) {
        return x6;
      }
      if (typeof x6 !== "string") {
        throw new DecodingError(`expected string constant "${s4}" at ${renderContext(c6)} but got ${typeof x6}`);
      }
      throw new DecodingError(`expected string constant "${s4}" at ${renderContext(c6)} but got string value "${x6}"`);
    }
  };
}
function codecOptional(innerCodec) {
  return {
    decode(x6, c6) {
      if (x6 === void 0 || x6 === null) {
        return void 0;
      }
      return innerCodec.decode(x6, c6);
    }
  };
}
function codecForEither(...alts) {
  return {
    decode(x6, c6) {
      for (const alt of alts) {
        try {
          return alt.decode(x6, c6);
        } catch (e3) {
          continue;
        }
      }
      if (logger.shouldLogTrace()) {
        logger.trace(`offending value: ${j2s(x6)}`);
      }
      throw new DecodingError(`No alternative matched at at ${renderContext(c6)}`);
    }
  };
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-status-codes.js
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
  HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
  HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
  HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
  HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
  HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
  HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
  HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
  HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode2[HttpStatusCode2["SwitchProxy"] = 306] = "SwitchProxy";
  HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
  HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
  HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode2[HttpStatusCode2["IAmATeapot"] = 418] = "IAmATeapot";
  HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
  HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-impl.missing.js
var HttpLibImpl = class {
  fetch(url, opt) {
    throw new Error("Method not implemented.");
  }
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/time.js
var opaque_AbsoluteTime = Symbol("opaque_AbsoluteTime");
var TalerPreciseTimestamp;
(function(TalerPreciseTimestamp3) {
  function now2() {
    const absNow = AbsoluteTime.now();
    return AbsoluteTime.toPreciseTimestamp(absNow);
  }
  TalerPreciseTimestamp3.now = now2;
  function round(t4) {
    return {
      t_s: t4.t_s
    };
  }
  TalerPreciseTimestamp3.round = round;
  function fromSeconds(s4) {
    return {
      t_s: Math.floor(s4),
      off_us: Math.floor((s4 - Math.floor(s4)) / 1e3 / 1e3)
    };
  }
  TalerPreciseTimestamp3.fromSeconds = fromSeconds;
  function fromMilliseconds(ms) {
    return {
      t_s: Math.floor(ms / 1e3),
      off_us: Math.floor((ms - Math.floor(ms / 1e3) * 1e3) * 1e3)
    };
  }
  TalerPreciseTimestamp3.fromMilliseconds = fromMilliseconds;
})(TalerPreciseTimestamp || (TalerPreciseTimestamp = {}));
var TalerProtocolTimestamp;
(function(TalerProtocolTimestamp3) {
  function now2() {
    return AbsoluteTime.toProtocolTimestamp(AbsoluteTime.now());
  }
  TalerProtocolTimestamp3.now = now2;
  function zero3() {
    return {
      t_s: 0
    };
  }
  TalerProtocolTimestamp3.zero = zero3;
  function never() {
    return {
      t_s: "never"
    };
  }
  TalerProtocolTimestamp3.never = never;
  function isNever(t4) {
    return t4.t_s === "never";
  }
  TalerProtocolTimestamp3.isNever = isNever;
  function fromSeconds(s4) {
    return {
      t_s: s4
    };
  }
  TalerProtocolTimestamp3.fromSeconds = fromSeconds;
  function min4(t13, t23) {
    if (t13.t_s === "never") {
      return { t_s: t23.t_s };
    }
    if (t23.t_s === "never") {
      return { t_s: t13.t_s };
    }
    return { t_s: Math.min(t13.t_s, t23.t_s) };
  }
  TalerProtocolTimestamp3.min = min4;
  function max3(t13, t23) {
    if (t13.t_s === "never" || t23.t_s === "never") {
      return { t_s: "never" };
    }
    return { t_s: Math.max(t13.t_s, t23.t_s) };
  }
  TalerProtocolTimestamp3.max = max3;
})(TalerProtocolTimestamp || (TalerProtocolTimestamp = {}));
var timeshift = 0;
var Duration;
(function(Duration3) {
  function toMilliseconds(d3) {
    if (d3.d_ms === "forever") {
      return Number.MAX_VALUE;
    }
    return d3.d_ms;
  }
  Duration3.toMilliseconds = toMilliseconds;
  function getRemaining(deadline, now2 = AbsoluteTime.now()) {
    if (deadline.t_ms === "never") {
      return { d_ms: "forever" };
    }
    if (now2.t_ms === "never") {
      throw Error("invalid argument for 'now'");
    }
    if (deadline.t_ms < now2.t_ms) {
      return { d_ms: 0 };
    }
    return { d_ms: deadline.t_ms - now2.t_ms };
  }
  Duration3.getRemaining = getRemaining;
  function fromPrettyString(s4) {
    let dMs = 0;
    let currentNum = "";
    let parsingNum = true;
    for (let i3 = 0; i3 < s4.length; i3++) {
      const cc = s4.charCodeAt(i3);
      if (cc >= "0".charCodeAt(0) && cc <= "9".charCodeAt(0)) {
        if (!parsingNum) {
          throw Error("invalid duration, unexpected number");
        }
        currentNum += s4[i3];
        continue;
      }
      if (s4[i3] == " ") {
        if (currentNum != "") {
          parsingNum = false;
        }
        continue;
      }
      if (currentNum == "") {
        throw Error("invalid duration, missing number");
      }
      if (s4[i3] === "s") {
        dMs += 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "m") {
        dMs += 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "h") {
        dMs += 60 * 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "d") {
        dMs += 24 * 60 * 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else {
        throw Error("invalid duration, unsupported unit");
      }
      currentNum = "";
      parsingNum = true;
    }
    return {
      d_ms: dMs
    };
  }
  Duration3.fromPrettyString = fromPrettyString;
  function cmp(d1, d22) {
    if (d1.d_ms === "forever") {
      if (d22.d_ms === "forever") {
        return 0;
      }
      return 1;
    }
    if (d22.d_ms === "forever") {
      return -1;
    }
    if (d1.d_ms == d22.d_ms) {
      return 0;
    }
    if (d1.d_ms > d22.d_ms) {
      return 1;
    }
    return -1;
  }
  Duration3.cmp = cmp;
  function max3(d1, d22) {
    return durationMax(d1, d22);
  }
  Duration3.max = max3;
  function min4(d1, d22) {
    return durationMin(d1, d22);
  }
  Duration3.min = min4;
  function multiply(d1, n2) {
    return durationMul(d1, n2);
  }
  Duration3.multiply = multiply;
  function toIntegerYears(d3) {
    if (typeof d3.d_ms !== "number") {
      throw Error("infinite duration");
    }
    return Math.ceil(d3.d_ms / 1e3 / 60 / 60 / 24 / 365);
  }
  Duration3.toIntegerYears = toIntegerYears;
  function fromSpec(spec) {
    let d_ms = 0;
    d_ms += (spec.seconds ?? 0) * SECONDS;
    d_ms += (spec.minutes ?? 0) * MINUTES;
    d_ms += (spec.hours ?? 0) * HOURS;
    d_ms += (spec.days ?? 0) * DAYS;
    d_ms += (spec.months ?? 0) * MONTHS;
    d_ms += (spec.years ?? 0) * YEARS;
    return { d_ms };
  }
  Duration3.fromSpec = fromSpec;
  function getForever() {
    return { d_ms: "forever" };
  }
  Duration3.getForever = getForever;
  function getZero() {
    return { d_ms: 0 };
  }
  Duration3.getZero = getZero;
  function fromTalerProtocolDuration(d3) {
    if (d3.d_us === "forever") {
      return {
        d_ms: "forever"
      };
    }
    return {
      d_ms: Math.floor(d3.d_us / 1e3)
    };
  }
  Duration3.fromTalerProtocolDuration = fromTalerProtocolDuration;
  function toTalerProtocolDuration(d3) {
    if (d3.d_ms === "forever") {
      return {
        d_us: "forever"
      };
    }
    return {
      d_us: d3.d_ms * 1e3
    };
  }
  Duration3.toTalerProtocolDuration = toTalerProtocolDuration;
  function fromMilliseconds(ms) {
    return {
      d_ms: ms
    };
  }
  Duration3.fromMilliseconds = fromMilliseconds;
  function clamp(args) {
    return durationMax(durationMin(args.value, args.upper), args.lower);
  }
  Duration3.clamp = clamp;
})(Duration || (Duration = {}));
var AbsoluteTime;
(function(AbsoluteTime3) {
  function getStampMsNow() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  AbsoluteTime3.getStampMsNow = getStampMsNow;
  function getStampMsNever() {
    return Number.MAX_SAFE_INTEGER;
  }
  AbsoluteTime3.getStampMsNever = getStampMsNever;
  function now2() {
    return {
      t_ms: (/* @__PURE__ */ new Date()).getTime() + timeshift,
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.now = now2;
  function never() {
    return {
      t_ms: "never",
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.never = never;
  function fromMilliseconds(ms) {
    return {
      t_ms: ms,
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.fromMilliseconds = fromMilliseconds;
  function cmp(t13, t23) {
    if (t13.t_ms === "never") {
      if (t23.t_ms === "never") {
        return 0;
      }
      return 1;
    }
    if (t23.t_ms === "never") {
      return -1;
    }
    if (t13.t_ms == t23.t_ms) {
      return 0;
    }
    if (t13.t_ms > t23.t_ms) {
      return 1;
    }
    return -1;
  }
  AbsoluteTime3.cmp = cmp;
  function min4(t13, t23) {
    if (t13.t_ms === "never") {
      return { t_ms: t23.t_ms, [opaque_AbsoluteTime]: true };
    }
    if (t23.t_ms === "never") {
      return { t_ms: t23.t_ms, [opaque_AbsoluteTime]: true };
    }
    return { t_ms: Math.min(t13.t_ms, t23.t_ms), [opaque_AbsoluteTime]: true };
  }
  AbsoluteTime3.min = min4;
  function max3(t13, t23) {
    if (t13.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    if (t23.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    return { t_ms: Math.max(t13.t_ms, t23.t_ms), [opaque_AbsoluteTime]: true };
  }
  AbsoluteTime3.max = max3;
  function difference2(t13, t23) {
    if (t13.t_ms === "never") {
      return { d_ms: "forever" };
    }
    if (t23.t_ms === "never") {
      return { d_ms: "forever" };
    }
    return { d_ms: Math.abs(t13.t_ms - t23.t_ms) };
  }
  AbsoluteTime3.difference = difference2;
  function isExpired(t4) {
    return cmp(t4, now2()) <= 0;
  }
  AbsoluteTime3.isExpired = isExpired;
  function isNever(t4) {
    return t4.t_ms === "never";
  }
  AbsoluteTime3.isNever = isNever;
  function fromProtocolTimestamp(t4) {
    if (t4.t_s === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    return {
      t_ms: t4.t_s * 1e3,
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.fromProtocolTimestamp = fromProtocolTimestamp;
  function fromStampMs(stampMs) {
    return {
      t_ms: stampMs,
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.fromStampMs = fromStampMs;
  function fromPreciseTimestamp(t4) {
    if (t4.t_s === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    const offsetUs = t4.off_us ?? 0;
    return {
      t_ms: t4.t_s * 1e3 + Math.floor(offsetUs / 1e3),
      [opaque_AbsoluteTime]: true
    };
  }
  AbsoluteTime3.fromPreciseTimestamp = fromPreciseTimestamp;
  function toStampMs(at2) {
    if (at2.t_ms === "never") {
      return Number.MAX_SAFE_INTEGER;
    }
    return at2.t_ms;
  }
  AbsoluteTime3.toStampMs = toStampMs;
  function toPreciseTimestamp(at2) {
    if (at2.t_ms == "never") {
      return {
        t_s: "never"
      };
    }
    const t_s = Math.floor(at2.t_ms / 1e3);
    const off_us = Math.floor(1e3 * (at2.t_ms - t_s * 1e3));
    return {
      t_s,
      off_us
    };
  }
  AbsoluteTime3.toPreciseTimestamp = toPreciseTimestamp;
  function toProtocolTimestamp(at2) {
    if (at2.t_ms === "never") {
      return { t_s: "never" };
    }
    return {
      t_s: Math.floor(at2.t_ms / 1e3)
    };
  }
  AbsoluteTime3.toProtocolTimestamp = toProtocolTimestamp;
  function isBetween(t4, start2, end) {
    if (cmp(t4, start2) < 0) {
      return false;
    }
    if (cmp(t4, end) > 0) {
      return false;
    }
    return true;
  }
  AbsoluteTime3.isBetween = isBetween;
  function toIsoString(t4) {
    if (t4.t_ms === "never") {
      return "<never>";
    } else {
      return new Date(t4.t_ms).toISOString();
    }
  }
  AbsoluteTime3.toIsoString = toIsoString;
  function addDuration(t13, d3) {
    if (t13.t_ms === "never" || d3.d_ms === "forever") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    return { t_ms: t13.t_ms + d3.d_ms, [opaque_AbsoluteTime]: true };
  }
  AbsoluteTime3.addDuration = addDuration;
  function remaining(t13) {
    if (t13.t_ms === "never") {
      return Duration.getForever();
    }
    const stampNow = now2();
    if (stampNow.t_ms === "never") {
      throw Error("invariant violated");
    }
    return Duration.fromMilliseconds(Math.max(0, t13.t_ms - stampNow.t_ms));
  }
  AbsoluteTime3.remaining = remaining;
  function subtractDuraction(t13, d3) {
    if (t13.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime]: true };
    }
    if (d3.d_ms === "forever") {
      return { t_ms: 0, [opaque_AbsoluteTime]: true };
    }
    return { t_ms: Math.max(0, t13.t_ms - d3.d_ms), [opaque_AbsoluteTime]: true };
  }
  AbsoluteTime3.subtractDuraction = subtractDuraction;
  function stringify(t4) {
    if (t4.t_ms === "never") {
      return "never";
    }
    return new Date(t4.t_ms).toISOString();
  }
  AbsoluteTime3.stringify = stringify;
})(AbsoluteTime || (AbsoluteTime = {}));
var SECONDS = 1e3;
var MINUTES = SECONDS * 60;
var HOURS = MINUTES * 60;
var DAYS = HOURS * 24;
var MONTHS = DAYS * 30;
var YEARS = DAYS * 365;
function durationMin(d1, d22) {
  if (d1.d_ms === "forever") {
    return { d_ms: d22.d_ms };
  }
  if (d22.d_ms === "forever") {
    return { d_ms: d1.d_ms };
  }
  return { d_ms: Math.min(d1.d_ms, d22.d_ms) };
}
function durationMax(d1, d22) {
  if (d1.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  if (d22.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  return { d_ms: Math.max(d1.d_ms, d22.d_ms) };
}
function durationMul(d3, n2) {
  if (d3.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  return { d_ms: Math.round(d3.d_ms * n2) };
}
var codecForAbsoluteTime = {
  decode(x6, c6) {
    if (x6 === void 0) {
      throw Error(`got undefined and expected absolute time at ${renderContext(c6)}`);
    }
    const t_ms = x6.t_ms;
    if (typeof t_ms === "string") {
      if (t_ms === "never") {
        return { t_ms: "never", [opaque_AbsoluteTime]: true };
      }
    } else if (typeof t_ms === "number") {
      return { t_ms, [opaque_AbsoluteTime]: true };
    }
    throw Error(`expected timestamp at ${renderContext(c6)}`);
  }
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-common.js
var textEncoder = new TextEncoder();
var logger2 = new Logger("http.ts");
async function readTalerErrorResponse(httpResponse) {
  const contentType = httpResponse.headers.get("content-type");
  if (contentType !== "application/json") {
    throw TalerError.fromDetail(TalerErrorCode.WALLET_RECEIVED_MALFORMED_RESPONSE, {
      requestUrl: httpResponse.requestUrl,
      requestMethod: httpResponse.requestMethod,
      httpStatusCode: httpResponse.status,
      contentType: contentType || "<null>"
    }, "Error response did not even contain JSON. The request URL might be wrong or the service might be unavailable.");
  }
  let errJson;
  try {
    errJson = await httpResponse.json();
  } catch (e3) {
    throw TalerError.fromDetail(TalerErrorCode.WALLET_RECEIVED_MALFORMED_RESPONSE, {
      requestUrl: httpResponse.requestUrl,
      requestMethod: httpResponse.requestMethod,
      httpStatusCode: httpResponse.status,
      response: await httpResponse.text(),
      validationError: e3 instanceof Error ? e3.message : String(e3)
    }, "Couldn't parse JSON format from error response");
  }
  const talerErrorCode = errJson.code;
  if (typeof talerErrorCode !== "number") {
    logger2.warn(`malformed error response (status ${httpResponse.status}): ${j2s(errJson)}`);
    throw TalerError.fromDetail(TalerErrorCode.WALLET_RECEIVED_MALFORMED_RESPONSE, {
      requestUrl: httpResponse.requestUrl,
      requestMethod: httpResponse.requestMethod,
      httpStatusCode: httpResponse.status,
      response: await httpResponse.text()
    }, "Error response did not contain error code");
  }
  return errJson;
}
async function readSuccessResponseJsonOrErrorCode(httpResponse, codec) {
  if (!(httpResponse.status >= 200 && httpResponse.status < 300)) {
    return {
      isError: true,
      talerErrorResponse: await readTalerErrorResponse(httpResponse)
    };
  }
  let respJson;
  try {
    respJson = await httpResponse.json();
  } catch (e3) {
    throw TalerError.fromDetail(TalerErrorCode.WALLET_RECEIVED_MALFORMED_RESPONSE, {
      requestUrl: httpResponse.requestUrl,
      requestMethod: httpResponse.requestMethod,
      httpStatusCode: httpResponse.status,
      response: await httpResponse.text(),
      validationError: e3 instanceof Error ? e3.message : String(e3)
    }, "Couldn't parse JSON format from response");
  }
  let parsedResponse;
  try {
    parsedResponse = codec.decode(respJson);
  } catch (e3) {
    throw TalerError.fromDetail(TalerErrorCode.WALLET_RECEIVED_MALFORMED_RESPONSE, {
      requestUrl: httpResponse.requestUrl,
      requestMethod: httpResponse.requestMethod,
      httpStatusCode: httpResponse.status,
      response: await httpResponse.text(),
      validationError: e3 instanceof Error ? e3.message : String(e3)
    }, "Response invalid");
  }
  return {
    isError: false,
    response: parsedResponse
  };
}
function throwUnexpectedRequestError(httpResponse, talerErrorResponse) {
  throw TalerError.fromDetail(TalerErrorCode.WALLET_UNEXPECTED_REQUEST_ERROR, {
    requestUrl: httpResponse.requestUrl,
    requestMethod: httpResponse.requestMethod,
    httpStatusCode: httpResponse.status,
    errorResponse: talerErrorResponse
  }, `Unexpected HTTP status ${httpResponse.status} in response`);
}
async function readSuccessResponseJsonOrThrow(httpResponse, codec) {
  const r3 = await readSuccessResponseJsonOrErrorCode(httpResponse, codec);
  if (!r3.isError) {
    return r3.response;
  }
  throwUnexpectedRequestError(httpResponse, r3.talerErrorResponse);
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http.js
function createPlatformHttpLib(args) {
  return new HttpLibImpl(args);
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/libtool-version.js
var LibtoolVersion;
(function(LibtoolVersion2) {
  function compare2(me, other) {
    const meVer = parseVersion(me);
    const otherVer = parseVersion(other);
    if (!(meVer && otherVer)) {
      return void 0;
    }
    const compatible = meVer.current - meVer.age <= otherVer.current && meVer.current >= otherVer.current - otherVer.age;
    const currentCmp = Math.sign(meVer.current - otherVer.current);
    return { compatible, currentCmp };
  }
  LibtoolVersion2.compare = compare2;
  function parseVersion(v3) {
    const [currentStr, revisionStr, ageStr, ...rest] = v3.split(":");
    if (rest.length !== 0) {
      return void 0;
    }
    const current = Number.parseInt(currentStr);
    const revision = Number.parseInt(revisionStr);
    const age = Number.parseInt(ageStr);
    if (Number.isNaN(current)) {
      return void 0;
    }
    if (Number.isNaN(revision)) {
      return void 0;
    }
    if (Number.isNaN(age)) {
      return void 0;
    }
    return { current, revision, age };
  }
  LibtoolVersion2.parseVersion = parseVersion;
})(LibtoolVersion || (LibtoolVersion = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/operation.js
async function opSuccessFromHttp(resp, codec) {
  const body = await readSuccessResponseJsonOrThrow(resp, codec);
  return { type: "ok", body };
}
function opFixedSuccess(body) {
  return { type: "ok", body };
}
function opEmptySuccess(resp) {
  return { type: "ok", body: void 0 };
}
async function opKnownHttpFailure(s4, resp) {
  const detail = await readTalerErrorResponse(resp);
  return { type: "fail", case: s4, detail };
}
function opKnownTalerFailure(s4, detail) {
  return { type: "fail", case: s4, detail };
}
function opUnknownFailure(resp, error2) {
  throw TalerError.fromDetail(TalerErrorCode.WALLET_UNEXPECTED_REQUEST_ERROR, {
    requestUrl: resp.requestUrl,
    requestMethod: resp.requestMethod,
    httpStatusCode: resp.status,
    errorResponse: error2
  }, `Unexpected HTTP status ${resp.status} in response`);
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-common.js
var codecForURLString = codecForString;
var codecForCurrencyName = codecForString;
var codecForCurrencySpecificiation = () => buildCodecForObject().property("name", codecForString()).property("num_fractional_input_digits", codecForNumber()).property("num_fractional_normal_digits", codecForNumber()).property("num_fractional_trailing_zero_digits", codecForNumber()).property("alt_unit_names", codecForMap(codecForString())).build("CurrencySpecification");
var ExchangeProtocolVersion;
(function(ExchangeProtocolVersion2) {
  ExchangeProtocolVersion2[ExchangeProtocolVersion2["V12"] = 12] = "V12";
})(ExchangeProtocolVersion || (ExchangeProtocolVersion = {}));
var MerchantProtocolVersion;
(function(MerchantProtocolVersion2) {
  MerchantProtocolVersion2[MerchantProtocolVersion2["V3"] = 3] = "V3";
})(MerchantProtocolVersion || (MerchantProtocolVersion = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-merchant.js
var TokenFamilyKind;
(function(TokenFamilyKind2) {
  TokenFamilyKind2["Discount"] = "discount";
  TokenFamilyKind2["Subscription"] = "subscription";
})(TokenFamilyKind || (TokenFamilyKind = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/MerchantApiClient.js
var logger3 = new Logger("MerchantApiClient.ts");

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/RequestThrottler.js
var logger4 = new Logger("RequestThrottler.ts");

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/ReserveTransaction.js
var ReserveTransactionType;
(function(ReserveTransactionType2) {
  ReserveTransactionType2["Withdraw"] = "WITHDRAW";
  ReserveTransactionType2["Credit"] = "CREDIT";
  ReserveTransactionType2["Recoup"] = "RECOUP";
  ReserveTransactionType2["Closing"] = "CLOSING";
})(ReserveTransactionType || (ReserveTransactionType = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/TaskThrottler.js
var logger5 = new Logger("OperationThrottler.ts");

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/bank-api-client.js
var logger6 = new Logger("bank-api-client.ts");
var CreditDebitIndicator;
(function(CreditDebitIndicator2) {
  CreditDebitIndicator2["Credit"] = "credit";
  CreditDebitIndicator2["Debit"] = "debit";
})(CreditDebitIndicator || (CreditDebitIndicator = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/taler-crypto.js
var import_big_integer = __toESM(require_BigInteger(), 1);

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/sha256.js
var digestLength = 32;
var blockSize = 64;
var K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
function hashBlocks(w4, v3, p4, pos, len) {
  let a4, b3, c6, d3, e3, f3, g4, h3, u3, i3, j4, t13, t23;
  while (len >= 64) {
    a4 = v3[0];
    b3 = v3[1];
    c6 = v3[2];
    d3 = v3[3];
    e3 = v3[4];
    f3 = v3[5];
    g4 = v3[6];
    h3 = v3[7];
    for (i3 = 0; i3 < 16; i3++) {
      j4 = pos + i3 * 4;
      w4[i3] = (p4[j4] & 255) << 24 | (p4[j4 + 1] & 255) << 16 | (p4[j4 + 2] & 255) << 8 | p4[j4 + 3] & 255;
    }
    for (i3 = 16; i3 < 64; i3++) {
      u3 = w4[i3 - 2];
      t13 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
      u3 = w4[i3 - 15];
      t23 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
      w4[i3] = (t13 + w4[i3 - 7] | 0) + (t23 + w4[i3 - 16] | 0);
    }
    for (i3 = 0; i3 < 64; i3++) {
      t13 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f3 ^ ~e3 & g4) | 0) + (h3 + (K2[i3] + w4[i3] | 0) | 0) | 0;
      t23 = ((a4 >>> 2 | a4 << 32 - 2) ^ (a4 >>> 13 | a4 << 32 - 13) ^ (a4 >>> 22 | a4 << 32 - 22)) + (a4 & b3 ^ a4 & c6 ^ b3 & c6) | 0;
      h3 = g4;
      g4 = f3;
      f3 = e3;
      e3 = d3 + t13 | 0;
      d3 = c6;
      c6 = b3;
      b3 = a4;
      a4 = t13 + t23 | 0;
    }
    v3[0] += a4;
    v3[1] += b3;
    v3[2] += c6;
    v3[3] += d3;
    v3[4] += e3;
    v3[5] += f3;
    v3[6] += g4;
    v3[7] += h3;
    pos += 64;
    len -= 64;
  }
  return pos;
}
var HashSha256 = class {
  constructor() {
    this.digestLength = digestLength;
    this.blockSize = blockSize;
    this.state = new Int32Array(8);
    this.temp = new Int32Array(64);
    this.buffer = new Uint8Array(128);
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
    this.reset();
  }
  // Resets hash state making it possible
  // to reuse this instance to hash other data.
  reset() {
    this.state[0] = 1779033703;
    this.state[1] = 3144134277;
    this.state[2] = 1013904242;
    this.state[3] = 2773480762;
    this.state[4] = 1359893119;
    this.state[5] = 2600822924;
    this.state[6] = 528734635;
    this.state[7] = 1541459225;
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
    return this;
  }
  // Cleans internal buffers and re-initializes hash state.
  clean() {
    for (let i3 = 0; i3 < this.buffer.length; i3++) {
      this.buffer[i3] = 0;
    }
    for (let i3 = 0; i3 < this.temp.length; i3++) {
      this.temp[i3] = 0;
    }
    this.reset();
  }
  // Updates hash state with the given data.
  //
  // Optionally, length of the data can be specified to hash
  // fewer bytes than data.length.
  //
  // Throws error when trying to update already finalized hash:
  // instance must be reset to use it again.
  update(data, dataLength = data.length) {
    if (this.finished) {
      throw new Error("SHA256: can't update because hash was finished.");
    }
    let dataPos = 0;
    this.bytesHashed += dataLength;
    if (this.bufferLength > 0) {
      while (this.bufferLength < 64 && dataLength > 0) {
        this.buffer[this.bufferLength++] = data[dataPos++];
        dataLength--;
      }
      if (this.bufferLength === 64) {
        hashBlocks(this.temp, this.state, this.buffer, 0, 64);
        this.bufferLength = 0;
      }
    }
    if (dataLength >= 64) {
      dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
      dataLength %= 64;
    }
    while (dataLength > 0) {
      this.buffer[this.bufferLength++] = data[dataPos++];
      dataLength--;
    }
    return this;
  }
  // Finalizes hash state and puts hash into out.
  //
  // If hash was already finalized, puts the same value.
  finish(out) {
    if (!this.finished) {
      const bytesHashed = this.bytesHashed;
      const left2 = this.bufferLength;
      const bitLenHi = bytesHashed / 536870912 | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;
      this.buffer[left2] = 128;
      for (let i3 = left2 + 1; i3 < padLength - 8; i3++) {
        this.buffer[i3] = 0;
      }
      this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
      this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
      this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
      this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
      this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
      this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
      this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
      this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
      hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
      this.finished = true;
    }
    for (let i3 = 0; i3 < 8; i3++) {
      out[i3 * 4 + 0] = this.state[i3] >>> 24 & 255;
      out[i3 * 4 + 1] = this.state[i3] >>> 16 & 255;
      out[i3 * 4 + 2] = this.state[i3] >>> 8 & 255;
      out[i3 * 4 + 3] = this.state[i3] >>> 0 & 255;
    }
    return this;
  }
  // Returns the final hash digest.
  digest() {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
  // Internal function for use in HMAC for optimization.
  _saveState(out) {
    for (let i3 = 0; i3 < this.state.length; i3++) {
      out[i3] = this.state[i3];
    }
  }
  // Internal function for use in HMAC for optimization.
  _restoreState(from, bytesHashed) {
    for (let i3 = 0; i3 < this.state.length; i3++) {
      this.state[i3] = from[i3];
    }
    this.bytesHashed = bytesHashed;
    this.finished = false;
    this.bufferLength = 0;
  }
};
function sha256(data) {
  const h3 = new HashSha256().update(data);
  const digest = h3.digest();
  h3.clean();
  return digest;
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/kdf.js
function sha512(data) {
  return hash(data);
}
function hmac(digest, blockSize2, key, message) {
  if (key.byteLength > blockSize2) {
    key = digest(key);
  }
  if (key.byteLength < blockSize2) {
    const k5 = key;
    key = new Uint8Array(blockSize2);
    key.set(k5, 0);
  }
  const okp = new Uint8Array(blockSize2);
  const ikp = new Uint8Array(blockSize2);
  for (let i3 = 0; i3 < blockSize2; i3++) {
    ikp[i3] = key[i3] ^ 54;
    okp[i3] = key[i3] ^ 92;
  }
  const b1 = new Uint8Array(blockSize2 + message.byteLength);
  b1.set(ikp, 0);
  b1.set(message, blockSize2);
  const h0 = digest(b1);
  const b22 = new Uint8Array(blockSize2 + h0.length);
  b22.set(okp, 0);
  b22.set(h0, blockSize2);
  return digest(b22);
}
function hmacSha512(key, message) {
  return hmac(sha512, 128, key, message);
}
function hmacSha256(key, message) {
  return hmac(sha256, 64, key, message);
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-exchange.js
var DenominationPubKey;
(function(DenominationPubKey2) {
  function cmp(p1, p22) {
    if (p1.cipher < p22.cipher) {
      return -1;
    } else if (p1.cipher > p22.cipher) {
      return 1;
    } else if (p1.cipher === DenomKeyType.Rsa && p22.cipher === DenomKeyType.Rsa) {
      if ((p1.age_mask ?? 0) < (p22.age_mask ?? 0)) {
        return -1;
      } else if ((p1.age_mask ?? 0) > (p22.age_mask ?? 0)) {
        return 1;
      }
      return strcmp(p1.rsa_public_key, p22.rsa_public_key);
    } else if (p1.cipher === DenomKeyType.ClauseSchnorr && p22.cipher === DenomKeyType.ClauseSchnorr) {
      if ((p1.age_mask ?? 0) < (p22.age_mask ?? 0)) {
        return -1;
      } else if ((p1.age_mask ?? 0) > (p22.age_mask ?? 0)) {
        return 1;
      }
      return strcmp(p1.cs_public_key, p22.cs_public_key);
    } else {
      throw Error("unsupported cipher");
    }
  }
  DenominationPubKey2.cmp = cmp;
})(DenominationPubKey || (DenominationPubKey = {}));
var codecForNgDenominations = codecForAny();
var DenomKeyType;
(function(DenomKeyType2) {
  DenomKeyType2["Rsa"] = "RSA";
  DenomKeyType2["ClauseSchnorr"] = "CS";
})(DenomKeyType || (DenomKeyType = {}));
(function(DenomKeyType2) {
  function toIntTag(t4) {
    switch (t4) {
      case DenomKeyType2.Rsa:
        return 1;
      case DenomKeyType2.ClauseSchnorr:
        return 2;
    }
  }
  DenomKeyType2.toIntTag = toIntTag;
})(DenomKeyType || (DenomKeyType = {}));
var AmlState;
(function(AmlState2) {
  AmlState2[AmlState2["normal"] = 0] = "normal";
  AmlState2[AmlState2["pending"] = 1] = "pending";
  AmlState2[AmlState2["frozen"] = 2] = "frozen";
})(AmlState || (AmlState = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/taler-crypto.js
function getRandomBytes(n2) {
  return randomBytes(n2);
}
var useNative = true;
var tart;
if (useNative) {
  tart = globalThis._tart;
}
var encTable = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var EncodingError = class _EncodingError extends Error {
  constructor() {
    super("Encoding error");
    Object.setPrototypeOf(this, _EncodingError.prototype);
  }
};
function getValue(chr) {
  let a4 = chr;
  switch (chr) {
    case "O":
    case "o":
      a4 = "0";
      break;
    case "i":
    case "I":
    case "l":
    case "L":
      a4 = "1";
      break;
    case "u":
    case "U":
      a4 = "V";
  }
  if (a4 >= "0" && a4 <= "9") {
    return a4.charCodeAt(0) - "0".charCodeAt(0);
  }
  if (a4 >= "a" && a4 <= "z")
    a4 = a4.toUpperCase();
  let dec = 0;
  if (a4 >= "A" && a4 <= "Z") {
    if ("I" < a4)
      dec++;
    if ("L" < a4)
      dec++;
    if ("O" < a4)
      dec++;
    if ("U" < a4)
      dec++;
    return a4.charCodeAt(0) - "A".charCodeAt(0) + 10 - dec;
  }
  throw new EncodingError();
}
function encodeCrock(data) {
  if (tart) {
    return tart.encodeCrock(data);
  }
  const dataBytes = new Uint8Array(data);
  let sb = "";
  const size = data.byteLength;
  let bitBuf = 0;
  let numBits = 0;
  let pos = 0;
  while (pos < size || numBits > 0) {
    if (pos < size && numBits < 5) {
      const d3 = dataBytes[pos++];
      bitBuf = bitBuf << 8 | d3;
      numBits += 8;
    }
    if (numBits < 5) {
      bitBuf = bitBuf << 5 - numBits;
      numBits = 5;
    }
    const v3 = bitBuf >>> numBits - 5 & 31;
    sb += encTable[v3];
    numBits -= 5;
  }
  return sb;
}
function kdf(outputLength, ikm, salt, info) {
  if (tart) {
    return tart.kdf(outputLength, ikm, salt, info);
  }
  salt = salt ?? new Uint8Array(64);
  const prk = hmacSha512(salt, ikm);
  info = info ?? new Uint8Array(0);
  const N3 = Math.ceil(outputLength / 32);
  const output = new Uint8Array(N3 * 32);
  for (let i3 = 0; i3 < N3; i3++) {
    let buf;
    if (i3 == 0) {
      buf = new Uint8Array(info.byteLength + 1);
      buf.set(info, 0);
    } else {
      buf = new Uint8Array(info.byteLength + 1 + 32);
      for (let j4 = 0; j4 < 32; j4++) {
        buf[j4] = output[(i3 - 1) * 32 + j4];
      }
      buf.set(info, 32);
    }
    buf[buf.length - 1] = i3 + 1;
    const chunk = hmacSha256(prk, buf);
    output.set(chunk, i3 * 32);
  }
  return output.slice(0, outputLength);
}
function kdfKw(args) {
  return kdf(args.outputLength, args.ikm, args.salt, args.info);
}
function decodeCrock(encoded) {
  if (tart) {
    return tart.decodeCrock(encoded);
  }
  const size = encoded.length;
  let bitpos = 0;
  let bitbuf = 0;
  let readPosition = 0;
  const outLen = Math.floor(size * 5 / 8);
  const out = new Uint8Array(outLen);
  let outPos = 0;
  while (readPosition < size || bitpos > 0) {
    if (readPosition < size) {
      const v3 = getValue(encoded[readPosition++]);
      bitbuf = bitbuf << 5 | v3;
      bitpos += 5;
    }
    while (bitpos >= 8) {
      const d3 = bitbuf >>> bitpos - 8 & 255;
      out[outPos++] = d3;
      bitpos -= 8;
    }
    if (readPosition == size && bitpos > 0) {
      bitbuf = bitbuf << 8 - bitpos & 255;
      bitpos = bitbuf == 0 ? 0 : 8;
    }
  }
  return out;
}
var encoder;
function stringToBytes(s4) {
  if (!encoder) {
    encoder = new TextEncoder();
  }
  return encoder.encode(s4);
}
function typedArrayConcat(chunks) {
  let payloadLen = 0;
  for (const c6 of chunks) {
    payloadLen += c6.byteLength;
  }
  const buf = new ArrayBuffer(payloadLen);
  const u8buf = new Uint8Array(buf);
  let p4 = 0;
  for (const c6 of chunks) {
    u8buf.set(c6, p4);
    p4 += c6.byteLength;
  }
  return u8buf;
}
function hash2(d3) {
  if (tart) {
    return tart.hash(d3);
  }
  return hash(d3);
}
var logger7 = new Logger("talerCrypto.ts");
function bufferForUint32(n2) {
  const arrBuf = new ArrayBuffer(4);
  const buf = new Uint8Array(arrBuf);
  const dv = new DataView(arrBuf);
  dv.setUint32(0, n2);
  return buf;
}
var TalerSignaturePurpose;
(function(TalerSignaturePurpose2) {
  TalerSignaturePurpose2[TalerSignaturePurpose2["MERCHANT_TRACK_TRANSACTION"] = 1103] = "MERCHANT_TRACK_TRANSACTION";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_RESERVE_WITHDRAW"] = 1200] = "WALLET_RESERVE_WITHDRAW";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_RESERVE_HISTORY"] = 1208] = "WALLET_RESERVE_HISTORY";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_DEPOSIT"] = 1201] = "WALLET_COIN_DEPOSIT";
  TalerSignaturePurpose2[TalerSignaturePurpose2["GLOBAL_FEES"] = 1022] = "GLOBAL_FEES";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MASTER_DENOMINATION_KEY_VALIDITY"] = 1025] = "MASTER_DENOMINATION_KEY_VALIDITY";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MASTER_WIRE_FEES"] = 1028] = "MASTER_WIRE_FEES";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MASTER_WIRE_DETAILS"] = 1030] = "MASTER_WIRE_DETAILS";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_MELT"] = 1202] = "WALLET_COIN_MELT";
  TalerSignaturePurpose2[TalerSignaturePurpose2["TEST"] = 4242] = "TEST";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MERCHANT_PAYMENT_OK"] = 1104] = "MERCHANT_PAYMENT_OK";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MERCHANT_CONTRACT"] = 1101] = "MERCHANT_CONTRACT";
  TalerSignaturePurpose2[TalerSignaturePurpose2["MERCHANT_REFUND"] = 1102] = "MERCHANT_REFUND";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_RECOUP"] = 1203] = "WALLET_COIN_RECOUP";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_LINK"] = 1204] = "WALLET_COIN_LINK";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_RECOUP_REFRESH"] = 1206] = "WALLET_COIN_RECOUP_REFRESH";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_AGE_ATTESTATION"] = 1207] = "WALLET_AGE_ATTESTATION";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_PURSE_CREATE"] = 1210] = "WALLET_PURSE_CREATE";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_PURSE_DEPOSIT"] = 1211] = "WALLET_PURSE_DEPOSIT";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_PURSE_MERGE"] = 1213] = "WALLET_PURSE_MERGE";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_ACCOUNT_MERGE"] = 1214] = "WALLET_ACCOUNT_MERGE";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_PURSE_ECONTRACT"] = 1216] = "WALLET_PURSE_ECONTRACT";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_PURSE_DELETE"] = 1220] = "WALLET_PURSE_DELETE";
  TalerSignaturePurpose2[TalerSignaturePurpose2["WALLET_COIN_HISTORY"] = 1209] = "WALLET_COIN_HISTORY";
  TalerSignaturePurpose2[TalerSignaturePurpose2["EXCHANGE_CONFIRM_RECOUP"] = 1039] = "EXCHANGE_CONFIRM_RECOUP";
  TalerSignaturePurpose2[TalerSignaturePurpose2["EXCHANGE_CONFIRM_RECOUP_REFRESH"] = 1041] = "EXCHANGE_CONFIRM_RECOUP_REFRESH";
  TalerSignaturePurpose2[TalerSignaturePurpose2["TALER_SIGNATURE_AML_DECISION"] = 1350] = "TALER_SIGNATURE_AML_DECISION";
  TalerSignaturePurpose2[TalerSignaturePurpose2["TALER_SIGNATURE_AML_QUERY"] = 1351] = "TALER_SIGNATURE_AML_QUERY";
  TalerSignaturePurpose2[TalerSignaturePurpose2["TALER_SIGNATURE_MASTER_AML_KEY"] = 1017] = "TALER_SIGNATURE_MASTER_AML_KEY";
  TalerSignaturePurpose2[TalerSignaturePurpose2["ANASTASIS_POLICY_UPLOAD"] = 1400] = "ANASTASIS_POLICY_UPLOAD";
  TalerSignaturePurpose2[TalerSignaturePurpose2["ANASTASIS_POLICY_DOWNLOAD"] = 1401] = "ANASTASIS_POLICY_DOWNLOAD";
  TalerSignaturePurpose2[TalerSignaturePurpose2["SYNC_BACKUP_UPLOAD"] = 1450] = "SYNC_BACKUP_UPLOAD";
})(TalerSignaturePurpose || (TalerSignaturePurpose = {}));
var WalletAccountMergeFlags;
(function(WalletAccountMergeFlags2) {
  WalletAccountMergeFlags2[WalletAccountMergeFlags2["None"] = 0] = "None";
  WalletAccountMergeFlags2[WalletAccountMergeFlags2["MergeFullyPaidPurse"] = 1] = "MergeFullyPaidPurse";
  WalletAccountMergeFlags2[WalletAccountMergeFlags2["CreateFromPurseQuota"] = 2] = "CreateFromPurseQuota";
  WalletAccountMergeFlags2[WalletAccountMergeFlags2["CreateWithPurseFee"] = 3] = "CreateWithPurseFee";
})(WalletAccountMergeFlags || (WalletAccountMergeFlags = {}));
var SignaturePurposeBuilder = class {
  constructor(purposeNum) {
    this.purposeNum = purposeNum;
    this.chunks = [];
  }
  put(bytes) {
    this.chunks.push(Uint8Array.from(bytes));
    return this;
  }
  build() {
    let payloadLen = 0;
    for (const c6 of this.chunks) {
      payloadLen += c6.byteLength;
    }
    const buf = new ArrayBuffer(4 + 4 + payloadLen);
    const u8buf = new Uint8Array(buf);
    let p4 = 8;
    for (const c6 of this.chunks) {
      u8buf.set(c6, p4);
      p4 += c6.byteLength;
    }
    const dvbuf = new DataView(buf);
    dvbuf.setUint32(0, payloadLen + 4 + 4);
    dvbuf.setUint32(4, this.purposeNum);
    return u8buf;
  }
};
function buildSigPS(purposeNum) {
  return new SignaturePurposeBuilder(purposeNum);
}
function bigintToNaclArr(x6, size) {
  const byteArr = new Uint8Array(size);
  const arr = x6.toArray(256).value.reverse();
  byteArr.set(arr, 0);
  return byteArr;
}
function bigintFromNaclArr(arr) {
  let rev = new Uint8Array(arr);
  rev = rev.reverse();
  return import_big_integer.default.fromArray(Array.from(rev), 256, false);
}
var Edx25519;
(function(Edx255192) {
  const revL = [
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ];
  const L4 = import_big_integer.default.fromArray(revL.reverse(), 256, false);
  async function keyCreateFromSeed(seed) {
    return crypto_edx25519_private_key_create_from_seed(seed);
  }
  Edx255192.keyCreateFromSeed = keyCreateFromSeed;
  async function keyCreate() {
    return crypto_edx25519_private_key_create();
  }
  Edx255192.keyCreate = keyCreate;
  async function getPublic(priv) {
    return crypto_edx25519_get_public(priv);
  }
  Edx255192.getPublic = getPublic;
  function sign3(msg, key) {
    throw Error("not implemented");
  }
  Edx255192.sign = sign3;
  async function deriveFactor(pub, seed) {
    const res = kdfKw({
      outputLength: 64,
      salt: seed,
      ikm: pub,
      info: stringToBytes("edx25519-derivation")
    });
    return res;
  }
  async function privateKeyDerive(priv, seed) {
    const pub = await getPublic(priv);
    const privDec = priv;
    const a4 = bigintFromNaclArr(privDec.subarray(0, 32));
    const factorEnc = await deriveFactor(pub, seed);
    const factorModL = bigintFromNaclArr(factorEnc).mod(L4);
    const aPrime = a4.divide(8).multiply(factorModL).mod(L4).multiply(8).mod(L4);
    const bPrime = hash(typedArrayConcat([privDec.subarray(32, 64), factorEnc])).subarray(0, 32);
    const newPriv = typedArrayConcat([bigintToNaclArr(aPrime, 32), bPrime]);
    return newPriv;
  }
  Edx255192.privateKeyDerive = privateKeyDerive;
  async function publicKeyDerive(pub, seed) {
    const factorEnc = await deriveFactor(pub, seed);
    const factorReduced = crypto_core_ed25519_scalar_reduce(factorEnc);
    const res = crypto_scalarmult_ed25519_noclamp(factorReduced, pub);
    return res;
  }
  Edx255192.publicKeyDerive = publicKeyDerive;
})(Edx25519 || (Edx25519 = {}));
function invariant(cond) {
  if (!cond) {
    throw Error("invariant failed");
  }
}
var AgeRestriction;
(function(AgeRestriction2) {
  AgeRestriction2.AGE_UNRESTRICTED = 32;
  function hashCommitment(ac) {
    const hc = new HashState();
    for (const pub of ac.publicKeys) {
      hc.update(decodeCrock(pub));
    }
    return encodeCrock(hc.finish().subarray(0, 32));
  }
  AgeRestriction2.hashCommitment = hashCommitment;
  function countAgeGroups(mask) {
    let count2 = 0;
    let m3 = mask;
    while (m3 > 0) {
      count2 += m3 & 1;
      m3 = m3 >> 1;
    }
    return count2;
  }
  AgeRestriction2.countAgeGroups = countAgeGroups;
  function getAgeGroupsFromMask(mask) {
    const groups2 = [];
    let age = 1;
    let m3 = mask >> 1;
    while (m3 > 0) {
      if (m3 & 1) {
        groups2.push(age);
      }
      m3 = m3 >> 1;
      age++;
    }
    return groups2;
  }
  AgeRestriction2.getAgeGroupsFromMask = getAgeGroupsFromMask;
  function getAgeGroupIndex(mask, age) {
    invariant((mask & 1) === 1);
    let i3 = 0;
    let m3 = mask;
    let a4 = age;
    while (m3 > 0) {
      if (a4 <= 0) {
        break;
      }
      m3 = m3 >> 1;
      i3 += m3 & 1;
      a4--;
    }
    return i3;
  }
  AgeRestriction2.getAgeGroupIndex = getAgeGroupIndex;
  function ageGroupSpecToMask(ageGroupSpec) {
    throw Error("not implemented");
  }
  AgeRestriction2.ageGroupSpecToMask = ageGroupSpecToMask;
  async function restrictionCommit(ageMask, age) {
    invariant((ageMask & 1) === 1);
    const numPubs = countAgeGroups(ageMask) - 1;
    const numPrivs = getAgeGroupIndex(ageMask, age);
    const pubs = [];
    const privs = [];
    for (let i3 = 0; i3 < numPubs; i3++) {
      const priv = await Edx25519.keyCreate();
      const pub = await Edx25519.getPublic(priv);
      pubs.push(pub);
      if (i3 < numPrivs) {
        privs.push(priv);
      }
    }
    return {
      commitment: {
        mask: ageMask,
        publicKeys: pubs.map((x6) => encodeCrock(x6))
      },
      proof: {
        privateKeys: privs.map((x6) => encodeCrock(x6))
      }
    };
  }
  AgeRestriction2.restrictionCommit = restrictionCommit;
  const PublishedAgeRestrictionBaseKey = decodeCrock("CH0VKFDZ2GWRWHQBBGEK9MWV5YDQVJ0RXEE0KYT3NMB69F0R96TG");
  async function restrictionCommitSeeded(ageMask, age, seed) {
    invariant((ageMask & 1) === 1);
    const numPubs = countAgeGroups(ageMask) - 1;
    const numPrivs = getAgeGroupIndex(ageMask, age);
    const pubs = [];
    const privs = [];
    for (let i3 = 0; i3 < numPrivs; i3++) {
      const privSeed = await kdfKw({
        outputLength: 32,
        ikm: seed,
        info: stringToBytes("age-commitment"),
        salt: bufferForUint32(i3)
      });
      const priv = await Edx25519.keyCreateFromSeed(privSeed);
      const pub = await Edx25519.getPublic(priv);
      pubs.push(pub);
      privs.push(priv);
    }
    for (let i3 = numPrivs; i3 < numPubs; i3++) {
      const deriveSeed = await kdfKw({
        outputLength: 32,
        ikm: seed,
        info: stringToBytes("age-factor"),
        salt: bufferForUint32(i3)
      });
      const pub = await Edx25519.publicKeyDerive(PublishedAgeRestrictionBaseKey, deriveSeed);
      pubs.push(pub);
    }
    return {
      commitment: {
        mask: ageMask,
        publicKeys: pubs.map((x6) => encodeCrock(x6))
      },
      proof: {
        privateKeys: privs.map((x6) => encodeCrock(x6))
      }
    };
  }
  AgeRestriction2.restrictionCommitSeeded = restrictionCommitSeeded;
  async function commitCompare(c1, c22, salt) {
    if (c1.publicKeys.length != c22.publicKeys.length) {
      return false;
    }
    for (let i3 = 0; i3 < c1.publicKeys.length; i3++) {
      const k1 = decodeCrock(c1.publicKeys[i3]);
      const k22 = await Edx25519.publicKeyDerive(decodeCrock(c22.publicKeys[i3]), salt);
      if (k1 != k22) {
        return false;
      }
    }
    return true;
  }
  AgeRestriction2.commitCompare = commitCompare;
  async function commitmentDerive(commitmentProof, salt) {
    const newPrivs = [];
    const newPubs = [];
    for (const oldPub of commitmentProof.commitment.publicKeys) {
      newPubs.push(await Edx25519.publicKeyDerive(decodeCrock(oldPub), salt));
    }
    for (const oldPriv of commitmentProof.proof.privateKeys) {
      newPrivs.push(await Edx25519.privateKeyDerive(decodeCrock(oldPriv), salt));
    }
    return {
      commitment: {
        mask: commitmentProof.commitment.mask,
        publicKeys: newPubs.map((x6) => encodeCrock(x6))
      },
      proof: {
        privateKeys: newPrivs.map((x6) => encodeCrock(x6))
      }
    };
  }
  AgeRestriction2.commitmentDerive = commitmentDerive;
  function commitmentAttest(commitmentProof, age) {
    const d3 = buildSigPS(TalerSignaturePurpose.WALLET_AGE_ATTESTATION).put(bufferForUint32(commitmentProof.commitment.mask)).put(bufferForUint32(age)).build();
    const group2 = getAgeGroupIndex(commitmentProof.commitment.mask, age);
    if (group2 === 0) {
      return new Uint8Array(64);
    }
    const priv = commitmentProof.proof.privateKeys[group2 - 1];
    const pub = commitmentProof.commitment.publicKeys[group2 - 1];
    const sig = crypto_edx25519_sign_detached(d3, decodeCrock(priv), decodeCrock(pub));
    return sig;
  }
  AgeRestriction2.commitmentAttest = commitmentAttest;
  function commitmentVerify(commitment, sig, age) {
    const d3 = buildSigPS(TalerSignaturePurpose.WALLET_AGE_ATTESTATION).put(bufferForUint32(commitment.mask)).put(bufferForUint32(age)).build();
    const group2 = getAgeGroupIndex(commitment.mask, age);
    if (group2 === 0) {
      return true;
    }
    const pub = commitment.publicKeys[group2 - 1];
    return crypto_edx25519_sign_detached_verify(d3, decodeCrock(sig), decodeCrock(pub));
  }
  AgeRestriction2.commitmentVerify = commitmentVerify;
})(AgeRestriction || (AgeRestriction = {}));
var ContractFormatTag;
(function(ContractFormatTag2) {
  ContractFormatTag2[ContractFormatTag2["PaymentOffer"] = 0] = "PaymentOffer";
  ContractFormatTag2[ContractFormatTag2["PaymentRequest"] = 1] = "PaymentRequest";
})(ContractFormatTag || (ContractFormatTag = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/contract-terms.js
var logger8 = new Logger("contractTerms.ts");
var ContractTermsUtil;
(function(ContractTermsUtil2) {
  function forgetAllImpl(anyJson, path2, pred) {
    const dup = JSON.parse(JSON.stringify(anyJson));
    if (Array.isArray(dup)) {
      for (let i3 = 0; i3 < dup.length; i3++) {
        dup[i3] = forgetAllImpl(dup[i3], [...path2, `${i3}`], pred);
      }
    } else if (typeof dup === "object" && dup != null) {
      if (typeof dup.$forgettable === "object") {
        for (const x6 of Object.keys(dup.$forgettable)) {
          if (!pred([...path2, x6])) {
            continue;
          }
          if (!dup.$forgotten) {
            dup.$forgotten = {};
          }
          if (!dup.$forgotten[x6]) {
            const membValCanon = stringToBytes(canonicalJson(scrub(dup[x6])) + "\0");
            const membSalt = stringToBytes(dup.$forgettable[x6] + "\0");
            const h3 = kdf(64, membValCanon, membSalt, new Uint8Array([]));
            dup.$forgotten[x6] = encodeCrock(h3);
          }
          delete dup[x6];
          delete dup.$forgettable[x6];
        }
        if (Object.keys(dup.$forgettable).length === 0) {
          delete dup.$forgettable;
        }
      }
      for (const x6 of Object.keys(dup)) {
        if (x6.startsWith("$")) {
          continue;
        }
        dup[x6] = forgetAllImpl(dup[x6], [...path2, x6], pred);
      }
    }
    return dup;
  }
  ContractTermsUtil2.forgetAllImpl = forgetAllImpl;
  function scrub(anyJson) {
    return forgetAllImpl(anyJson, [], () => true);
  }
  ContractTermsUtil2.scrub = scrub;
  function forgetAll(anyJson, pred) {
    return forgetAllImpl(anyJson, [], pred);
  }
  ContractTermsUtil2.forgetAll = forgetAll;
  function saltForgettable(anyJson) {
    const dup = JSON.parse(JSON.stringify(anyJson));
    if (Array.isArray(dup)) {
      for (let i3 = 0; i3 < dup.length; i3++) {
        dup[i3] = saltForgettable(dup[i3]);
      }
    } else if (typeof dup === "object" && dup !== null) {
      if (typeof dup.$forgettable === "object") {
        for (const k5 of Object.keys(dup.$forgettable)) {
          if (dup.$forgettable[k5] === true) {
            dup.$forgettable[k5] = encodeCrock(getRandomBytes(32));
          }
        }
      }
      for (const x6 of Object.keys(dup)) {
        if (x6.startsWith("$")) {
          continue;
        }
        dup[x6] = saltForgettable(dup[x6]);
      }
    }
    return dup;
  }
  ContractTermsUtil2.saltForgettable = saltForgettable;
  const nameRegex = /^[0-9A-Za-z_]+$/;
  function validateForgettable(anyJson) {
    if (typeof anyJson === "string") {
      return true;
    }
    if (typeof anyJson === "number") {
      return Number.isInteger(anyJson) && anyJson >= Number.MIN_SAFE_INTEGER && anyJson <= Number.MAX_SAFE_INTEGER;
    }
    if (typeof anyJson === "boolean") {
      return true;
    }
    if (anyJson === null) {
      return true;
    }
    if (Array.isArray(anyJson)) {
      return anyJson.every((x6) => validateForgettable(x6));
    }
    if (typeof anyJson === "object") {
      for (const k5 of Object.keys(anyJson)) {
        if (k5.match(nameRegex)) {
          if (validateForgettable(anyJson[k5])) {
            continue;
          } else {
            return false;
          }
        }
        if (k5 === "$forgettable") {
          const fga = anyJson.$forgettable;
          if (!fga || typeof fga !== "object") {
            return false;
          }
          for (const fk of Object.keys(fga)) {
            if (!fk.match(nameRegex)) {
              return false;
            }
            if (!(fk in anyJson)) {
              return false;
            }
            const fv = anyJson.$forgettable[fk];
            if (typeof fv !== "string") {
              return false;
            }
          }
        } else if (k5 === "$forgotten") {
          const fgo = anyJson.$forgotten;
          if (!fgo || typeof fgo !== "object") {
            return false;
          }
          for (const fk of Object.keys(fgo)) {
            if (!fk.match(nameRegex)) {
              return false;
            }
            if (fk in anyJson) {
              return false;
            }
            const fv = anyJson.$forgotten[fk];
            if (typeof fv !== "string") {
              return false;
            }
            try {
              const decFv = decodeCrock(fv);
              if (decFv.length != 64) {
                return false;
              }
            } catch (e3) {
              return false;
            }
            if (anyJson.$forgettable?.[k5] !== void 0) {
              return false;
            }
          }
        } else {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  ContractTermsUtil2.validateForgettable = validateForgettable;
  function validateNothingForgotten(contractTerms) {
    throw Error("not implemented yet");
  }
  ContractTermsUtil2.validateNothingForgotten = validateNothingForgotten;
  function hashContractTerms(contractTerms) {
    const cleaned = scrub(contractTerms);
    const canon = canonicalJson(cleaned) + "\0";
    const bytes = stringToBytes(canon);
    return encodeCrock(hash2(bytes));
  }
  ContractTermsUtil2.hashContractTerms = hashContractTerms;
})(ContractTermsUtil || (ContractTermsUtil = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/errors.js
function makeErrorDetail(code, detail, hint) {
  if (!hint && !detail.hint) {
    hint = getDefaultTalerErrorHint(code);
  }
  const when = AbsoluteTime.now();
  return { code, when, hint, ...detail };
}
function getDefaultTalerErrorHint(code) {
  const errName = TalerErrorCode[code];
  if (errName) {
    return `Error (${errName})`;
  } else {
    return `Error (<unknown>)`;
  }
}
var TalerError = class _TalerError extends Error {
  constructor(d3, cause) {
    super(d3.hint ?? `Error (code ${d3.code})`);
    this.errorDetail = d3;
    this.cause = cause;
    Object.setPrototypeOf(this, _TalerError.prototype);
  }
  static fromDetail(code, detail, hint, cause) {
    if (!hint) {
      hint = getDefaultTalerErrorHint(code);
    }
    const when = AbsoluteTime.now();
    return new _TalerError({ code, when, hint, ...detail }, cause);
  }
  static fromUncheckedDetail(d3, c6) {
    return new _TalerError({ ...d3 }, c6);
  }
  static fromException(e3) {
    const errDetail = getErrorDetailFromException(e3);
    return new _TalerError(errDetail, e3);
  }
  hasErrorCode(code) {
    return this.errorDetail.code === code;
  }
  toString() {
    return `TalerError: ${JSON.stringify(this.errorDetail)}`;
  }
};
function getErrorDetailFromException(e3) {
  if (e3 instanceof TalerError) {
    return e3.errorDetail;
  }
  if (e3 instanceof CancellationToken.CancellationError) {
    const err2 = makeErrorDetail(TalerErrorCode.WALLET_CORE_REQUEST_CANCELLED, {});
    return err2;
  }
  if (e3 instanceof Error) {
    const err2 = makeErrorDetail(TalerErrorCode.WALLET_UNEXPECTED_EXCEPTION, {
      stack: e3.stack
    }, `unexpected exception (message: ${e3.message})`);
    return err2;
  }
  let excString;
  try {
    excString = e3.toString();
  } catch (e4) {
    excString = "can't stringify exception";
  }
  const err = makeErrorDetail(TalerErrorCode.WALLET_UNEXPECTED_EXCEPTION, {}, `unexpected exception (not an exception, ${excString})`);
  return err;
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/fnutils.js
var fnutil;
(function(fnutil2) {
  function all(arr, f3) {
    for (const x6 of arr) {
      if (!f3(x6)) {
        return false;
      }
    }
    return true;
  }
  fnutil2.all = all;
  function any(arr, f3) {
    for (const x6 of arr) {
      if (f3(x6)) {
        return true;
      }
    }
    return false;
  }
  fnutil2.any = any;
})(fnutil || (fnutil = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/utils.js
function addLongPollingParam(url, param) {
  if (!param)
    return;
  if (param.timeoutMs) {
    url.searchParams.set("long_poll_ms", String(param.timeoutMs));
  }
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/payto.js
function codecForPaytoString() {
  return {
    decode(x6, c6) {
      if (typeof x6 !== "string") {
        throw new DecodingError(`expected string at ${renderContext(c6)} but got ${typeof x6}`);
      }
      if (!x6.startsWith(paytoPfx)) {
        throw new DecodingError(`expected start with payto at ${renderContext(c6)} but got "${x6}"`);
      }
      return x6;
    }
  };
}
var paytoPfx = "payto://";

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-wallet-transactions.js
var TransactionMajorState;
(function(TransactionMajorState2) {
  TransactionMajorState2["None"] = "none";
  TransactionMajorState2["Pending"] = "pending";
  TransactionMajorState2["Done"] = "done";
  TransactionMajorState2["Aborting"] = "aborting";
  TransactionMajorState2["Aborted"] = "aborted";
  TransactionMajorState2["Dialog"] = "dialog";
  TransactionMajorState2["Finalizing"] = "finalizing";
  TransactionMajorState2["Suspended"] = "suspended";
  TransactionMajorState2["SuspendedFinalizing"] = "suspended-finalizing";
  TransactionMajorState2["SuspendedAborting"] = "suspended-aborting";
  TransactionMajorState2["Failed"] = "failed";
  TransactionMajorState2["Expired"] = "expired";
  TransactionMajorState2["Deleted"] = "deleted";
})(TransactionMajorState || (TransactionMajorState = {}));
var TransactionMinorState;
(function(TransactionMinorState2) {
  TransactionMinorState2["Unknown"] = "unknown";
  TransactionMinorState2["Deposit"] = "deposit";
  TransactionMinorState2["KycRequired"] = "kyc";
  TransactionMinorState2["AmlRequired"] = "aml";
  TransactionMinorState2["MergeKycRequired"] = "merge-kyc";
  TransactionMinorState2["Track"] = "track";
  TransactionMinorState2["SubmitPayment"] = "submit-payment";
  TransactionMinorState2["RebindSession"] = "rebind-session";
  TransactionMinorState2["Refresh"] = "refresh";
  TransactionMinorState2["Pickup"] = "pickup";
  TransactionMinorState2["AutoRefund"] = "auto-refund";
  TransactionMinorState2["User"] = "user";
  TransactionMinorState2["Bank"] = "bank";
  TransactionMinorState2["Exchange"] = "exchange";
  TransactionMinorState2["ClaimProposal"] = "claim-proposal";
  TransactionMinorState2["CheckRefund"] = "check-refund";
  TransactionMinorState2["CreatePurse"] = "create-purse";
  TransactionMinorState2["DeletePurse"] = "delete-purse";
  TransactionMinorState2["RefreshExpired"] = "refresh-expired";
  TransactionMinorState2["Ready"] = "ready";
  TransactionMinorState2["Merge"] = "merge";
  TransactionMinorState2["Repurchase"] = "repurchase";
  TransactionMinorState2["BankRegisterReserve"] = "bank-register-reserve";
  TransactionMinorState2["BankConfirmTransfer"] = "bank-confirm-transfer";
  TransactionMinorState2["WithdrawCoins"] = "withdraw-coins";
  TransactionMinorState2["ExchangeWaitReserve"] = "exchange-wait-reserve";
  TransactionMinorState2["AbortingBank"] = "aborting-bank";
  TransactionMinorState2["Aborting"] = "aborting";
  TransactionMinorState2["Refused"] = "refused";
  TransactionMinorState2["Withdraw"] = "withdraw";
  TransactionMinorState2["MerchantOrderProposed"] = "merchant-order-proposed";
  TransactionMinorState2["Proposed"] = "proposed";
  TransactionMinorState2["RefundAvailable"] = "refund-available";
  TransactionMinorState2["AcceptRefund"] = "accept-refund";
  TransactionMinorState2["PaidByOther"] = "paid-by-other";
  TransactionMinorState2["CompletedByOtherWallet"] = "completed-by-other-wallet";
})(TransactionMinorState || (TransactionMinorState = {}));
var TransactionAction;
(function(TransactionAction2) {
  TransactionAction2["Delete"] = "delete";
  TransactionAction2["Suspend"] = "suspend";
  TransactionAction2["Resume"] = "resume";
  TransactionAction2["Abort"] = "abort";
  TransactionAction2["Fail"] = "fail";
  TransactionAction2["Retry"] = "retry";
})(TransactionAction || (TransactionAction = {}));
var TransactionType;
(function(TransactionType2) {
  TransactionType2["Withdrawal"] = "withdrawal";
  TransactionType2["InternalWithdrawal"] = "internal-withdrawal";
  TransactionType2["Payment"] = "payment";
  TransactionType2["Refund"] = "refund";
  TransactionType2["Refresh"] = "refresh";
  TransactionType2["Deposit"] = "deposit";
  TransactionType2["PeerPushDebit"] = "peer-push-debit";
  TransactionType2["PeerPushCredit"] = "peer-push-credit";
  TransactionType2["PeerPullDebit"] = "peer-pull-debit";
  TransactionType2["PeerPullCredit"] = "peer-pull-credit";
  TransactionType2["Recoup"] = "recoup";
  TransactionType2["DenomLoss"] = "denom-loss";
})(TransactionType || (TransactionType = {}));
var WithdrawalType;
(function(WithdrawalType2) {
  WithdrawalType2["TalerBankIntegrationApi"] = "taler-bank-integration-api";
  WithdrawalType2["ManualTransfer"] = "manual-transfer";
})(WithdrawalType || (WithdrawalType = {}));
var DenomLossEventType;
(function(DenomLossEventType2) {
  DenomLossEventType2["DenomExpired"] = "denom-expired";
  DenomLossEventType2["DenomVanished"] = "denom-vanished";
  DenomLossEventType2["DenomUnoffered"] = "denom-unoffered";
})(DenomLossEventType || (DenomLossEventType = {}));
var PaymentStatus;
(function(PaymentStatus2) {
  PaymentStatus2["Aborted"] = "aborted";
  PaymentStatus2["Failed"] = "failed";
  PaymentStatus2["Paid"] = "paid";
  PaymentStatus2["Accepted"] = "accepted";
})(PaymentStatus || (PaymentStatus = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-wallet.js
var TransactionAmountMode;
(function(TransactionAmountMode2) {
  TransactionAmountMode2["Effective"] = "effective";
  TransactionAmountMode2["Raw"] = "raw";
})(TransactionAmountMode || (TransactionAmountMode = {}));
var codecForConvertAmountRequest = buildCodecForObject().property("amount", codecForAmountString()).property("depositPaytoUri", codecForPaytoString()).property("type", codecForEither(codecForConstString(TransactionAmountMode.Raw), codecForConstString(TransactionAmountMode.Effective))).build("ConvertAmountRequest");
var codecForGetAmountRequest = buildCodecForObject().property("currency", codecForString()).build("GetAmountRequest");
var codecForGetPlanForWalletInitiatedOperation = () => buildCodecForObject().property("mode", codecForEither(codecForConstString(TransactionAmountMode.Raw), codecForConstString(TransactionAmountMode.Effective))).property("instructedAmount", codecForAmountString());
var codecForGetPlanForWithdrawRequest = codecForGetPlanForWalletInitiatedOperation().property("type", codecForConstString(TransactionType.Withdrawal)).property("exchangeUrl", codecOptional(codecForString())).build("GetPlanForWithdrawRequest");
var codecForGetPlanForDepositRequest = codecForGetPlanForWalletInitiatedOperation().property("type", codecForConstString(TransactionType.Deposit)).property("account", codecForString()).build("GetPlanForDepositRequest");
var codecForGetPlanForPushDebitRequest = codecForGetPlanForWalletInitiatedOperation().property("type", codecForConstString(TransactionType.PeerPushDebit)).build("GetPlanForPushDebitRequest");
var codecForGetPlanForPullCreditRequest = codecForGetPlanForWalletInitiatedOperation().property("type", codecForConstString(TransactionType.PeerPullCredit)).property("exchangeUrl", codecForString()).build("GetPlanForPullCreditRequest");
var codecForGetPlanForPaymentRequest = buildCodecForObject().property("type", codecForConstString(TransactionType.Payment)).property("maxDepositFee", codecForAmountString()).build("GetPlanForPaymentRequest");
var codecForGetPlanForPullDebitRequest = buildCodecForObject().property("type", codecForConstString(TransactionType.PeerPullDebit)).build("GetPlanForPullDebitRequest");
var codecForGetPlanForPushCreditRequest = buildCodecForObject().property("type", codecForConstString(TransactionType.PeerPushCredit)).build("GetPlanForPushCreditRequest");
var BalanceFlag;
(function(BalanceFlag2) {
  BalanceFlag2["IncomingKyc"] = "incoming-kyc";
  BalanceFlag2["IncomingAml"] = "incoming-aml";
  BalanceFlag2["IncomingConfirmation"] = "incoming-confirmation";
  BalanceFlag2["OutgoingKyc"] = "outgoing-kyc";
})(BalanceFlag || (BalanceFlag = {}));
var ScopeType;
(function(ScopeType2) {
  ScopeType2["Global"] = "global";
  ScopeType2["Exchange"] = "exchange";
  ScopeType2["Auditor"] = "auditor";
})(ScopeType || (ScopeType = {}));
var CoinStatus;
(function(CoinStatus2) {
  CoinStatus2["Fresh"] = "fresh";
  CoinStatus2["DenomLoss"] = "denom-loss";
  CoinStatus2["FreshSuspended"] = "fresh-suspended";
  CoinStatus2["Dormant"] = "dormant";
})(CoinStatus || (CoinStatus = {}));
var ConfirmPayResultType;
(function(ConfirmPayResultType2) {
  ConfirmPayResultType2["Done"] = "done";
  ConfirmPayResultType2["Pending"] = "pending";
})(ConfirmPayResultType || (ConfirmPayResultType = {}));
var codecForTalerErrorDetail = () => buildCodecForObject().property("code", codecForNumber()).property("when", codecOptional(codecForAbsoluteTime)).property("hint", codecOptional(codecForString())).build("TalerErrorDetail");
var PreparePayResultType;
(function(PreparePayResultType2) {
  PreparePayResultType2["PaymentPossible"] = "payment-possible";
  PreparePayResultType2["InsufficientBalance"] = "insufficient-balance";
  PreparePayResultType2["AlreadyConfirmed"] = "already-confirmed";
})(PreparePayResultType || (PreparePayResultType = {}));
var RefreshReason;
(function(RefreshReason2) {
  RefreshReason2["Manual"] = "manual";
  RefreshReason2["PayMerchant"] = "pay-merchant";
  RefreshReason2["PayDeposit"] = "pay-deposit";
  RefreshReason2["PayPeerPush"] = "pay-peer-push";
  RefreshReason2["PayPeerPull"] = "pay-peer-pull";
  RefreshReason2["Refund"] = "refund";
  RefreshReason2["AbortPay"] = "abort-pay";
  RefreshReason2["AbortDeposit"] = "abort-deposit";
  RefreshReason2["AbortPeerPushDebit"] = "abort-peer-push-debit";
  RefreshReason2["AbortPeerPullDebit"] = "abort-peer-pull-debit";
  RefreshReason2["Recoup"] = "recoup";
  RefreshReason2["BackupRestored"] = "backup-restored";
  RefreshReason2["Scheduled"] = "scheduled";
})(RefreshReason || (RefreshReason = {}));
var ExchangeTosStatus;
(function(ExchangeTosStatus2) {
  ExchangeTosStatus2["Pending"] = "pending";
  ExchangeTosStatus2["Proposed"] = "proposed";
  ExchangeTosStatus2["Accepted"] = "accepted";
  ExchangeTosStatus2["MissingTos"] = "missing-tos";
})(ExchangeTosStatus || (ExchangeTosStatus = {}));
var ExchangeEntryStatus;
(function(ExchangeEntryStatus2) {
  ExchangeEntryStatus2["Preset"] = "preset";
  ExchangeEntryStatus2["Ephemeral"] = "ephemeral";
  ExchangeEntryStatus2["Used"] = "used";
})(ExchangeEntryStatus || (ExchangeEntryStatus = {}));
var ExchangeUpdateStatus;
(function(ExchangeUpdateStatus2) {
  ExchangeUpdateStatus2["Initial"] = "initial";
  ExchangeUpdateStatus2["InitialUpdate"] = "initial-update";
  ExchangeUpdateStatus2["Suspended"] = "suspended";
  ExchangeUpdateStatus2["UnavailableUpdate"] = "unavailable-update";
  ExchangeUpdateStatus2["Ready"] = "ready";
  ExchangeUpdateStatus2["ReadyUpdate"] = "ready-update";
  ExchangeUpdateStatus2["OutdatedUpdate"] = "outdated-update";
})(ExchangeUpdateStatus || (ExchangeUpdateStatus = {}));
var RecoveryMergeStrategy;
(function(RecoveryMergeStrategy2) {
  RecoveryMergeStrategy2["Ours"] = "ours";
  RecoveryMergeStrategy2["Theirs"] = "theirs";
})(RecoveryMergeStrategy || (RecoveryMergeStrategy = {}));
var AttentionPriority;
(function(AttentionPriority2) {
  AttentionPriority2["High"] = "high";
  AttentionPriority2["Medium"] = "medium";
  AttentionPriority2["Low"] = "low";
})(AttentionPriority || (AttentionPriority = {}));
var AttentionType;
(function(AttentionType2) {
  AttentionType2["KycWithdrawal"] = "kyc-withdrawal";
  AttentionType2["BackupUnpaid"] = "backup-unpaid";
  AttentionType2["BackupExpiresSoon"] = "backup-expires-soon";
  AttentionType2["MerchantRefund"] = "merchant-refund";
  AttentionType2["ExchangeTosChanged"] = "exchange-tos-changed";
  AttentionType2["ExchangeKeyExpired"] = "exchange-key-expired";
  AttentionType2["ExchangeKeyExpiresSoon"] = "exchange-key-expires-soon";
  AttentionType2["ExchangeDenominationsExpired"] = "exchange-denominations-expired";
  AttentionType2["ExchangeDenominationsExpiresSoon"] = "exchange-denominations-expires-soon";
  AttentionType2["AuditorTosChanged"] = "auditor-tos-changed";
  AttentionType2["AuditorKeyExpires"] = "auditor-key-expires";
  AttentionType2["AuditorDenominationsExpires"] = "auditor-denominations-expires";
  AttentionType2["PullPaymentPaid"] = "pull-payment-paid";
  AttentionType2["PushPaymentReceived"] = "push-payment-withdrawn";
})(AttentionType || (AttentionType = {}));
var UserAttentionPriority = {
  "kyc-withdrawal": AttentionPriority.Medium,
  "backup-unpaid": AttentionPriority.High,
  "backup-expires-soon": AttentionPriority.Medium,
  "merchant-refund": AttentionPriority.Medium,
  "exchange-tos-changed": AttentionPriority.Medium,
  "exchange-key-expired": AttentionPriority.High,
  "exchange-key-expires-soon": AttentionPriority.Medium,
  "exchange-denominations-expired": AttentionPriority.High,
  "exchange-denominations-expires-soon": AttentionPriority.Medium,
  "auditor-tos-changed": AttentionPriority.Medium,
  "auditor-key-expires": AttentionPriority.Medium,
  "auditor-denominations-expires": AttentionPriority.Medium,
  "pull-payment-paid": AttentionPriority.High,
  "push-payment-withdrawn": AttentionPriority.High
};
var ProviderPaymentType;
(function(ProviderPaymentType2) {
  ProviderPaymentType2["Unpaid"] = "unpaid";
  ProviderPaymentType2["Pending"] = "pending";
  ProviderPaymentType2["InsufficientBalance"] = "insufficient-balance";
  ProviderPaymentType2["Paid"] = "paid";
  ProviderPaymentType2["TermsChanged"] = "terms-changed";
})(ProviderPaymentType || (ProviderPaymentType = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/bank-conversion.js
var TalerBankConversionCacheEviction;
(function(TalerBankConversionCacheEviction2) {
  TalerBankConversionCacheEviction2[TalerBankConversionCacheEviction2["UPDATE_RATE"] = 0] = "UPDATE_RATE";
})(TalerBankConversionCacheEviction || (TalerBankConversionCacheEviction = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-corebank.js
var MonitorTimeframeParam;
(function(MonitorTimeframeParam2) {
  MonitorTimeframeParam2[MonitorTimeframeParam2["hour"] = 0] = "hour";
  MonitorTimeframeParam2[MonitorTimeframeParam2["day"] = 1] = "day";
  MonitorTimeframeParam2[MonitorTimeframeParam2["month"] = 2] = "month";
  MonitorTimeframeParam2[MonitorTimeframeParam2["year"] = 3] = "year";
  MonitorTimeframeParam2[MonitorTimeframeParam2["decade"] = 4] = "decade";
})(MonitorTimeframeParam || (MonitorTimeframeParam = {}));
var TanChannel;
(function(TanChannel2) {
  TanChannel2["SMS"] = "sms";
  TanChannel2["EMAIL"] = "email";
})(TanChannel || (TanChannel = {}));
var codecForIntegrationBankConfig = () => buildCodecForObject().property("name", codecForConstString("taler-bank-integration")).property("version", codecForString()).property("currency", codecForString()).property("currency_specification", codecForCurrencySpecificiation()).build("TalerCorebankApi.IntegrationConfig");

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/bank-core.js
var TalerCoreBankCacheEviction;
(function(TalerCoreBankCacheEviction2) {
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["DELETE_ACCOUNT"] = 0] = "DELETE_ACCOUNT";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["CREATE_ACCOUNT"] = 1] = "CREATE_ACCOUNT";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["UPDATE_ACCOUNT"] = 2] = "UPDATE_ACCOUNT";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["UPDATE_PASSWORD"] = 3] = "UPDATE_PASSWORD";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["CREATE_TRANSACTION"] = 4] = "CREATE_TRANSACTION";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["CONFIRM_WITHDRAWAL"] = 5] = "CONFIRM_WITHDRAWAL";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["ABORT_WITHDRAWAL"] = 6] = "ABORT_WITHDRAWAL";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["CREATE_WITHDRAWAL"] = 7] = "CREATE_WITHDRAWAL";
  TalerCoreBankCacheEviction2[TalerCoreBankCacheEviction2["CREATE_CASHOUT"] = 8] = "CREATE_CASHOUT";
})(TalerCoreBankCacheEviction || (TalerCoreBankCacheEviction = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/types-taler-bank-integration.js
var codecForBankWithdrawalOperationStatus = () => buildCodecForObject().property("status", codecForEither(codecForConstString("pending"), codecForConstString("selected"), codecForConstString("aborted"), codecForConstString("confirmed"))).property("amount", codecOptional(codecForAmountString())).property("currency", codecOptional(codecForCurrencyName())).property("suggested_amount", codecOptional(codecForAmountString())).property("card_fees", codecOptional(codecForAmountString())).property("sender_wire", codecOptional(codecForPaytoString())).property("suggested_exchange", codecOptional(codecForURLString())).property("confirm_transfer_url", codecOptional(codecForURLString())).property("wire_types", codecForList(codecForString())).property("selected_reserve_pub", codecOptional(codecForString())).property("selected_exchange_account", codecOptional(codecForString())).property("max_amount", codecOptional(codecForAmountString())).build("TalerBankIntegrationApi.BankWithdrawalOperationStatus");
var codecForBankWithdrawalOperationPostResponse = () => buildCodecForObject().property("status", codecForEither(codecForConstString("selected"), codecForConstString("aborted"), codecForConstString("confirmed"))).property("confirm_transfer_url", codecOptional(codecForURLString())).build("TalerBankIntegrationApi.BankWithdrawalOperationPostResponse");

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/bank-integration.js
var logger9 = new Logger("bank-integration.ts");
var TalerBankIntegrationHttpClient = class _TalerBankIntegrationHttpClient {
  constructor(baseUrl, httpClient) {
    this.baseUrl = baseUrl;
    this.PROTOCOL_VERSION = _TalerBankIntegrationHttpClient.PROTOCOL_VERSION;
    this.httpLib = httpClient ?? createPlatformHttpLib();
  }
  isCompatible(version) {
    const compare2 = LibtoolVersion.compare(this.PROTOCOL_VERSION, version);
    return compare2?.compatible ?? false;
  }
  /**
   * https://docs.taler.net/core/api-bank-integration.html#get--config
   *
   */
  async getConfig() {
    const url = new URL(`config`, this.baseUrl);
    const resp = await this.httpLib.fetch(url.href, {
      method: "GET"
    });
    switch (resp.status) {
      case HttpStatusCode.Ok:
        return opSuccessFromHttp(resp, codecForIntegrationBankConfig());
      default:
        logger9.warn(`config request failed, status ${resp.status}`);
        return opUnknownFailure(resp, await readTalerErrorResponse(resp));
    }
  }
  /**
   * https://docs.taler.net/core/api-bank-integration.html#get--withdrawal-operation-$WITHDRAWAL_ID
   *
   */
  async getWithdrawalOperationById(woid, params) {
    const url = new URL(`withdrawal-operation/${woid}`, this.baseUrl);
    addLongPollingParam(url, params);
    if (params) {
      url.searchParams.set("old_state", !params.old_state ? "pending" : params.old_state);
    }
    const resp = await this.httpLib.fetch(url.href, {
      method: "GET"
    });
    switch (resp.status) {
      case HttpStatusCode.Ok:
        return opSuccessFromHttp(resp, codecForBankWithdrawalOperationStatus());
      case HttpStatusCode.NotFound:
        return opKnownHttpFailure(resp.status, resp);
      default:
        return opUnknownFailure(resp, await readTalerErrorResponse(resp));
    }
  }
  /**
   * https://docs.taler.net/core/api-bank-integration.html#post-$BANK_API_BASE_URL-withdrawal-operation-$wopid
   *
   */
  async completeWithdrawalOperationById(woid, body) {
    const url = new URL(`withdrawal-operation/${woid}`, this.baseUrl);
    const resp = await this.httpLib.fetch(url.href, {
      method: "POST",
      body
    });
    switch (resp.status) {
      case HttpStatusCode.Ok:
        return opSuccessFromHttp(resp, codecForBankWithdrawalOperationPostResponse());
      case HttpStatusCode.NotFound:
        return opKnownHttpFailure(resp.status, resp);
      case HttpStatusCode.Conflict: {
        const body2 = await readTalerErrorResponse(resp);
        const details = codecForTalerErrorDetail().decode(body2);
        switch (details.code) {
          case TalerErrorCode.BANK_WITHDRAWAL_OPERATION_RESERVE_SELECTION_CONFLICT:
            return opKnownTalerFailure(details.code, details);
          case TalerErrorCode.BANK_DUPLICATE_RESERVE_PUB_SUBJECT:
            return opKnownTalerFailure(details.code, details);
          case TalerErrorCode.BANK_UNKNOWN_ACCOUNT:
            return opKnownTalerFailure(details.code, details);
          case TalerErrorCode.BANK_ACCOUNT_IS_NOT_EXCHANGE:
            return opKnownTalerFailure(details.code, details);
          case TalerErrorCode.BANK_AMOUNT_DIFFERS:
            return opKnownTalerFailure(details.code, details);
          case TalerErrorCode.BANK_AMOUNT_REQUIRED:
            return opKnownTalerFailure(details.code, details);
          default:
            return opUnknownFailure(resp, details);
        }
      }
      default:
        return opUnknownFailure(resp, await readTalerErrorResponse(resp));
    }
  }
  /**
   * https://docs.taler.net/core/api-bank-integration.html#post-$BANK_API_BASE_URL-withdrawal-operation-$wopid
   *
   */
  async abortWithdrawalOperationById(woid) {
    const url = new URL(`withdrawal-operation/${woid}/abort`, this.baseUrl);
    const resp = await this.httpLib.fetch(url.href, {
      method: "POST"
    });
    switch (resp.status) {
      case HttpStatusCode.NoContent:
        return opEmptySuccess(resp);
      case HttpStatusCode.NotFound:
        return opKnownHttpFailure(resp.status, resp);
      case HttpStatusCode.Conflict:
        return opKnownHttpFailure(resp.status, resp);
      default:
        return opUnknownFailure(resp, await readTalerErrorResponse(resp));
    }
  }
};
TalerBankIntegrationHttpClient.PROTOCOL_VERSION = "2:0:1";

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/challenger.js
var ChallengerCacheEviction;
(function(ChallengerCacheEviction2) {
  ChallengerCacheEviction2[ChallengerCacheEviction2["CREATE_CHALLENGE"] = 0] = "CREATE_CHALLENGE";
  ChallengerCacheEviction2[ChallengerCacheEviction2["SOLVE_CHALLENGE"] = 1] = "SOLVE_CHALLENGE";
})(ChallengerCacheEviction || (ChallengerCacheEviction = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/exchange.js
var TalerExchangeCacheEviction;
(function(TalerExchangeCacheEviction2) {
  TalerExchangeCacheEviction2[TalerExchangeCacheEviction2["CREATE_DESCISION"] = 0] = "CREATE_DESCISION";
})(TalerExchangeCacheEviction || (TalerExchangeCacheEviction = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/http-client/merchant.js
var TalerMerchantInstanceCacheEviction;
(function(TalerMerchantInstanceCacheEviction2) {
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_ORDER"] = 0] = "CREATE_ORDER";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_ORDER"] = 1] = "UPDATE_ORDER";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_ORDER"] = 2] = "DELETE_ORDER";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_CURRENT_INSTANCE"] = 3] = "UPDATE_CURRENT_INSTANCE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_CURRENT_INSTANCE"] = 4] = "DELETE_CURRENT_INSTANCE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_BANK_ACCOUNT"] = 5] = "CREATE_BANK_ACCOUNT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_BANK_ACCOUNT"] = 6] = "UPDATE_BANK_ACCOUNT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_BANK_ACCOUNT"] = 7] = "DELETE_BANK_ACCOUNT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_PRODUCT"] = 8] = "CREATE_PRODUCT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_PRODUCT"] = 9] = "UPDATE_PRODUCT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_PRODUCT"] = 10] = "DELETE_PRODUCT";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_TRANSFER"] = 11] = "CREATE_TRANSFER";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_TRANSFER"] = 12] = "DELETE_TRANSFER";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_DEVICE"] = 13] = "CREATE_DEVICE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_DEVICE"] = 14] = "UPDATE_DEVICE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_DEVICE"] = 15] = "DELETE_DEVICE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_TEMPLATE"] = 16] = "CREATE_TEMPLATE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_TEMPLATE"] = 17] = "UPDATE_TEMPLATE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_TEMPLATE"] = 18] = "DELETE_TEMPLATE";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_WEBHOOK"] = 19] = "CREATE_WEBHOOK";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_WEBHOOK"] = 20] = "UPDATE_WEBHOOK";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_WEBHOOK"] = 21] = "DELETE_WEBHOOK";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["CREATE_TOKENFAMILY"] = 22] = "CREATE_TOKENFAMILY";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["UPDATE_TOKENFAMILY"] = 23] = "UPDATE_TOKENFAMILY";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["DELETE_TOKENFAMILY"] = 24] = "DELETE_TOKENFAMILY";
  TalerMerchantInstanceCacheEviction2[TalerMerchantInstanceCacheEviction2["LAST"] = 25] = "LAST";
})(TalerMerchantInstanceCacheEviction || (TalerMerchantInstanceCacheEviction = {}));
var TalerMerchantManagementCacheEviction;
(function(TalerMerchantManagementCacheEviction2) {
  TalerMerchantManagementCacheEviction2[TalerMerchantManagementCacheEviction2["CREATE_INSTANCE"] = 26] = "CREATE_INSTANCE";
  TalerMerchantManagementCacheEviction2[TalerMerchantManagementCacheEviction2["UPDATE_INSTANCE"] = 27] = "UPDATE_INSTANCE";
  TalerMerchantManagementCacheEviction2[TalerMerchantManagementCacheEviction2["DELETE_INSTANCE"] = 28] = "DELETE_INSTANCE";
})(TalerMerchantManagementCacheEviction || (TalerMerchantManagementCacheEviction = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/i18n.js
var jedLib = __toESM(require_jed(), 1);
var logger10 = new Logger("i18n/index.ts");
var jed = void 0;
function setupI18n(lang, strings2) {
  lang = lang.replace("_", "-");
  if (!strings2[lang]) {
    strings2[lang] = {};
  }
  jed = new jedLib.Jed(strings2[lang]);
}
function toI18nString(stringSeq) {
  let s4 = "";
  for (let i3 = 0; i3 < stringSeq.length; i3++) {
    s4 += stringSeq[i3];
    if (i3 < stringSeq.length - 1) {
      s4 += `%${i3 + 1}$s`;
    }
  }
  return s4;
}
function singular(stringSeq, ...values2) {
  const s4 = toI18nString(stringSeq);
  const tr = jed.translate(s4).ifPlural(1, s4).fetch(...values2);
  return tr;
}
function translate(stringSeq, ...values2) {
  const s4 = toI18nString(stringSeq);
  if (!s4)
    return [];
  const translation = jed.ngettext(s4, s4, 1);
  return replacePlaceholderWithValues(translation, values2);
}
function Translate({ children: children2, debug }) {
  const c6 = [].concat(children2);
  const s4 = stringifyArray(c6);
  if (!s4)
    return [];
  const translation = jed.ngettext(s4, s4, 1);
  if (debug) {
    console.log("looking for ", s4, "got", translation);
  }
  return replacePlaceholderWithValues(translation, c6);
}
function replacePlaceholderWithValues(translation, childArray) {
  const tr = translation.split(/%(\d+)\$s/);
  const placeholderChildren = [];
  for (let i3 = 0; i3 < childArray.length; i3++) {
    const x6 = childArray[i3];
    if (x6 === void 0) {
      continue;
    } else if (typeof x6 === "string") {
      continue;
    } else {
      placeholderChildren.push(x6);
    }
  }
  const result = [];
  for (let i3 = 0; i3 < tr.length; i3++) {
    if (i3 % 2 == 0) {
      result.push(tr[i3]);
    } else {
      const childIdx = Number.parseInt(tr[i3]) - 1;
      result.push(placeholderChildren[childIdx]);
    }
  }
  return result;
}
function stringifyArray(children2) {
  let n2 = 1;
  const ss = children2.map((c6) => {
    if (typeof c6 === "string") {
      return c6;
    }
    return `%${n2++}$s`;
  });
  const s4 = ss.join("").replace(/ +/g, " ").trim();
  return s4;
}
var i18n = {
  str: singular,
  singular,
  Translate,
  translate
};

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/iban.js
var ccZero = "0".charCodeAt(0);
var ccNine = "9".charCodeAt(0);
var ccA = "A".charCodeAt(0);
var ccZ = "Z".charCodeAt(0);

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/notifications.js
var NotificationType;
(function(NotificationType2) {
  NotificationType2["BalanceChange"] = "balance-change";
  NotificationType2["BackupOperationError"] = "backup-error";
  NotificationType2["TransactionStateTransition"] = "transaction-state-transition";
  NotificationType2["WithdrawalOperationTransition"] = "withdrawal-operation-transition";
  NotificationType2["ExchangeStateTransition"] = "exchange-state-transition";
  NotificationType2["Idle"] = "idle";
  NotificationType2["TaskObservabilityEvent"] = "task-observability-event";
  NotificationType2["RequestObservabilityEvent"] = "request-observability-event";
})(NotificationType || (NotificationType = {}));
var ObservabilityEventType;
(function(ObservabilityEventType2) {
  ObservabilityEventType2["HttpFetchStart"] = "http-fetch-start";
  ObservabilityEventType2["HttpFetchFinishError"] = "http-fetch-finish-error";
  ObservabilityEventType2["HttpFetchFinishSuccess"] = "http-fetch-finish-success";
  ObservabilityEventType2["DbQueryStart"] = "db-query-start";
  ObservabilityEventType2["DbQueryFinishSuccess"] = "db-query-finish-success";
  ObservabilityEventType2["DbQueryFinishError"] = "db-query-finish-error";
  ObservabilityEventType2["RequestStart"] = "request-start";
  ObservabilityEventType2["RequestFinishSuccess"] = "request-finish-success";
  ObservabilityEventType2["RequestFinishError"] = "request-finish-error";
  ObservabilityEventType2["TaskStart"] = "task-start";
  ObservabilityEventType2["TaskStop"] = "task-stop";
  ObservabilityEventType2["TaskReset"] = "task-reset";
  ObservabilityEventType2["ShepherdTaskResult"] = "shepherd-task-result";
  ObservabilityEventType2["DeclareTaskDependency"] = "declare-task-dependency";
  ObservabilityEventType2["CryptoStart"] = "crypto-start";
  ObservabilityEventType2["CryptoFinishSuccess"] = "crypto-finish-success";
  ObservabilityEventType2["CryptoFinishError"] = "crypto-finish-error";
  ObservabilityEventType2["Message"] = "message";
  ObservabilityEventType2["DeclareConcernsTransaction"] = "declare-concerns-transaction";
})(ObservabilityEventType || (ObservabilityEventType = {}));

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/taleruri.js
function parseWithdrawUriWithError(s4) {
  const pi5 = parseProtoInfoWithError(s4, "withdraw");
  if (pi5.type === "fail") {
    return pi5;
  }
  const c6 = pi5.body.rest.split("?", 2);
  const path2 = c6[0];
  const q4 = new URLSearchParams2(c6[1] ?? "");
  const parts = path2.split("/");
  if (parts.length < 2) {
    return opKnownTalerFailure(TalerErrorCode.WALLET_TALER_URI_MALFORMED, {
      code: TalerErrorCode.WALLET_TALER_URI_MALFORMED
    });
  }
  const host = parts[0].toLowerCase();
  const pathSegments = parts.slice(1, parts.length - 1);
  const withdrawId = parts[parts.length - 1];
  const p4 = [host, ...pathSegments].join("/");
  const result = {
    type: TalerUriAction.Withdraw,
    bankIntegrationApiBaseUrl: canonicalizeBaseUrl(`${pi5.body.innerProto}://${p4}/`),
    withdrawalOperationId: withdrawId,
    externalConfirmation: q4.get("external-confirmation") == "1"
  };
  return opFixedSuccess(result);
}
function parseWithdrawUri(s4) {
  const r3 = parseWithdrawUriWithError(s4);
  if (r3.type === "fail")
    return void 0;
  return r3.body;
}
function parseAddExchangeUriWithError(s4) {
  const pi5 = parseProtoInfoWithError(s4, "add-exchange");
  if (pi5.type === "fail") {
    return pi5;
  }
  const parts = pi5.body.rest.split("/");
  if (parts.length < 2) {
    return opKnownTalerFailure(TalerErrorCode.WALLET_TALER_URI_MALFORMED, {
      code: TalerErrorCode.WALLET_TALER_URI_MALFORMED
    });
  }
  const host = parts[0].toLowerCase();
  const pathSegments = parts.slice(1, parts.length - 1);
  const p4 = [host, ...pathSegments].join("/");
  const result = {
    type: TalerUriAction.AddExchange,
    exchangeBaseUrl: canonicalizeBaseUrl(`${pi5.body.innerProto}://${p4}/`)
  };
  return opFixedSuccess(result);
}
function parseAddExchangeUri(s4) {
  const r3 = parseAddExchangeUriWithError(s4);
  if (r3.type === "fail")
    return void 0;
  return r3.body;
}
var TalerUriType;
(function(TalerUriType2) {
  TalerUriType2["TalerPay"] = "taler-pay";
  TalerUriType2["TalerTemplate"] = "taler-template";
  TalerUriType2["TalerPayTemplate"] = "taler-pay-template";
  TalerUriType2["TalerWithdraw"] = "taler-withdraw";
  TalerUriType2["TalerTip"] = "taler-tip";
  TalerUriType2["TalerRefund"] = "taler-refund";
  TalerUriType2["TalerPayPush"] = "taler-pay-push";
  TalerUriType2["TalerPayPull"] = "taler-pay-pull";
  TalerUriType2["TalerRecovery"] = "taler-recovery";
  TalerUriType2["TalerDevExperiment"] = "taler-dev-experiment";
  TalerUriType2["Unknown"] = "unknown";
})(TalerUriType || (TalerUriType = {}));
var TalerUriAction;
(function(TalerUriAction2) {
  TalerUriAction2["Pay"] = "pay";
  TalerUriAction2["Withdraw"] = "withdraw";
  TalerUriAction2["Refund"] = "refund";
  TalerUriAction2["PayPull"] = "pay-pull";
  TalerUriAction2["PayPush"] = "pay-push";
  TalerUriAction2["PayTemplate"] = "pay-template";
  TalerUriAction2["Restore"] = "restore";
  TalerUriAction2["DevExperiment"] = "dev-experiment";
  TalerUriAction2["WithdrawExchange"] = "withdraw-exchange";
  TalerUriAction2["AddExchange"] = "add-exchange";
})(TalerUriAction || (TalerUriAction = {}));
function parseProtoInfo(s4, action) {
  const pfxPlain = `taler://${action}/`;
  const pfxHttp = `taler+http://${action}/`;
  if (s4.toLowerCase().startsWith(pfxPlain)) {
    return {
      innerProto: "https",
      rest: s4.substring(pfxPlain.length)
    };
  } else if (s4.toLowerCase().startsWith(pfxHttp)) {
    return {
      innerProto: "http",
      rest: s4.substring(pfxHttp.length)
    };
  } else {
    return void 0;
  }
}
function parseProtoInfoWithError(s4, action) {
  if (!s4.toLowerCase().startsWith("taler://") && !s4.toLowerCase().startsWith("taler+http://")) {
    return opKnownTalerFailure(TalerErrorCode.WALLET_TALER_URI_MALFORMED, {
      code: TalerErrorCode.WALLET_TALER_URI_MALFORMED
    });
  }
  const pfxPlain = `taler://${action}/`;
  const pfxHttp = `taler+http://${action}/`;
  if (s4.toLowerCase().startsWith(pfxPlain)) {
    return opFixedSuccess({
      innerProto: "https",
      rest: s4.substring(pfxPlain.length)
    });
  } else if (s4.toLowerCase().startsWith(pfxHttp)) {
    return opFixedSuccess({
      innerProto: "http",
      rest: s4.substring(pfxHttp.length)
    });
  } else {
    return opKnownTalerFailure(TalerErrorCode.WALLET_TALER_URI_MALFORMED, {
      code: TalerErrorCode.WALLET_TALER_URI_MALFORMED
    });
  }
}
var parsers = {
  [TalerUriAction.Pay]: parsePayUri,
  [TalerUriAction.PayPull]: parsePayPullUri,
  [TalerUriAction.PayPush]: parsePayPushUri,
  [TalerUriAction.PayTemplate]: parsePayTemplateUri,
  [TalerUriAction.Restore]: parseRestoreUri,
  [TalerUriAction.Refund]: parseRefundUri,
  [TalerUriAction.Withdraw]: parseWithdrawUri,
  [TalerUriAction.DevExperiment]: parseDevExperimentUri,
  [TalerUriAction.WithdrawExchange]: parseWithdrawExchangeUri,
  [TalerUriAction.AddExchange]: parseAddExchangeUri
};
function stringifyTalerUri(uri) {
  switch (uri.type) {
    case TalerUriAction.DevExperiment: {
      return stringifyDevExperimentUri(uri);
    }
    case TalerUriAction.Pay: {
      return stringifyPayUri(uri);
    }
    case TalerUriAction.PayPull: {
      return stringifyPayPullUri(uri);
    }
    case TalerUriAction.PayPush: {
      return stringifyPayPushUri(uri);
    }
    case TalerUriAction.PayTemplate: {
      return stringifyPayTemplateUri(uri);
    }
    case TalerUriAction.Restore: {
      return stringifyRestoreUri(uri);
    }
    case TalerUriAction.Refund: {
      return stringifyRefundUri(uri);
    }
    case TalerUriAction.Withdraw: {
      return stringifyWithdrawUri(uri);
    }
    case TalerUriAction.WithdrawExchange: {
      return stringifyWithdrawExchange(uri);
    }
    case TalerUriAction.AddExchange: {
      return stringifyAddExchange(uri);
    }
  }
}
function parsePayUri(s4) {
  const pi5 = parseProtoInfo(s4, "pay");
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5?.rest.split("?");
  const q4 = new URLSearchParams2(c6[1] ?? "");
  const claimToken = q4.get("c") ?? void 0;
  const noncePriv = q4.get("n") ?? void 0;
  const parts = c6[0].split("/");
  if (parts.length < 3) {
    return void 0;
  }
  const host = parts[0].toLowerCase();
  const sessionId = parts[parts.length - 1];
  const orderId = parts[parts.length - 2];
  const pathSegments = parts.slice(1, parts.length - 2);
  const p4 = [host, ...pathSegments].join("/");
  const merchantBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${p4}/`);
  return {
    type: TalerUriAction.Pay,
    merchantBaseUrl,
    orderId,
    sessionId,
    claimToken,
    noncePriv
  };
}
function parsePayTemplateUri(uriString) {
  const pi5 = parseProtoInfo(uriString, TalerUriAction.PayTemplate);
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 2) {
    return void 0;
  }
  const q4 = new URLSearchParams2(c6[1] ?? "");
  const params = {};
  q4.forEach((v3, k5) => {
    params[k5] = v3;
  });
  const host = parts[0].toLowerCase();
  const templateId = parts[parts.length - 1];
  const pathSegments = parts.slice(1, parts.length - 1);
  const hostAndSegments = [host, ...pathSegments].join("/");
  const merchantBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${hostAndSegments}/`);
  return {
    type: TalerUriAction.PayTemplate,
    merchantBaseUrl,
    templateId
  };
}
function parsePayPushUri(s4) {
  const pi5 = parseProtoInfo(s4, TalerUriAction.PayPush);
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5?.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 2) {
    return void 0;
  }
  const host = parts[0].toLowerCase();
  const contractPriv = parts[parts.length - 1];
  const pathSegments = parts.slice(1, parts.length - 1);
  const hostAndSegments = [host, ...pathSegments].join("/");
  const exchangeBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${hostAndSegments}/`);
  return {
    type: TalerUriAction.PayPush,
    exchangeBaseUrl,
    contractPriv
  };
}
function parsePayPullUri(s4) {
  const pi5 = parseProtoInfo(s4, TalerUriAction.PayPull);
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5?.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 2) {
    return void 0;
  }
  const host = parts[0].toLowerCase();
  const contractPriv = parts[parts.length - 1];
  const pathSegments = parts.slice(1, parts.length - 1);
  const hostAndSegments = [host, ...pathSegments].join("/");
  const exchangeBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${hostAndSegments}/`);
  return {
    type: TalerUriAction.PayPull,
    exchangeBaseUrl,
    contractPriv
  };
}
function parseWithdrawExchangeUri(s4) {
  const pi5 = parseProtoInfo(s4, "withdraw-exchange");
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5?.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 1) {
    return void 0;
  }
  const host = parts[0].toLowerCase();
  const lastPathComponent = parts.length > 1 ? parts[parts.length - 1] : void 0;
  if (lastPathComponent) {
    return void 0;
  }
  const pathSegments = parts.slice(1, parts.length - 1);
  const hostAndSegments = [host, ...pathSegments].join("/");
  const exchangeBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${hostAndSegments}/`);
  const q4 = new URLSearchParams2(c6[1] ?? "");
  const amount = q4.get("a") ?? void 0;
  return {
    type: TalerUriAction.WithdrawExchange,
    exchangeBaseUrl,
    amount
  };
}
function parseRefundUri(s4) {
  const pi5 = parseProtoInfo(s4, "refund");
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5?.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 3) {
    return void 0;
  }
  const host = parts[0].toLowerCase();
  const sessionId = parts[parts.length - 1];
  const orderId = parts[parts.length - 2];
  const pathSegments = parts.slice(1, parts.length - 2);
  const hostAndSegments = [host, ...pathSegments].join("/");
  const merchantBaseUrl = canonicalizeBaseUrl(`${pi5.innerProto}://${hostAndSegments}/`);
  return {
    type: TalerUriAction.Refund,
    merchantBaseUrl,
    orderId
  };
}
function parseDevExperimentUri(s4) {
  const pi5 = parseProtoInfo(s4, "dev-experiment");
  const c6 = pi5?.rest.split("?");
  if (!c6) {
    return void 0;
  }
  const parts = c6[0].split("/");
  return {
    type: TalerUriAction.DevExperiment,
    devExperimentId: parts[0]
  };
}
function parseRestoreUri(uri) {
  const pi5 = parseProtoInfo(uri, "restore");
  if (!pi5) {
    return void 0;
  }
  const c6 = pi5.rest.split("?");
  const parts = c6[0].split("/");
  if (parts.length < 2) {
    return void 0;
  }
  const walletRootPriv = parts[0];
  if (!walletRootPriv)
    return void 0;
  const providers = new Array();
  parts[1].split(",").map((name) => {
    const url = canonicalizeBaseUrl(`${pi5.innerProto}://${decodeURIComponent(name)}/`);
    providers.push(url);
  });
  return {
    type: TalerUriAction.Restore,
    walletRootPriv,
    providers
  };
}
function stringifyPayUri({ merchantBaseUrl, orderId, sessionId, claimToken, noncePriv }) {
  const { proto, path: path2, query } = getUrlInfo(merchantBaseUrl, {
    c: claimToken,
    n: noncePriv
  });
  return `${proto}://pay/${path2}${orderId}/${sessionId}${query}`;
}
function stringifyPayPullUri({ contractPriv, exchangeBaseUrl }) {
  const { proto, path: path2 } = getUrlInfo(exchangeBaseUrl);
  return `${proto}://pay-pull/${path2}${contractPriv}`;
}
function stringifyPayPushUri({ contractPriv, exchangeBaseUrl }) {
  const { proto, path: path2 } = getUrlInfo(exchangeBaseUrl);
  return `${proto}://pay-push/${path2}${contractPriv}`;
}
function stringifyRestoreUri({ providers, walletRootPriv }) {
  const list = providers.map((url) => `${encodeURIComponent(new URL2(url).href)}`).join(",");
  return `taler://restore/${walletRootPriv}/${list}`;
}
function stringifyWithdrawExchange({ exchangeBaseUrl, amount }) {
  const { proto, path: path2, query } = getUrlInfo(exchangeBaseUrl, {
    a: amount
  });
  return `${proto}://withdraw-exchange/${path2}${query}`;
}
function stringifyAddExchange({ exchangeBaseUrl }) {
  const { proto, path: path2 } = getUrlInfo(exchangeBaseUrl);
  return `${proto}://add-exchange/${path2}`;
}
function stringifyDevExperimentUri({ devExperimentId }) {
  return `taler://dev-experiment/${devExperimentId}`;
}
function stringifyPayTemplateUri({ merchantBaseUrl, templateId }) {
  const { proto, path: path2, query } = getUrlInfo(merchantBaseUrl);
  return `${proto}://pay-template/${path2}${templateId}${query}`;
}
function stringifyRefundUri({ merchantBaseUrl, orderId }) {
  const { proto, path: path2 } = getUrlInfo(merchantBaseUrl);
  return `${proto}://refund/${path2}${orderId}/`;
}
function stringifyWithdrawUri({ bankIntegrationApiBaseUrl, withdrawalOperationId }) {
  const { proto, path: path2 } = getUrlInfo(bankIntegrationApiBaseUrl);
  return `${proto}://withdraw/${path2}${withdrawalOperationId}`;
}
function getUrlInfo(baseUrl, params = {}) {
  const url = new URL2(baseUrl);
  let proto;
  if (url.protocol === "https:") {
    proto = "taler";
  } else if (url.protocol === "http:") {
    proto = "taler+http";
  } else {
    throw Error(`Unsupported URL protocol in ${baseUrl}`);
  }
  let path2 = url.hostname;
  if (url.port) {
    path2 = path2 + ":" + url.port;
  }
  if (url.pathname) {
    path2 = path2 + url.pathname;
  }
  if (!path2.endsWith("/")) {
    path2 = path2 + "/";
  }
  const qp = new URLSearchParams2();
  let withParams = false;
  Object.entries(params).forEach(([name, value]) => {
    if (value !== void 0) {
      withParams = true;
      qp.append(name, value);
    }
  });
  const query = withParams ? "?" + qp.toString() : "";
  return { proto, path: path2, query };
}

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/timer.js
var logger11 = new Logger("timer.ts");
var IntervalHandle = class {
  constructor(h3) {
    this.h = h3;
  }
  clear() {
    clearInterval(this.h);
  }
  /**
   * Make sure the event loop exits when the timer is the
   * only event left.  Has no effect in the browser.
   */
  unref() {
    if (typeof this.h === "object" && "unref" in this.h) {
      this.h.unref();
    }
  }
};
var TimeoutHandle = class {
  constructor(h3) {
    this.h = h3;
  }
  clear() {
    clearTimeout(this.h);
  }
  /**
   * Make sure the event loop exits when the timer is the
   * only event left.  Has no effect in the browser.
   */
  unref() {
    if (typeof this.h === "object" && "unref" in this.h) {
      this.h.unref();
    }
  }
};
var performanceNow = (() => {
  if (typeof process !== "undefined" && process.hrtime) {
    return () => {
      return process.hrtime.bigint();
    };
  }
  if (typeof performance !== "undefined") {
    return () => BigInt(Math.floor(performance.now() * 1e3)) * BigInt(1e3);
  }
  return () => BigInt((/* @__PURE__ */ new Date()).getTime()) * BigInt(1e3) * BigInt(1e3);
})();
var SetTimeoutTimerAPI = class {
  /**
   * Call a function every time the delay given in milliseconds passes.
   */
  every(delayMs, callback) {
    return new IntervalHandle(setInterval(callback, delayMs));
  }
  /**
   * Call a function after the delay given in milliseconds passes.
   */
  after(delayMs, callback) {
    return new TimeoutHandle(setTimeout(callback, delayMs));
  }
};
var timer = new SetTimeoutTimerAPI();

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/transaction-test-data.js
var sampleWalletCoreTransactions = [
  {
    type: TransactionType.Payment,
    txState: {
      major: TransactionMajorState.Done
    },
    amountRaw: "KUDOS:10",
    amountEffective: "KUDOS:10",
    totalRefundRaw: "KUDOS:0",
    totalRefundEffective: "KUDOS:0",
    status: PaymentStatus.Paid,
    refundPending: void 0,
    posConfirmation: void 0,
    pending: false,
    refunds: [],
    timestamp: {
      t_s: 1677166045
    },
    transactionId: "txn:payment:NRRD9KJ8970P5HDAGPW1MBA6HZHB1XMFKF5M3CNR6WA0GT98DHY0",
    proposalId: "NRRD9KJ8970P5HDAGPW1MBA6HZHB1XMFKF5M3CNR6WA0GT98DHY0",
    info: {
      merchant: {
        name: "woocommerce",
        website: "woocommerce.demo.taler.net",
        email: "foo@example.com",
        address: {},
        jurisdiction: {}
      },
      orderId: "wc_order_KQCRldghIgDRB-100",
      products: [
        {
          description: "Using GCC",
          quantity: 1,
          price: "KUDOS:10",
          product_id: "28"
        }
      ],
      summary: "WooTalerShop #100",
      contractTermsHash: "A02E1M6ARWKBJ87K2TV4S6WQ4X5YH7BRVR6MYCHCTVAED8MBXTFD6PZ5Q50Y7Z5K18PYBTDA14NQ56XPC1VCQW1EVRWTSB7ZYT65B5G",
      fulfillmentUrl: "https://woocommerce.demo.taler.net/?wc-api=wc_gnutaler_gateway&order_id=wc_order_KQCRldghIgDRB-100"
    },
    refundQueryActive: false,
    frozen: false
  },
  {
    type: TransactionType.Refresh,
    txState: {
      major: TransactionMajorState.Pending
    },
    refreshReason: RefreshReason.PayMerchant,
    amountEffective: "KUDOS:0",
    amountRaw: "KUDOS:0",
    refreshInputAmount: "KUDOS:1.5",
    refreshOutputAmount: "KUDOS:1.4",
    originatingTransactionId: "txn:proposal:ZCGBZFE8KZ1CBYYGSC3ZC8E40KVJWV16VYCTHGC8FFSVZ5HD24BG",
    pending: true,
    timestamp: {
      t_s: 1681376214
    },
    transactionId: "txn:refresh:QQSWHHXCRQ269G0E3RW14JMC6F7NFDYDW26NSFHRTXSKDS6CMCZ0",
    frozen: false,
    error: {
      code: 7029,
      when: {
        t_ms: 1681376473665
      },
      hint: "Error (WALLET_REFRESH_GROUP_INCOMPLETE)",
      numErrors: 1,
      errors: [
        {
          code: 7001,
          when: {
            t_ms: 1681376473189
          },
          hint: "unexpected exception (message: exchange wire fee signature invalid)",
          stack: "    at validateWireInfo (../taler-wallet-core-qjs.mjs:23166)\n"
        }
      ]
    }
  }
];

// node_modules/.pnpm/@gnu-taler+taler-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3f_4pvlut4qzkiz5o6nqpyvszyqcu/node_modules/@gnu-taler/taler-util/lib/index.browser.js
loadBrowserPrng();

// node_modules/.pnpm/@gnu-taler+web-util@git+git+++git.taler.net+wallet-core.git+#fc03476a5f129b59006e74bb1afa3fae_pwiiokuw34goucrhclyok6qneu/node_modules/@gnu-taler/web-util/lib/index.browser.mjs
init_hooks_module();
init_hooks_module();
init_hooks_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_compat_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_compat_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_hooks_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_preact_module();
init_hooks_module();
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
function memoryMap(backend = /* @__PURE__ */ new Map()) {
  const obs = new EventTarget();
  const theMemoryMap = {
    onAnyUpdate: (handler) => {
      obs.addEventListener(`update`, handler);
      obs.addEventListener(`clear`, handler);
      return () => {
        obs.removeEventListener(`update`, handler);
        obs.removeEventListener(`clear`, handler);
      };
    },
    onUpdate: (key, handler) => {
      obs.addEventListener(`update-${key}`, handler);
      obs.addEventListener(`clear`, handler);
      return () => {
        obs.removeEventListener(`update-${key}`, handler);
        obs.removeEventListener(`clear`, handler);
      };
    },
    delete: (key) => {
      const result = backend.delete(key);
      theMemoryMap.size = backend.length;
      obs.dispatchEvent(new Event(`update-${key}`));
      obs.dispatchEvent(new Event(`update`));
      return result;
    },
    set: (key, value) => {
      backend.set(key, value);
      theMemoryMap.size = backend.length;
      obs.dispatchEvent(new Event(`update-${key}`));
      obs.dispatchEvent(new Event(`update`));
      return theMemoryMap;
    },
    clear: () => {
      backend.clear();
      obs.dispatchEvent(new Event(`clear`));
    },
    entries: backend.entries.bind(backend),
    forEach: backend.forEach.bind(backend),
    get: backend.get.bind(backend),
    has: backend.has.bind(backend),
    keys: backend.keys.bind(backend),
    size: backend.size,
    values: backend.values.bind(backend),
    [Symbol.iterator]: backend[Symbol.iterator],
    [Symbol.toStringTag]: "theMemoryMap"
  };
  return theMemoryMap;
}
function localStorageMap() {
  const obs = new EventTarget();
  const theLocalStorageMap = {
    onAnyUpdate: (handler) => {
      obs.addEventListener(`update`, handler);
      obs.addEventListener(`clear`, handler);
      window.addEventListener("storage", handler);
      return () => {
        window.removeEventListener("storage", handler);
        obs.removeEventListener(`update`, handler);
        obs.removeEventListener(`clear`, handler);
      };
    },
    onUpdate: (key, handler) => {
      obs.addEventListener(`update-${key}`, handler);
      obs.addEventListener(`clear`, handler);
      function handleStorageEvent(ev) {
        if (ev.key === null || ev.key === key) {
          handler();
        }
      }
      window.addEventListener("storage", handleStorageEvent);
      return () => {
        window.removeEventListener("storage", handleStorageEvent);
        obs.removeEventListener(`update-${key}`, handler);
        obs.removeEventListener(`clear`, handler);
      };
    },
    delete: (key) => {
      const exists = localStorage.getItem(key) !== null;
      localStorage.removeItem(key);
      theLocalStorageMap.size = localStorage.length;
      obs.dispatchEvent(new Event(`update-${key}`));
      obs.dispatchEvent(new Event(`update`));
      return exists;
    },
    set: (key, v3) => {
      localStorage.setItem(key, v3);
      theLocalStorageMap.size = localStorage.length;
      obs.dispatchEvent(new Event(`update-${key}`));
      obs.dispatchEvent(new Event(`update`));
      return theLocalStorageMap;
    },
    clear: () => {
      localStorage.clear();
      obs.dispatchEvent(new Event(`clear`));
    },
    entries: () => {
      let index2 = 0;
      const total = localStorage.length;
      return {
        next() {
          if (index2 === total)
            return { done: true, value: void 0 };
          const key = localStorage.key(index2);
          if (key === null) {
            throw Error("key cant be null");
          }
          const item = localStorage.getItem(key);
          if (item === null) {
            throw Error("value cant be null");
          }
          index2 = index2 + 1;
          return { done: false, value: [key, item] };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    },
    forEach: (cb) => {
      for (let index2 = 0; index2 < localStorage.length; index2++) {
        const key = localStorage.key(index2);
        if (key === null) {
          throw Error("key cant be null");
        }
        const item = localStorage.getItem(key);
        if (item === null) {
          throw Error("value cant be null");
        }
        cb(key, item, theLocalStorageMap);
      }
    },
    get: (key) => {
      const item = localStorage.getItem(key);
      if (item === null)
        return void 0;
      return item;
    },
    has: (key) => {
      return localStorage.getItem(key) === null;
    },
    keys: () => {
      let index2 = 0;
      const total = localStorage.length;
      return {
        next() {
          if (index2 === total)
            return { done: true, value: void 0 };
          const key = localStorage.key(index2);
          if (key === null) {
            throw Error("key cant be null");
          }
          index2 = index2 + 1;
          return { done: false, value: key };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    },
    size: localStorage.length,
    values: () => {
      let index2 = 0;
      const total = localStorage.length;
      return {
        next() {
          if (index2 === total)
            return { done: true, value: void 0 };
          const key = localStorage.key(index2);
          if (key === null) {
            throw Error("key cant be null");
          }
          const item = localStorage.getItem(key);
          if (item === null) {
            throw Error("value cant be null");
          }
          index2 = index2 + 1;
          return { done: false, value: item };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    },
    [Symbol.iterator]: function() {
      return theLocalStorageMap.entries();
    },
    [Symbol.toStringTag]: "theLocalStorageMap"
  };
  return theLocalStorageMap;
}
var isFirefox = typeof window !== "undefined" && typeof window["InstallTrigger"] !== "undefined";
async function getAllContent() {
  if (isFirefox) {
    return browser.storage.local.get();
  } else {
    return chrome.storage.local.get();
  }
}
async function updateContent(obj) {
  if (isFirefox) {
    return browser.storage.local.set(obj);
  } else {
    return chrome.storage.local.set(obj);
  }
}
function onBrowserStorageUpdate(cb) {
  if (isFirefox) {
    browser.storage.local.onChanged.addListener(cb);
  } else {
    chrome.storage.local.onChanged.addListener(cb);
  }
}
function browserStorageMap(backend) {
  getAllContent().then((content) => {
    Object.entries(content ?? {}).forEach(([k22, v3]) => {
      backend.set(k22, v3);
    });
  });
  backend.onAnyUpdate(async () => {
    const result = {};
    for (const [key, value] of backend.entries()) {
      result[key] = value;
    }
    await updateContent(result);
  });
  onBrowserStorageUpdate((changes) => {
    const changedItems = Object.keys(changes);
    if (changedItems.length === 0) {
      backend.clear();
    } else {
      for (const key of changedItems) {
        if (!changes[key].newValue) {
          backend.delete(key);
        } else {
          if (changes[key].newValue !== changes[key].oldValue) {
            backend.set(key, changes[key].newValue);
          }
        }
      }
    }
  });
  return backend;
}
function buildStorageKey(name, codec) {
  return {
    id: name,
    codec: codec ?? codecForString()
  };
}
var supportLocalStorage = typeof window !== "undefined";
var supportBrowserStorage = typeof chrome !== "undefined" && typeof chrome.storage !== "undefined";
var storage = function buildStorage() {
  if (supportBrowserStorage) {
    if (supportLocalStorage) {
      return browserStorageMap(localStorageMap());
    } else {
      return browserStorageMap(memoryMap());
    }
  } else if (supportLocalStorage) {
    return localStorageMap();
  } else {
    return memoryMap();
  }
}();
function useLocalStorage(key, defaultValue) {
  const current = convert(storage.get(key.id), key, defaultValue);
  const [_3, setStoredValue] = p3(AbsoluteTime.now().t_ms);
  h2(() => {
    return storage.onUpdate(key.id, () => {
      setStoredValue(AbsoluteTime.now().t_ms);
    });
  }, [key.id]);
  const setValue = (value) => {
    if (value === void 0) {
      storage.delete(key.id);
    } else {
      storage.set(
        key.id,
        key.codec ? JSON.stringify(value) : value
      );
    }
  };
  return {
    value: current,
    update: setValue,
    reset: () => {
      setValue(defaultValue);
    }
  };
}
function convert(updated, key, defaultValue) {
  if (updated === void 0)
    return defaultValue;
  try {
    return key.codec.decode(JSON.parse(updated));
  } catch (e23) {
    return defaultValue;
  }
}
var MIN_LANG_COVERAGE_THRESHOLD = 90;
function getBrowserLang(completeness) {
  if (typeof window === "undefined")
    return void 0;
  if (window.navigator.language) {
    if (completeness[window.navigator.language] >= MIN_LANG_COVERAGE_THRESHOLD) {
      return window.navigator.language;
    }
  }
  if (window.navigator.languages) {
    const match5 = Object.entries(completeness).filter(([code, value]) => {
      if (value < MIN_LANG_COVERAGE_THRESHOLD)
        return false;
      return window.navigator.languages.findIndex((l3) => l3.startsWith(code)) !== -1;
    }).map(([code, value]) => ({ code, value }));
    if (match5.length > 0) {
      let max3 = match5[0];
      match5.forEach((v3) => {
        if (v3.value > max3.value) {
          max3 = v3;
        }
      });
      return max3.code;
    }
  }
  ;
  return void 0;
}
var langPreferenceKey = buildStorageKey("lang-preference");
function useLang(initial22, completeness) {
  const defaultValue = (getBrowserLang(completeness) || initial22 || "en").substring(0, 2);
  return useLocalStorage(langPreferenceKey, defaultValue);
}
var storage2 = memoryMap();
var storage3 = memoryMap();
var GLOBAL_NOTIFICATION_TIMEOUT = Duration.fromSpec({
  seconds: 5
});
function base64encode(str) {
  return base64EncArr(strToUTF8Arr(str));
}
function uint6ToB64(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function base64EncArr(aBytes) {
  let nMod3 = 2;
  let sB64Enc = "";
  const nLen = aBytes.length;
  let nUint24 = 0;
  for (let nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCodePoint(
        uint6ToB64(nUint24 >>> 18 & 63),
        uint6ToB64(nUint24 >>> 12 & 63),
        uint6ToB64(nUint24 >>> 6 & 63),
        uint6ToB64(nUint24 & 63)
      );
      nUint24 = 0;
    }
  }
  return sB64Enc.substring(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
}
function strToUTF8Arr(sDOMStr) {
  let nChr;
  const nStrLen = sDOMStr.length;
  let nArrLen = 0;
  for (let nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
    nChr = sDOMStr.codePointAt(nMapIdx);
    if (nChr === void 0) {
      throw Error(`No char at ${nMapIdx} on string with length: ${sDOMStr.length}`);
    }
    if (nChr >= 65536) {
      nMapIdx++;
    }
    nArrLen += nChr < 128 ? 1 : nChr < 2048 ? 2 : nChr < 65536 ? 3 : nChr < 2097152 ? 4 : nChr < 67108864 ? 5 : 6;
  }
  const aBytes = new Uint8Array(nArrLen);
  let nIdx = 0;
  let nChrIdx = 0;
  while (nIdx < nArrLen) {
    nChr = sDOMStr.codePointAt(nChrIdx);
    if (nChr === void 0) {
      throw Error(`No char at ${nChrIdx} on string with length: ${sDOMStr.length}`);
    }
    if (nChr < 128) {
      aBytes[nIdx++] = nChr;
    } else if (nChr < 2048) {
      aBytes[nIdx++] = 192 + (nChr >>> 6);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else if (nChr < 65536) {
      aBytes[nIdx++] = 224 + (nChr >>> 12);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
    } else if (nChr < 2097152) {
      aBytes[nIdx++] = 240 + (nChr >>> 18);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
      nChrIdx++;
    } else if (nChr < 67108864) {
      aBytes[nIdx++] = 248 + (nChr >>> 24);
      aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
      nChrIdx++;
    } else {
      aBytes[nIdx++] = 252 + (nChr >>> 30);
      aBytes[nIdx++] = 128 + (nChr >>> 24 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
      aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
      aBytes[nIdx++] = 128 + (nChr & 63);
      nChrIdx++;
    }
    nChrIdx++;
  }
  return aBytes;
}
async function defaultRequestHandler(baseUrl, endpoint, options = {}) {
  const requestHeaders = {};
  if (options.token) {
    requestHeaders.Authorization = `Bearer secret-token:${options.token}`;
  } else if (options.basicAuth) {
    requestHeaders.Authorization = `Basic ${base64encode(
      `${options.basicAuth.username}:${options.basicAuth.password}`
    )}`;
  }
  requestHeaders["Content-Type"] = !options.contentType || options.contentType === "json" ? "application/json" : "text/plain";
  if (options.talerAmlOfficerSignature) {
    requestHeaders["Taler-AML-Officer-Signature"] = options.talerAmlOfficerSignature;
  }
  const requestMethod = options?.method ?? "GET";
  const requestBody = options?.data;
  const requestTimeout = options?.timeout ?? 5 * 1e3;
  const requestParams = options.params ?? {};
  const requestPreventCache = options.preventCache ?? false;
  const requestPreventCors = options.preventCors ?? false;
  const validURL = validateURL(baseUrl, endpoint);
  if (!validURL) {
    const error2 = {
      info: {
        url: `${baseUrl}${endpoint}`,
        payload: {},
        hasToken: !!options.token,
        status: 0,
        options
      },
      type: 4,
      exception: void 0,
      loading: false,
      message: `invalid URL: "${baseUrl}${endpoint}"`
    };
    throw new RequestError(error2);
  }
  Object.entries(requestParams).forEach(([key, value]) => {
    validURL.searchParams.set(key, String(value));
  });
  let payload = void 0;
  if (requestBody != null) {
    if (typeof requestBody === "string") {
      payload = requestBody;
    } else if (requestBody instanceof ArrayBuffer) {
      payload = requestBody;
    } else if (ArrayBuffer.isView(requestBody)) {
      payload = requestBody;
    } else if (typeof requestBody === "object") {
      payload = JSON.stringify(requestBody);
    } else {
      const error2 = {
        info: {
          url: validURL.href,
          payload: {},
          hasToken: !!options.token,
          status: 0,
          options
        },
        type: 4,
        exception: void 0,
        loading: false,
        message: `unsupported request body type: "${typeof requestBody}"`
      };
      throw new RequestError(error2);
    }
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    controller.abort("HTTP_REQUEST_TIMEOUT");
  }, requestTimeout);
  let response;
  try {
    response = await fetch(validURL.href, {
      headers: requestHeaders,
      method: requestMethod,
      credentials: "omit",
      mode: requestPreventCors ? "no-cors" : "cors",
      cache: requestPreventCache ? "no-cache" : "default",
      body: payload,
      signal: controller.signal
    });
  } catch (ex) {
    const info = {
      payload,
      url: validURL.href,
      hasToken: !!options.token,
      status: 0,
      options
    };
    if (ex instanceof Error) {
      if (ex.message === "HTTP_REQUEST_TIMEOUT") {
        const error22 = {
          info,
          type: 3,
          message: "request timeout"
        };
        throw new RequestError(error22);
      }
    }
    const error2 = {
      info,
      type: 4,
      exception: ex,
      loading: false,
      message: ex instanceof Error ? ex.message : ""
    };
    throw new RequestError(error2);
  }
  if (timeoutId) {
    clearTimeout(timeoutId);
  }
  const headerMap = new Headers();
  response.headers.forEach((value, key) => {
    headerMap.set(key, value);
  });
  if (response.ok) {
    const result = await buildRequestOk(
      response,
      validURL.href,
      payload,
      !!options.token,
      options
    );
    return result;
  } else {
    const dataTxt = await response.text();
    const error2 = buildRequestFailed(
      validURL.href,
      dataTxt,
      response.status,
      payload,
      options
    );
    throw new RequestError(error2);
  }
}
var RequestError = class extends Error {
  constructor(d3) {
    super(d3.message);
    this.info = d3;
    this.cause = d3;
  }
};
async function buildRequestOk(response, url, payload, hasToken, options) {
  const dataTxt = await response.text();
  const data = dataTxt ? JSON.parse(dataTxt) : void 0;
  return {
    ok: true,
    data,
    info: {
      payload,
      url,
      hasToken,
      options,
      status: response.status
    }
  };
}
function buildRequestFailed(url, dataTxt, status, payload, maybeOptions) {
  const options = maybeOptions ?? {};
  const info = {
    payload,
    url,
    hasToken: !!options.token,
    options,
    status: status || 0
  };
  try {
    const data = dataTxt ? JSON.parse(dataTxt) : void 0;
    const errorCode = !data || !data.code ? "" : `(code: ${data.code})`;
    const errorHint = !data || !data.hint ? "Not hint." : `${data.hint} ${errorCode}`;
    if (status && status >= 400 && status < 500) {
      const message = data === void 0 ? `Client error (${status}) without data.` : errorHint;
      const error2 = {
        type: 0,
        status,
        info,
        message,
        payload: data
      };
      return error2;
    }
    if (status && status >= 500 && status < 600) {
      const message = data === void 0 ? `Server error (${status}) without data.` : errorHint;
      const error2 = {
        type: 1,
        status,
        info,
        message,
        payload: data
      };
      return error2;
    }
    return {
      info,
      loading: false,
      type: 4,
      status,
      exception: void 0,
      message: `http status code not handled: ${status}`
    };
  } catch (ex) {
    const error2 = {
      info,
      loading: false,
      status,
      type: 2,
      exception: ex,
      body: dataTxt,
      message: "Could not parse body as json"
    };
    return error2;
  }
}
function validateURL(baseUrl, endpoint) {
  try {
    return new URL(`${baseUrl}${endpoint}`);
  } catch (ex) {
    return void 0;
  }
}
var logger12 = new Logger("browserHttpLib");
function urlPattern(pattern, reverse2) {
  const url = reverse2;
  return {
    pattern: new RegExp(pattern),
    url
  };
}
var nullRountDef = {
  pattern: new RegExp(/.*/),
  url: () => ""
};
function findMatch(pagesMap, pageList, path2, params) {
  for (let idx = 0; idx < pageList.length; idx++) {
    const name = pageList[idx];
    const found = pagesMap[name].pattern.exec(path2);
    if (found !== null) {
      const values2 = {};
      if (found.groups !== void 0) {
        Object.entries(found.groups).forEach(([key, value]) => {
          values2[key] = value;
        });
      }
      return { name, parent: pagesMap, values: values2, params };
    }
  }
  return { name: void 0, parent: pagesMap, values: {}, params };
}
var Context = B({ request: defaultRequestHandler });
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format22 = args.formats[width] || args.formats[args.defaultWidth];
    return format22;
  };
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth2 = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth2;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth2];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
function buildMatchFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array2, predicate) {
  for (var key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string2.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string2.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string2.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number6 = Number(dirtyNumber);
  if (isNaN(number6)) {
    return number6;
  }
  return number6 < 0 ? Math.ceil(number6) : Math.floor(number6);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var day = date2.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCISOWeek(fourthOfJanuary);
  return date2;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date2).getTime() - startOfUTCISOWeekYear(date2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year = date2.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCWeek(firstWeek, options);
  return date2;
}
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCWeek(date2, options).getTime() - startOfUTCWeekYear(date2, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count2, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative_default = formatRelative;
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number6 = Number(dirtyNumber);
  var rem100 = number6 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number6 + "st";
      case 2:
        return number6 + "nd";
      case 3:
        return number6 + "rd";
    }
  }
  return number6 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;
function _typeof4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p4) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf(o3, p4);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf(o3);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate2, options) {
      return this.validateValue(utcDate2, this.value, options);
    }
  }, {
    key: "set",
    value: function set3(utcDate2, flags, options) {
      return this.setValue(utcDate2, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck2(this, Parser2);
  }
  _createClass2(Parser2, [{
    key: "run",
    value: function run(dateString, token, match5, options) {
      var result = this.parse(dateString, token, match5, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
function _typeof5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof5 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof5 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof5(obj);
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o3, p4) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf2(o3, p4);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf2(o3) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf2(o3);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits2(EraParser2, _Parser);
  var _super = _createSuper2(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck3(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty2(_assertThisInitialized2(_this), "priority", 140);
    _defineProperty2(_assertThisInitialized2(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass3(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match5.era(dateString, {
            width: "abbreviated"
          }) || match5.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match5.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match5.era(dateString, {
            width: "wide"
          }) || match5.era(dateString, {
            width: "abbreviated"
          }) || match5.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set3(date2, flags, value) {
      flags.era = value;
      date2.setUTCFullYear(value, 0, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return EraParser2;
}(Parser);
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign3 = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds2 = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign3 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds2 * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof6 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof6 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof6(obj);
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties4(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o3, p4) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf3(o3, p4);
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn3(this, result);
  };
}
function _possibleConstructorReturn3(self2, call) {
  if (call && (_typeof6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized3(self2);
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf3(o3) {
  _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf3(o3);
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits3(YearParser2, _Parser);
  var _super = _createSuper3(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck4(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty3(_assertThisInitialized3(_this), "priority", 130);
    _defineProperty3(_assertThisInitialized3(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass4(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      var valueCallback9 = function valueCallback10(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback9);
        case "yo":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback9);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback9);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set3(date2, flags, value) {
      var currentYear = date2.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date2.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date2.setUTCFullYear(year, 0, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return YearParser2;
}(Parser);
function _typeof7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof7 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof7 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof7(obj);
}
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties5(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties5(Constructor, staticProps);
  return Constructor;
}
function _inherits4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o3, p4) {
  _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf4(o3, p4);
}
function _createSuper4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn4(this, result);
  };
}
function _possibleConstructorReturn4(self2, call) {
  if (call && (_typeof7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized4(self2);
}
function _assertThisInitialized4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf4(o3) {
  _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf4(o3);
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits4(LocalWeekYearParser2, _Parser);
  var _super = _createSuper4(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck5(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty4(_assertThisInitialized4(_this), "priority", 130);
    _defineProperty4(_assertThisInitialized4(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass5(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      var valueCallback9 = function valueCallback10(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback9);
        case "Yo":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback9);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback9);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set3(date2, flags, value, options) {
      var currentYear = getUTCWeekYear(date2, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date2.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date2.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date2, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date2.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date2.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date2, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
function _typeof8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof8 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof8 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof8(obj);
}
function _classCallCheck6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties6(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties6(Constructor, staticProps);
  return Constructor;
}
function _inherits5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf5(subClass, superClass);
}
function _setPrototypeOf5(o3, p4) {
  _setPrototypeOf5 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf5(o3, p4);
}
function _createSuper5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn5(this, result);
  };
}
function _possibleConstructorReturn5(self2, call) {
  if (call && (_typeof8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized5(self2);
}
function _assertThisInitialized5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf5(o3) {
  _getPrototypeOf5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf5(o3);
}
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits5(ISOWeekYearParser2, _Parser);
  var _super = _createSuper5(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck6(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty5(_assertThisInitialized5(_this), "priority", 130);
    _defineProperty5(_assertThisInitialized5(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass6(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set3(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
function _typeof9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof9 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof9 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof9(obj);
}
function _classCallCheck7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties7(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties7(Constructor, staticProps);
  return Constructor;
}
function _inherits6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf6(subClass, superClass);
}
function _setPrototypeOf6(o3, p4) {
  _setPrototypeOf6 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf6(o3, p4);
}
function _createSuper6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn6(this, result);
  };
}
function _possibleConstructorReturn6(self2, call) {
  if (call && (_typeof9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized6(self2);
}
function _assertThisInitialized6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf6(o3) {
  _getPrototypeOf6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf6(o3);
}
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits6(ExtendedYearParser2, _Parser);
  var _super = _createSuper6(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck7(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty6(_assertThisInitialized6(_this), "priority", 130);
    _defineProperty6(_assertThisInitialized6(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass7(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCFullYear(value, 0, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
function _typeof10(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof10 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof10 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof10(obj);
}
function _classCallCheck8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties8(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties8(Constructor, staticProps);
  return Constructor;
}
function _inherits7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf7(subClass, superClass);
}
function _setPrototypeOf7(o3, p4) {
  _setPrototypeOf7 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf7(o3, p4);
}
function _createSuper7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn7(this, result);
  };
}
function _possibleConstructorReturn7(self2, call) {
  if (call && (_typeof10(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized7(self2);
}
function _assertThisInitialized7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf7(o3) {
  _getPrototypeOf7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf7(o3);
}
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits7(QuarterParser2, _Parser);
  var _super = _createSuper7(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck8(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty7(_assertThisInitialized7(_this), "priority", 120);
    _defineProperty7(_assertThisInitialized7(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass8(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match5.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match5.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match5.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match5.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMonth((value - 1) * 3, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return QuarterParser2;
}(Parser);
function _typeof11(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof11 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof11 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof11(obj);
}
function _classCallCheck9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties9(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties9(Constructor, staticProps);
  return Constructor;
}
function _inherits8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf8(subClass, superClass);
}
function _setPrototypeOf8(o3, p4) {
  _setPrototypeOf8 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf8(o3, p4);
}
function _createSuper8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn8(this, result);
  };
}
function _possibleConstructorReturn8(self2, call) {
  if (call && (_typeof11(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized8(self2);
}
function _assertThisInitialized8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf8(o3) {
  _getPrototypeOf8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf8(o3);
}
function _defineProperty8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits8(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper8(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck9(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty8(_assertThisInitialized8(_this), "priority", 120);
    _defineProperty8(_assertThisInitialized8(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass9(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match5.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match5.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match5.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match5.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match5.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMonth((value - 1) * 3, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
function _typeof12(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof12 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof12 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof12(obj);
}
function _classCallCheck10(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties10(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass10(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties10(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties10(Constructor, staticProps);
  return Constructor;
}
function _inherits9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf9(subClass, superClass);
}
function _setPrototypeOf9(o3, p4) {
  _setPrototypeOf9 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf9(o3, p4);
}
function _createSuper9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn9(this, result);
  };
}
function _possibleConstructorReturn9(self2, call) {
  if (call && (_typeof12(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized9(self2);
}
function _assertThisInitialized9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf9(o3) {
  _getPrototypeOf9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf9(o3);
}
function _defineProperty9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits9(MonthParser2, _Parser);
  var _super = _createSuper9(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck10(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty9(_assertThisInitialized9(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty9(_assertThisInitialized9(_this), "priority", 110);
    return _this;
  }
  _createClass10(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      var valueCallback9 = function valueCallback10(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback9);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback9);
        case "Mo":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback9);
        case "MMM":
          return match5.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match5.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match5.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMonth(value, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return MonthParser2;
}(Parser);
function _typeof13(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof13 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof13 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof13(obj);
}
function _classCallCheck11(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties11(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass11(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties11(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties11(Constructor, staticProps);
  return Constructor;
}
function _inherits10(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf10(subClass, superClass);
}
function _setPrototypeOf10(o3, p4) {
  _setPrototypeOf10 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf10(o3, p4);
}
function _createSuper10(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct10();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf10(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf10(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn10(this, result);
  };
}
function _possibleConstructorReturn10(self2, call) {
  if (call && (_typeof13(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized10(self2);
}
function _assertThisInitialized10(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct10() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf10(o3) {
  _getPrototypeOf10 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf10(o3);
}
function _defineProperty10(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits10(StandAloneMonthParser2, _Parser);
  var _super = _createSuper10(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck11(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty10(_assertThisInitialized10(_this), "priority", 110);
    _defineProperty10(_assertThisInitialized10(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass11(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      var valueCallback9 = function valueCallback10(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback9);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback9);
        case "Lo":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback9);
        case "LLL":
          return match5.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match5.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match5.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match5.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMonth(value, 1);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date2, options) - week;
  date2.setUTCDate(date2.getUTCDate() - diff * 7);
  return date2;
}
function _typeof14(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof14 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof14 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof14(obj);
}
function _classCallCheck12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties12(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass12(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties12(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties12(Constructor, staticProps);
  return Constructor;
}
function _inherits11(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf11(subClass, superClass);
}
function _setPrototypeOf11(o3, p4) {
  _setPrototypeOf11 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf11(o3, p4);
}
function _createSuper11(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct11();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf11(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf11(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn11(this, result);
  };
}
function _possibleConstructorReturn11(self2, call) {
  if (call && (_typeof14(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized11(self2);
}
function _assertThisInitialized11(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct11() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf11(o3) {
  _getPrototypeOf11 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf11(o3);
}
function _defineProperty11(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits11(LocalWeekParser2, _Parser);
  var _super = _createSuper11(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck12(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty11(_assertThisInitialized11(_this), "priority", 100);
    _defineProperty11(_assertThisInitialized11(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass12(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match5.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date2, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date2) - isoWeek;
  date2.setUTCDate(date2.getUTCDate() - diff * 7);
  return date2;
}
function _typeof15(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof15 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof15 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof15(obj);
}
function _classCallCheck13(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties13(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass13(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties13(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties13(Constructor, staticProps);
  return Constructor;
}
function _inherits12(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf12(subClass, superClass);
}
function _setPrototypeOf12(o3, p4) {
  _setPrototypeOf12 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf12(o3, p4);
}
function _createSuper12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf12(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf12(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn12(this, result);
  };
}
function _possibleConstructorReturn12(self2, call) {
  if (call && (_typeof15(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized12(self2);
}
function _assertThisInitialized12(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct12() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf12(o3) {
  _getPrototypeOf12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf12(o3);
}
function _defineProperty12(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits12(ISOWeekParser2, _Parser);
  var _super = _createSuper12(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck13(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty12(_assertThisInitialized12(_this), "priority", 100);
    _defineProperty12(_assertThisInitialized12(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass13(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match5.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date2, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
function _typeof16(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof16 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof16 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof16(obj);
}
function _classCallCheck14(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties14(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass14(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties14(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties14(Constructor, staticProps);
  return Constructor;
}
function _inherits13(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf13(subClass, superClass);
}
function _setPrototypeOf13(o3, p4) {
  _setPrototypeOf13 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf13(o3, p4);
}
function _createSuper13(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct13();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf13(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf13(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn13(this, result);
  };
}
function _possibleConstructorReturn13(self2, call) {
  if (call && (_typeof16(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized13(self2);
}
function _assertThisInitialized13(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct13() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf13(o3) {
  _getPrototypeOf13 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf13(o3);
}
function _defineProperty13(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits13(DateParser2, _Parser);
  var _super = _createSuper13(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck14(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty13(_assertThisInitialized13(_this), "priority", 90);
    _defineProperty13(_assertThisInitialized13(_this), "subPriority", 1);
    _defineProperty13(_assertThisInitialized13(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass14(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match5.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date2, value) {
      var year = date2.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date2.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCDate(value);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return DateParser2;
}(Parser);
function _typeof17(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof17 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof17 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof17(obj);
}
function _classCallCheck15(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties15(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass15(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties15(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties15(Constructor, staticProps);
  return Constructor;
}
function _inherits14(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf14(subClass, superClass);
}
function _setPrototypeOf14(o3, p4) {
  _setPrototypeOf14 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf14(o3, p4);
}
function _createSuper14(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct14();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf14(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf14(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn14(this, result);
  };
}
function _possibleConstructorReturn14(self2, call) {
  if (call && (_typeof17(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized14(self2);
}
function _assertThisInitialized14(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct14() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf14(o3) {
  _getPrototypeOf14 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf14(o3);
}
function _defineProperty14(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits14(DayOfYearParser2, _Parser);
  var _super = _createSuper14(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck15(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty14(_assertThisInitialized14(_this), "priority", 90);
    _defineProperty14(_assertThisInitialized14(_this), "subpriority", 1);
    _defineProperty14(_assertThisInitialized14(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass15(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match5.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date2, value) {
      var year = date2.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMonth(0, value);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date2.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
function _typeof18(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof18 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof18 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof18(obj);
}
function _classCallCheck16(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties16(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass16(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties16(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties16(Constructor, staticProps);
  return Constructor;
}
function _inherits15(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf15(subClass, superClass);
}
function _setPrototypeOf15(o3, p4) {
  _setPrototypeOf15 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf15(o3, p4);
}
function _createSuper15(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct15();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf15(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf15(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn15(this, result);
  };
}
function _possibleConstructorReturn15(self2, call) {
  if (call && (_typeof18(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized15(self2);
}
function _assertThisInitialized15(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct15() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf15(o3) {
  _getPrototypeOf15 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf15(o3);
}
function _defineProperty15(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits15(DayParser2, _Parser);
  var _super = _createSuper15(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck16(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty15(_assertThisInitialized15(_this), "priority", 90);
    _defineProperty15(_assertThisInitialized15(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass16(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match5.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value, options) {
      date2 = setUTCDay(date2, value, options);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return DayParser2;
}(Parser);
function _typeof19(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof19 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof19 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof19(obj);
}
function _classCallCheck17(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties17(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass17(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties17(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties17(Constructor, staticProps);
  return Constructor;
}
function _inherits16(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf16(subClass, superClass);
}
function _setPrototypeOf16(o3, p4) {
  _setPrototypeOf16 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf16(o3, p4);
}
function _createSuper16(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct16();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf16(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf16(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn16(this, result);
  };
}
function _possibleConstructorReturn16(self2, call) {
  if (call && (_typeof19(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized16(self2);
}
function _assertThisInitialized16(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct16() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf16(o3) {
  _getPrototypeOf16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf16(o3);
}
function _defineProperty16(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits16(LocalDayParser2, _Parser);
  var _super = _createSuper16(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck17(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty16(_assertThisInitialized16(_this), "priority", 90);
    _defineProperty16(_assertThisInitialized16(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass17(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5, options) {
      var valueCallback9 = function valueCallback10(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback9);
        case "eo":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback9);
        case "eee":
          return match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match5.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value, options) {
      date2 = setUTCDay(date2, value, options);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return LocalDayParser2;
}(Parser);
function _typeof20(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof20 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof20 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof20(obj);
}
function _classCallCheck18(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties18(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass18(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties18(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties18(Constructor, staticProps);
  return Constructor;
}
function _inherits17(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf17(subClass, superClass);
}
function _setPrototypeOf17(o3, p4) {
  _setPrototypeOf17 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf17(o3, p4);
}
function _createSuper17(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct17();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf17(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf17(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn17(this, result);
  };
}
function _possibleConstructorReturn17(self2, call) {
  if (call && (_typeof20(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized17(self2);
}
function _assertThisInitialized17(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct17() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf17(o3) {
  _getPrototypeOf17 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf17(o3);
}
function _defineProperty17(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits17(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper17(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck18(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty17(_assertThisInitialized17(_this), "priority", 90);
    _defineProperty17(_assertThisInitialized17(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass18(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5, options) {
      var valueCallback9 = function valueCallback10(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback9);
        case "co":
          return mapValue(match5.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback9);
        case "ccc":
          return match5.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match5.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match5.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match5.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value, options) {
      date2 = setUTCDay(date2, value, options);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var currentDay = date2.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
function _typeof21(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof21 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof21 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof21(obj);
}
function _classCallCheck19(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties19(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass19(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties19(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties19(Constructor, staticProps);
  return Constructor;
}
function _inherits18(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf18(subClass, superClass);
}
function _setPrototypeOf18(o3, p4) {
  _setPrototypeOf18 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf18(o3, p4);
}
function _createSuper18(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct18();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf18(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf18(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn18(this, result);
  };
}
function _possibleConstructorReturn18(self2, call) {
  if (call && (_typeof21(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized18(self2);
}
function _assertThisInitialized18(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct18() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf18(o3) {
  _getPrototypeOf18 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf18(o3);
}
function _defineProperty18(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits18(ISODayParser2, _Parser);
  var _super = _createSuper18(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck19(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty18(_assertThisInitialized18(_this), "priority", 90);
    _defineProperty18(_assertThisInitialized18(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass19(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      var valueCallback9 = function valueCallback10(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match5.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback9);
        case "iiiii":
          return mapValue(match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback9);
        case "iiiiii":
          return mapValue(match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback9);
        case "iiii":
        default:
          return mapValue(match5.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match5.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback9);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2 = setUTCISODay(date2, value);
      date2.setUTCHours(0, 0, 0, 0);
      return date2;
    }
  }]);
  return ISODayParser2;
}(Parser);
function _typeof22(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof22 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof22 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof22(obj);
}
function _classCallCheck20(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties20(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass20(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties20(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties20(Constructor, staticProps);
  return Constructor;
}
function _inherits19(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf19(subClass, superClass);
}
function _setPrototypeOf19(o3, p4) {
  _setPrototypeOf19 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf19(o3, p4);
}
function _createSuper19(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct19();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf19(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf19(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn19(this, result);
  };
}
function _possibleConstructorReturn19(self2, call) {
  if (call && (_typeof22(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized19(self2);
}
function _assertThisInitialized19(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct19() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf19(o3) {
  _getPrototypeOf19 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf19(o3);
}
function _defineProperty19(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits19(AMPMParser2, _Parser);
  var _super = _createSuper19(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck20(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty19(_assertThisInitialized19(_this), "priority", 80);
    _defineProperty19(_assertThisInitialized19(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass20(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match5.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  }]);
  return AMPMParser2;
}(Parser);
function _typeof23(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof23 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof23 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof23(obj);
}
function _classCallCheck21(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties21(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass21(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties21(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties21(Constructor, staticProps);
  return Constructor;
}
function _inherits20(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf20(subClass, superClass);
}
function _setPrototypeOf20(o3, p4) {
  _setPrototypeOf20 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf20(o3, p4);
}
function _createSuper20(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct20();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf20(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf20(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn20(this, result);
  };
}
function _possibleConstructorReturn20(self2, call) {
  if (call && (_typeof23(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized20(self2);
}
function _assertThisInitialized20(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct20() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf20(o3) {
  _getPrototypeOf20 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf20(o3);
}
function _defineProperty20(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits20(AMPMMidnightParser2, _Parser);
  var _super = _createSuper20(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck21(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty20(_assertThisInitialized20(_this), "priority", 80);
    _defineProperty20(_assertThisInitialized20(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass21(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match5.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
function _typeof24(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof24 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof24 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof24(obj);
}
function _classCallCheck22(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties22(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass22(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties22(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties22(Constructor, staticProps);
  return Constructor;
}
function _inherits21(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf21(subClass, superClass);
}
function _setPrototypeOf21(o3, p4) {
  _setPrototypeOf21 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf21(o3, p4);
}
function _createSuper21(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct21();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf21(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf21(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn21(this, result);
  };
}
function _possibleConstructorReturn21(self2, call) {
  if (call && (_typeof24(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized21(self2);
}
function _assertThisInitialized21(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct21() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf21(o3) {
  _getPrototypeOf21 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf21(o3);
}
function _defineProperty21(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits21(DayPeriodParser2, _Parser);
  var _super = _createSuper21(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck22(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty21(_assertThisInitialized21(_this), "priority", 80);
    _defineProperty21(_assertThisInitialized21(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass22(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match5.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match5.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date2;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
function _typeof25(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof25 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof25 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof25(obj);
}
function _classCallCheck23(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties23(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass23(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties23(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties23(Constructor, staticProps);
  return Constructor;
}
function _inherits22(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf22(subClass, superClass);
}
function _setPrototypeOf22(o3, p4) {
  _setPrototypeOf22 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf22(o3, p4);
}
function _createSuper22(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct22();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf22(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf22(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn22(this, result);
  };
}
function _possibleConstructorReturn22(self2, call) {
  if (call && (_typeof25(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized22(self2);
}
function _assertThisInitialized22(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct22() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf22(o3) {
  _getPrototypeOf22 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf22(o3);
}
function _defineProperty22(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits22(Hour1to12Parser2, _Parser);
  var _super = _createSuper22(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck23(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty22(_assertThisInitialized22(_this), "priority", 70);
    _defineProperty22(_assertThisInitialized22(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass23(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match5.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      var isPM = date2.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date2.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date2.setUTCHours(0, 0, 0, 0);
      } else {
        date2.setUTCHours(value, 0, 0, 0);
      }
      return date2;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
function _typeof26(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof26 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof26 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof26(obj);
}
function _classCallCheck24(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties24(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass24(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties24(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties24(Constructor, staticProps);
  return Constructor;
}
function _inherits23(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf23(subClass, superClass);
}
function _setPrototypeOf23(o3, p4) {
  _setPrototypeOf23 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf23(o3, p4);
}
function _createSuper23(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct23();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf23(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf23(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn23(this, result);
  };
}
function _possibleConstructorReturn23(self2, call) {
  if (call && (_typeof26(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized23(self2);
}
function _assertThisInitialized23(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct23() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf23(o3) {
  _getPrototypeOf23 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf23(o3);
}
function _defineProperty23(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits23(Hour0to23Parser2, _Parser);
  var _super = _createSuper23(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck24(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty23(_assertThisInitialized23(_this), "priority", 70);
    _defineProperty23(_assertThisInitialized23(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass24(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match5.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCHours(value, 0, 0, 0);
      return date2;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
function _typeof27(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof27 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof27 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof27(obj);
}
function _classCallCheck25(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties25(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass25(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties25(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties25(Constructor, staticProps);
  return Constructor;
}
function _inherits24(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf24(subClass, superClass);
}
function _setPrototypeOf24(o3, p4) {
  _setPrototypeOf24 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf24(o3, p4);
}
function _createSuper24(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct24();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf24(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf24(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn24(this, result);
  };
}
function _possibleConstructorReturn24(self2, call) {
  if (call && (_typeof27(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized24(self2);
}
function _assertThisInitialized24(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct24() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf24(o3) {
  _getPrototypeOf24 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf24(o3);
}
function _defineProperty24(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits24(Hour0To11Parser2, _Parser);
  var _super = _createSuper24(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck25(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty24(_assertThisInitialized24(_this), "priority", 70);
    _defineProperty24(_assertThisInitialized24(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass25(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match5.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      var isPM = date2.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date2.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date2.setUTCHours(value, 0, 0, 0);
      }
      return date2;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
function _typeof28(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof28 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof28 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof28(obj);
}
function _classCallCheck26(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties26(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass26(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties26(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties26(Constructor, staticProps);
  return Constructor;
}
function _inherits25(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf25(subClass, superClass);
}
function _setPrototypeOf25(o3, p4) {
  _setPrototypeOf25 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf25(o3, p4);
}
function _createSuper25(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct25();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf25(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf25(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn25(this, result);
  };
}
function _possibleConstructorReturn25(self2, call) {
  if (call && (_typeof28(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized25(self2);
}
function _assertThisInitialized25(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct25() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf25(o3) {
  _getPrototypeOf25 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf25(o3);
}
function _defineProperty25(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits25(Hour1To24Parser2, _Parser);
  var _super = _createSuper25(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck26(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty25(_assertThisInitialized25(_this), "priority", 70);
    _defineProperty25(_assertThisInitialized25(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass26(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match5.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date2.setUTCHours(hours, 0, 0, 0);
      return date2;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
function _typeof29(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof29 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof29 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof29(obj);
}
function _classCallCheck27(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties27(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass27(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties27(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties27(Constructor, staticProps);
  return Constructor;
}
function _inherits26(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf26(subClass, superClass);
}
function _setPrototypeOf26(o3, p4) {
  _setPrototypeOf26 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf26(o3, p4);
}
function _createSuper26(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct26();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf26(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf26(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn26(this, result);
  };
}
function _possibleConstructorReturn26(self2, call) {
  if (call && (_typeof29(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized26(self2);
}
function _assertThisInitialized26(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct26() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf26(o3) {
  _getPrototypeOf26 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf26(o3);
}
function _defineProperty26(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits26(MinuteParser2, _Parser);
  var _super = _createSuper26(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck27(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty26(_assertThisInitialized26(_this), "priority", 60);
    _defineProperty26(_assertThisInitialized26(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass27(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match5.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMinutes(value, 0, 0);
      return date2;
    }
  }]);
  return MinuteParser2;
}(Parser);
function _typeof30(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof30 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof30 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof30(obj);
}
function _classCallCheck28(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties28(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass28(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties28(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties28(Constructor, staticProps);
  return Constructor;
}
function _inherits27(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf27(subClass, superClass);
}
function _setPrototypeOf27(o3, p4) {
  _setPrototypeOf27 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf27(o3, p4);
}
function _createSuper27(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct27();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf27(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf27(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn27(this, result);
  };
}
function _possibleConstructorReturn27(self2, call) {
  if (call && (_typeof30(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized27(self2);
}
function _assertThisInitialized27(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct27() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf27(o3) {
  _getPrototypeOf27 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf27(o3);
}
function _defineProperty27(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits27(SecondParser2, _Parser);
  var _super = _createSuper27(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck28(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty27(_assertThisInitialized27(_this), "priority", 50);
    _defineProperty27(_assertThisInitialized27(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass28(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match5) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match5.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCSeconds(value, 0);
      return date2;
    }
  }]);
  return SecondParser2;
}(Parser);
function _typeof31(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof31 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof31 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof31(obj);
}
function _classCallCheck29(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties29(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass29(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties29(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties29(Constructor, staticProps);
  return Constructor;
}
function _inherits28(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf28(subClass, superClass);
}
function _setPrototypeOf28(o3, p4) {
  _setPrototypeOf28 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf28(o3, p4);
}
function _createSuper28(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct28();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf28(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf28(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn28(this, result);
  };
}
function _possibleConstructorReturn28(self2, call) {
  if (call && (_typeof31(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized28(self2);
}
function _assertThisInitialized28(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct28() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf28(o3) {
  _getPrototypeOf28 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf28(o3);
}
function _defineProperty28(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits28(FractionOfSecondParser2, _Parser);
  var _super = _createSuper28(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck29(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty28(_assertThisInitialized28(_this), "priority", 30);
    _defineProperty28(_assertThisInitialized28(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass29(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback9 = function valueCallback10(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback9);
    }
  }, {
    key: "set",
    value: function set3(date2, _flags, value) {
      date2.setUTCMilliseconds(value);
      return date2;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
function _typeof32(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof32 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof32 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof32(obj);
}
function _classCallCheck30(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties30(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass30(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties30(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties30(Constructor, staticProps);
  return Constructor;
}
function _inherits29(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf29(subClass, superClass);
}
function _setPrototypeOf29(o3, p4) {
  _setPrototypeOf29 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf29(o3, p4);
}
function _createSuper29(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct29();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf29(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf29(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn29(this, result);
  };
}
function _possibleConstructorReturn29(self2, call) {
  if (call && (_typeof32(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized29(self2);
}
function _assertThisInitialized29(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct29() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf29(o3) {
  _getPrototypeOf29 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf29(o3);
}
function _defineProperty29(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits29(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper29(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck30(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty29(_assertThisInitialized29(_this), "priority", 10);
    _defineProperty29(_assertThisInitialized29(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass30(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set3(date2, flags, value) {
      if (flags.timestampIsSet) {
        return date2;
      }
      return new Date(date2.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
function _typeof33(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof33 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof33 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof33(obj);
}
function _classCallCheck31(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties31(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass31(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties31(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties31(Constructor, staticProps);
  return Constructor;
}
function _inherits30(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf30(subClass, superClass);
}
function _setPrototypeOf30(o3, p4) {
  _setPrototypeOf30 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf30(o3, p4);
}
function _createSuper30(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct30();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf30(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf30(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn30(this, result);
  };
}
function _possibleConstructorReturn30(self2, call) {
  if (call && (_typeof33(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized30(self2);
}
function _assertThisInitialized30(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct30() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf30(o3) {
  _getPrototypeOf30 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf30(o3);
}
function _defineProperty30(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits30(ISOTimezoneParser2, _Parser);
  var _super = _createSuper30(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck31(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty30(_assertThisInitialized30(_this), "priority", 10);
    _defineProperty30(_assertThisInitialized30(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass31(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set3(date2, flags, value) {
      if (flags.timestampIsSet) {
        return date2;
      }
      return new Date(date2.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
function _typeof34(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof34 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof34 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof34(obj);
}
function _classCallCheck32(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties32(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass32(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties32(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties32(Constructor, staticProps);
  return Constructor;
}
function _inherits31(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf31(subClass, superClass);
}
function _setPrototypeOf31(o3, p4) {
  _setPrototypeOf31 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf31(o3, p4);
}
function _createSuper31(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct31();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf31(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf31(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn31(this, result);
  };
}
function _possibleConstructorReturn31(self2, call) {
  if (call && (_typeof34(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized31(self2);
}
function _assertThisInitialized31(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct31() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf31(o3) {
  _getPrototypeOf31 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf31(o3);
}
function _defineProperty31(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits31(TimestampSecondsParser2, _Parser);
  var _super = _createSuper31(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck32(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty31(_assertThisInitialized31(_this), "priority", 40);
    _defineProperty31(_assertThisInitialized31(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass32(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set3(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
function _typeof35(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof35 = function _typeof38(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof35 = function _typeof38(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof35(obj);
}
function _classCallCheck33(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties33(target, props) {
  for (var i22 = 0; i22 < props.length; i22++) {
    var descriptor = props[i22];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass33(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties33(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties33(Constructor, staticProps);
  return Constructor;
}
function _inherits32(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf32(subClass, superClass);
}
function _setPrototypeOf32(o3, p4) {
  _setPrototypeOf32 = Object.setPrototypeOf || function _setPrototypeOf33(o22, p22) {
    o22.__proto__ = p22;
    return o22;
  };
  return _setPrototypeOf32(o3, p4);
}
function _createSuper32(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct32();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf32(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf32(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn32(this, result);
  };
}
function _possibleConstructorReturn32(self2, call) {
  if (call && (_typeof35(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized32(self2);
}
function _assertThisInitialized32(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct32() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e23) {
    return false;
  }
}
function _getPrototypeOf32(o3) {
  _getPrototypeOf32 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf33(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf32(o3);
}
function _defineProperty32(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits32(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper32(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck33(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty32(_assertThisInitialized32(_this), "priority", 20);
    _defineProperty32(_assertThisInitialized32(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass33(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set3(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers2 = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
var formatDistanceLocale2 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    },
    withPreposition: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    }
  },
  xSeconds: {
    standalone: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    },
    withPreposition: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    }
  },
  halfAMinute: {
    standalone: "halbe Minute",
    withPreposition: "halben Minute"
  },
  lessThanXMinutes: {
    standalone: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    },
    withPreposition: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    }
  },
  xMinutes: {
    standalone: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    },
    withPreposition: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    },
    withPreposition: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    }
  },
  xHours: {
    standalone: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    },
    withPreposition: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    }
  },
  xDays: {
    standalone: {
      one: "1 Tag",
      other: "{{count}} Tage"
    },
    withPreposition: {
      one: "1 Tag",
      other: "{{count}} Tagen"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    },
    withPreposition: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monate"
    },
    withPreposition: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monaten"
    }
  },
  xMonths: {
    standalone: {
      one: "1 Monat",
      other: "{{count}} Monate"
    },
    withPreposition: {
      one: "1 Monat",
      other: "{{count}} Monaten"
    }
  },
  aboutXYears: {
    standalone: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahre"
    },
    withPreposition: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahren"
    }
  },
  xYears: {
    standalone: {
      one: "1 Jahr",
      other: "{{count}} Jahre"
    },
    withPreposition: {
      one: "1 Jahr",
      other: "{{count}} Jahren"
    }
  },
  overXYears: {
    standalone: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahre"
    },
    withPreposition: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahren"
    }
  },
  almostXYears: {
    standalone: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahre"
    },
    withPreposition: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahren"
    }
  }
};
var formatDistance3 = function formatDistance4(token, count2, options) {
  var result;
  var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale2[token].withPreposition : formatDistanceLocale2[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count2));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }
  return result;
};
var formatDistance_default2 = formatDistance3;
var dateFormats2 = {
  full: "EEEE, do MMMM y",
  // Montag, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan. 2018
  short: "dd.MM.y"
  // 07.01.2018
};
var timeFormats2 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats2 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong2 = {
  date: buildFormatLongFn({
    formats: dateFormats2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats2,
    defaultWidth: "full"
  })
};
var formatLong_default2 = formatLong2;
var formatRelativeLocale2 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
var formatRelative3 = function formatRelative4(token, _date, _baseDate, _options) {
  return formatRelativeLocale2[token];
};
var formatRelative_default2 = formatRelative3;
var eraValues2 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
var quarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
var monthValues2 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "M\xE4r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
  wide: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
};
var formattingMonthValues = {
  narrow: monthValues2.narrow,
  abbreviated: ["Jan.", "Feb.", "M\xE4rz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sep.", "Okt.", "Nov.", "Dez."],
  wide: monthValues2.wide
};
var dayValues2 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
};
var dayPeriodValues2 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
var formattingDayPeriodValues2 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
var ordinalNumber3 = function ordinalNumber4(dirtyNumber) {
  var number6 = Number(dirtyNumber);
  return number6 + ".";
};
var localize2 = {
  ordinalNumber: ordinalNumber3,
  era: buildLocalizeFn({
    values: eraValues2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues2,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback2(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues2,
    formattingValues: formattingMonthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues2,
    defaultFormattingWidth: "wide"
  })
};
var localize_default2 = localize2;
var matchOrdinalNumberPattern2 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern2 = /\d+/i;
var matchEraPatterns2 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
var parseEraPatterns2 = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns2 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns2 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns2 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns2 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^j[aä]/i, /^f/i, /^mär/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns2 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
var parseDayPatterns2 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns2 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
var parseDayPeriodPatterns2 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i
    // will never be matched. Night is matched by `pm`
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern2,
    parsePattern: parseOrdinalNumberPattern2,
    valueCallback: function valueCallback3(value) {
      return parseInt(value);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns2,
    defaultParseWidth: "any",
    valueCallback: function valueCallback4(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns2,
    defaultParseWidth: "any"
  })
};
var match_default2 = match2;
var locale2 = {
  code: "de",
  formatDistance: formatDistance_default2,
  formatLong: formatLong_default2,
  formatRelative: formatRelative_default2,
  localize: localize_default2,
  match: match_default2,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var de_default = locale2;
var dateFormats3 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats3 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats3 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong3 = {
  date: buildFormatLongFn({
    formats: dateFormats3,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats3,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats3,
    defaultWidth: "full"
  })
};
var formatLong_default3 = formatLong3;
var locale3 = {
  code: "en-GB",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default3,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var en_GB_default = locale3;
var formatDistanceLocale3 = {
  lessThanXSeconds: {
    one: "menos de un segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos de un minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "alrededor de 1 hora",
    other: "alrededor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 d\xEDa",
    other: "{{count}} d\xEDas"
  },
  aboutXWeeks: {
    one: "alrededor de 1 semana",
    other: "alrededor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "alrededor de 1 mes",
    other: "alrededor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "alrededor de 1 a\xF1o",
    other: "alrededor de {{count}} a\xF1os"
  },
  xYears: {
    one: "1 a\xF1o",
    other: "{{count}} a\xF1os"
  },
  overXYears: {
    one: "m\xE1s de 1 a\xF1o",
    other: "m\xE1s de {{count}} a\xF1os"
  },
  almostXYears: {
    one: "casi 1 a\xF1o",
    other: "casi {{count}} a\xF1os"
  }
};
var formatDistance5 = function formatDistance6(token, count2, options) {
  var result;
  var tokenValue = formatDistanceLocale3[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hace " + result;
    }
  }
  return result;
};
var formatDistance_default3 = formatDistance5;
var dateFormats4 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats4 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats4 = {
  full: "{{date}} 'a las' {{time}}",
  long: "{{date}} 'a las' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong4 = {
  date: buildFormatLongFn({
    formats: dateFormats4,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats4,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats4,
    defaultWidth: "full"
  })
};
var formatLong_default4 = formatLong4;
var formatRelativeLocale3 = {
  lastWeek: "'el' eeee 'pasado a la' p",
  yesterday: "'ayer a la' p",
  today: "'hoy a la' p",
  tomorrow: "'ma\xF1ana a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
var formatRelativeLocalePlural = {
  lastWeek: "'el' eeee 'pasado a las' p",
  yesterday: "'ayer a las' p",
  today: "'hoy a las' p",
  tomorrow: "'ma\xF1ana a las' p",
  nextWeek: "eeee 'a las' p",
  other: "P"
};
var formatRelative5 = function formatRelative6(token, date2, _baseDate, _options) {
  if (date2.getUTCHours() !== 1) {
    return formatRelativeLocalePlural[token];
  } else {
    return formatRelativeLocale3[token];
  }
};
var formatRelative_default3 = formatRelative5;
var eraValues3 = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despu\xE9s de cristo"]
};
var quarterValues3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1\xBA trimestre", "2\xBA trimestre", "3\xBA trimestre", "4\xBA trimestre"]
};
var monthValues3 = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
  wide: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"]
};
var dayValues3 = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "mi", "ju", "vi", "s\xE1"],
  abbreviated: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
  wide: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"]
};
var dayPeriodValues3 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "ma\xF1ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "ma\xF1ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "ma\xF1ana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  }
};
var formattingDayPeriodValues3 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "de la ma\xF1ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la ma\xF1ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la ma\xF1ana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  }
};
var ordinalNumber5 = function ordinalNumber6(dirtyNumber, _options) {
  var number6 = Number(dirtyNumber);
  return number6 + "\xBA";
};
var localize3 = {
  ordinalNumber: ordinalNumber5,
  era: buildLocalizeFn({
    values: eraValues3,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues3,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback3(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues3,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues3,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues3,
    defaultFormattingWidth: "wide"
  })
};
var localize_default3 = localize3;
var matchOrdinalNumberPattern3 = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern3 = /\d+/i;
var matchEraPatterns3 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i
};
var parseEraPatterns3 = {
  any: [/^ac/i, /^dc/i],
  wide: [/^(antes de cristo|antes de la era com[uú]n)/i, /^(despu[eé]s de cristo|era com[uú]n)/i]
};
var matchQuarterPatterns3 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns3 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns3 = {
  narrow: /^[efmajsond]/i,
  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
};
var parseMonthPatterns3 = {
  narrow: [/^e/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^en/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i]
};
var matchDayPatterns3 = {
  narrow: /^[dlmjvs]/i,
  short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,
  abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,
  wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i
};
var parseDayPatterns3 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
};
var matchDayPeriodPatterns3 = {
  narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,
  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i
};
var parseDayPeriodPatterns3 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /mañana/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noche/i
  }
};
var match3 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern3,
    parsePattern: parseOrdinalNumberPattern3,
    valueCallback: function valueCallback5(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns3,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns3,
    defaultParseWidth: "any",
    valueCallback: function valueCallback6(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns3,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns3,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns3,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns3,
    defaultParseWidth: "any"
  })
};
var match_default3 = match3;
var locale4 = {
  code: "es",
  formatDistance: formatDistance_default3,
  formatLong: formatLong_default4,
  formatRelative: formatRelative_default3,
  localize: localize_default3,
  match: match_default3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
var es_default = locale4;
var formatDistanceLocale4 = {
  lessThanXSeconds: {
    one: "moins d\u2019une seconde",
    other: "moins de {{count}} secondes"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} secondes"
  },
  halfAMinute: "30 secondes",
  lessThanXMinutes: {
    one: "moins d\u2019une minute",
    other: "moins de {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "environ 1 heure",
    other: "environ {{count}} heures"
  },
  xHours: {
    one: "1 heure",
    other: "{{count}} heures"
  },
  xDays: {
    one: "1 jour",
    other: "{{count}} jours"
  },
  aboutXWeeks: {
    one: "environ 1 semaine",
    other: "environ {{count}} semaines"
  },
  xWeeks: {
    one: "1 semaine",
    other: "{{count}} semaines"
  },
  aboutXMonths: {
    one: "environ 1 mois",
    other: "environ {{count}} mois"
  },
  xMonths: {
    one: "1 mois",
    other: "{{count}} mois"
  },
  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ans"
  },
  overXYears: {
    one: "plus d\u2019un an",
    other: "plus de {{count}} ans"
  },
  almostXYears: {
    one: "presqu\u2019un an",
    other: "presque {{count}} ans"
  }
};
var formatDistance7 = function formatDistance8(token, count2, options) {
  var result;
  var form = formatDistanceLocale4[token];
  if (typeof form === "string") {
    result = form;
  } else if (count2 === 1) {
    result = form.one;
  } else {
    result = form.other.replace("{{count}}", String(count2));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "dans " + result;
    } else {
      return "il y a " + result;
    }
  }
  return result;
};
var formatDistance_default4 = formatDistance7;
var dateFormats5 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats5 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats5 = {
  full: "{{date}} '\xE0' {{time}}",
  long: "{{date}} '\xE0' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong5 = {
  date: buildFormatLongFn({
    formats: dateFormats5,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats5,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats5,
    defaultWidth: "full"
  })
};
var formatLong_default5 = formatLong5;
var formatRelativeLocale4 = {
  lastWeek: "eeee 'dernier \xE0' p",
  yesterday: "'hier \xE0' p",
  today: "'aujourd\u2019hui \xE0' p",
  tomorrow: "'demain \xE0' p'",
  nextWeek: "eeee 'prochain \xE0' p",
  other: "P"
};
var formatRelative7 = function formatRelative8(token, _date, _baseDate, _options) {
  return formatRelativeLocale4[token];
};
var formatRelative_default4 = formatRelative7;
var eraValues4 = {
  narrow: ["av. J.-C", "ap. J.-C"],
  abbreviated: ["av. J.-C", "ap. J.-C"],
  wide: ["avant J\xE9sus-Christ", "apr\xE8s J\xE9sus-Christ"]
};
var quarterValues4 = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1er trim.", "2\xE8me trim.", "3\xE8me trim.", "4\xE8me trim."],
  wide: ["1er trimestre", "2\xE8me trimestre", "3\xE8me trimestre", "4\xE8me trimestre"]
};
var monthValues4 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["janv.", "f\xE9vr.", "mars", "avr.", "mai", "juin", "juil.", "ao\xFBt", "sept.", "oct.", "nov.", "d\xE9c."],
  wide: ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"]
};
var dayValues4 = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
  abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
  wide: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
};
var dayPeriodValues4 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "soir",
    night: "mat."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "matin",
    afternoon: "apr\xE8s-midi",
    evening: "soir",
    night: "matin"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "du matin",
    afternoon: "de l\u2019apr\xE8s-midi",
    evening: "du soir",
    night: "du matin"
  }
};
var ordinalNumber7 = function ordinalNumber8(dirtyNumber, options) {
  var number6 = Number(dirtyNumber);
  var unit3 = options === null || options === void 0 ? void 0 : options.unit;
  if (number6 === 0)
    return "0";
  var feminineUnits = ["year", "week", "hour", "minute", "second"];
  var suffix;
  if (number6 === 1) {
    suffix = unit3 && feminineUnits.includes(unit3) ? "\xE8re" : "er";
  } else {
    suffix = "\xE8me";
  }
  return number6 + suffix;
};
var localize4 = {
  ordinalNumber: ordinalNumber7,
  era: buildLocalizeFn({
    values: eraValues4,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues4,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback4(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues4,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues4,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues4,
    defaultWidth: "wide"
  })
};
var localize_default4 = localize4;
var matchOrdinalNumberPattern4 = /^(\d+)(ième|ère|ème|er|e)?/i;
var parseOrdinalNumberPattern4 = /\d+/i;
var matchEraPatterns4 = {
  narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
  abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(avant Jésus-Christ|après Jésus-Christ)/i
};
var parseEraPatterns4 = {
  any: [/^av/i, /^ap/i]
};
var matchQuarterPatterns4 = {
  narrow: /^T?[1234]/i,
  abbreviated: /^[1234](er|ème|e)? trim\.?/i,
  wide: /^[1234](er|ème|e)? trimestre/i
};
var parseQuarterPatterns4 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns4 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|févr|mars|avr|mai|juin|juill|juil|août|sept|oct|nov|déc)\.?/i,
  wide: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i
};
var parseMonthPatterns4 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^av/i, /^ma/i, /^juin/i, /^juil/i, /^ao/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns4 = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|lu|ma|me|je|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
  wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
};
var parseDayPatterns4 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
};
var matchDayPeriodPatterns4 = {
  narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
  any: /^([ap]\.?\s?m\.?|du matin|de l'après[-\s]midi|du soir|de la nuit)/i
};
var parseDayPeriodPatterns4 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /soir/i,
    night: /nuit/i
  }
};
var match4 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern4,
    parsePattern: parseOrdinalNumberPattern4,
    valueCallback: function valueCallback7(value) {
      return parseInt(value);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns4,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns4,
    defaultParseWidth: "any",
    valueCallback: function valueCallback8(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns4,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns4,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns4,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns4,
    defaultParseWidth: "any"
  })
};
var match_default4 = match4;
var locale5 = {
  code: "fr",
  formatDistance: formatDistance_default4,
  formatLong: formatLong_default5,
  formatRelative: formatRelative_default4,
  localize: localize_default4,
  match: match_default4,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var fr_default = locale5;
var supportedLang = {
  es: "Espanol [es]",
  en: "English [en]",
  fr: "Francais [fr]",
  de: "Deutsch [de]",
  sv: "Svenska [sv]",
  it: "Italiane [it]"
};
var initial = {
  lang: "en",
  supportedLang,
  changeLanguage: () => {
  },
  i18n,
  dateLocale: en_GB_default,
  completeness: {
    de: 0,
    en: 0,
    es: 0,
    fr: 0,
    it: 0,
    sv: 0
  }
};
var Context2 = B(initial);
var TranslationProvider = ({
  initial: initial22,
  children: children2,
  forceLang,
  source,
  completeness: completenessProp
}) => {
  const completeness = {
    en: 100,
    de: !completenessProp || !completenessProp["de"] ? 0 : completenessProp["de"],
    es: !completenessProp || !completenessProp["es"] ? 0 : completenessProp["es"],
    fr: !completenessProp || !completenessProp["fr"] ? 0 : completenessProp["fr"],
    it: !completenessProp || !completenessProp["it"] ? 0 : completenessProp["it"],
    sv: !completenessProp || !completenessProp["sv"] ? 0 : completenessProp["sv"]
  };
  const { value: lang, update: changeLanguage } = useLang(initial22, completeness);
  h2(() => {
    if (forceLang) {
      changeLanguage(forceLang);
    }
  }, [forceLang]);
  h2(() => {
    setupI18n(lang, source);
  }, [lang]);
  if (forceLang) {
    setupI18n(forceLang, source);
  } else {
    setupI18n(lang, source);
  }
  const dateLocale = lang === "es" ? es_default : lang === "fr" ? fr_default : lang === "de" ? de_default : en_GB_default;
  return h(Context2.Provider, {
    value: { lang, changeLanguage, supportedLang, i18n, dateLocale, completeness },
    children: children2
  });
};
var useTranslationContext = () => q2(Context2);
var BankContext = B(void 0);
var ChallengerContext = B(void 0);
var MerchantContext = B(void 0);
var ExchangeContext = B(void 0);
var Context3 = B(void 0);
var useNavigationContext = () => q2(Context3);
function useCurrentLocation(pagesMap) {
  const pageList = Object.keys(pagesMap);
  const { path: path2, params } = useNavigationContext();
  return findMatch(pagesMap, pageList, path2, params);
}
function getPathAndParamsFromWindow() {
  const path2 = typeof window !== "undefined" ? window.location.hash.substring(1) : "/";
  const params = {};
  if (typeof window !== "undefined") {
    for (const [key, value] of new URLSearchParams(window.location.search)) {
      if (!params[key]) {
        params[key] = [];
      }
      params[key].push(value);
    }
  }
  return { path: path2, params };
}
var { path: initialPath, params: initialParams } = getPathAndParamsFromWindow();
var PopStateEventType = "popstate";
var BrowserHashNavigationProvider = ({
  children: children2
}) => {
  const [{ path: path2, params }, setState] = p3({
    path: initialPath,
    params: initialParams
  });
  if (typeof window === "undefined") {
    throw Error(
      "Can't use BrowserHashNavigationProvider if there is no window object"
    );
  }
  function navigateTo(path22) {
    const { params: params2 } = getPathAndParamsFromWindow();
    setState({ path: path22, params: params2 });
    window.location.href = path22;
  }
  h2(() => {
    function eventListener() {
      setState(getPathAndParamsFromWindow());
    }
    window.addEventListener(PopStateEventType, eventListener);
    return () => {
      window.removeEventListener(PopStateEventType, eventListener);
    };
  }, []);
  return h(Context3.Provider, {
    value: { path: path2, params, navigateTo },
    children: children2
  });
};
function createHeadMetaTag(uri, onNotFound) {
  const meta = document.createElement("meta");
  meta.setAttribute("name", "taler-uri");
  meta.setAttribute("content", stringifyTalerUri(uri));
  document.head.appendChild(meta);
  let walletFound = false;
  window.addEventListener("beforeunload", () => {
    walletFound = true;
  });
  setTimeout(() => {
    if (!walletFound && onNotFound) {
      onNotFound();
    }
  }, 10);
}
var Context4 = B(void 0);
var TalerWalletIntegrationBrowserProvider = ({
  children: children2
}) => {
  const value = {
    publishTalerAction: createHeadMetaTag
  };
  return h(Context4.Provider, {
    value,
    children: children2
  });
};
var utils_exports = {};
__export2(utils_exports, {
  compose: () => compose,
  recursive: () => recursive,
  saveVNodeForInspection: () => saveVNodeForInspection
});
function compose(hook, viewMap) {
  function withHook(stateHook) {
    function ComposedComponent() {
      const state = stateHook();
      if (typeof state === "function") {
        const subComponent = withHook(state);
        return h(subComponent, {});
      }
      const statusName = state.status;
      const viewComponent = viewMap[statusName];
      return h(viewComponent, state);
    }
    return ComposedComponent;
  }
  return (p4) => {
    const h44 = withHook(() => hook(p4));
    return h44();
  };
}
function recursive(hook) {
  function withHook(stateHook) {
    function ComposedComponent() {
      const state = stateHook();
      if (typeof state === "function") {
        const subComponent = withHook(state);
        return h(subComponent, {});
      }
      return state;
    }
    return ComposedComponent;
  }
  return (p4) => {
    const h44 = withHook(() => hook(p4));
    return h44();
  };
}
function saveVNodeForInspection(obj) {
  window["showVNodeInfo"] = function showVNodeInfo() {
    inspect(obj);
  };
  return obj;
}
function inspect(obj) {
  if (!obj)
    return;
  if (obj.__c && obj.__c.__H) {
    const componentName = obj.__c.constructor.name;
    const hookState = obj.__c.__H;
    const stateList = hookState.__;
    console.log("==============", componentName);
    stateList.forEach((hook) => {
      const { __: value, c: context, __h: factory, __H: args } = hook;
      if (typeof context !== "undefined") {
        const { __c: contextId } = context;
        console.log("context:", contextId, hook);
      } else if (typeof factory === "function") {
        console.log("memo:", value, "deps:", args);
      } else if (typeof value === "function") {
        const effectName = value.name;
        console.log("effect:", effectName, "deps:", args);
      } else if (typeof value.current !== "undefined") {
        const ref = value.current;
        console.log("ref:", ref instanceof Element ? ref.outerHTML : ref);
      } else if (value instanceof Array) {
        console.log("state:", value[0]);
      } else {
        console.log(hook);
      }
    });
  }
  const children2 = obj.__k;
  if (children2 instanceof Array) {
    children2.forEach((e23) => inspect(e23));
  } else {
    inspect(children2);
  }
}
function Loading() {
  return /* @__PURE__ */ h(
    "div",
    {
      class: "columns is-centered is-vcentered",
      style: {
        width: "100%",
        height: "200px",
        display: "flex",
        margin: "auto",
        justifyContent: "center"
      }
    },
    /* @__PURE__ */ h(Spinner, null)
  );
}
function Spinner() {
  return /* @__PURE__ */ h("div", { class: "lds-ring", style: { margin: "auto" } }, /* @__PURE__ */ h("div", null), /* @__PURE__ */ h("div", null), /* @__PURE__ */ h("div", null), /* @__PURE__ */ h("div", null));
}
var FormContext = B(void 0);

// src/app.tsx
init_preact_module();
init_hooks_module();

// node_modules/.pnpm/swr@2.0.3_react@18.2.0/node_modules/swr/core/dist/index.mjs
init_compat_module();
var import_shim = __toESM(require_shim(), 1);

// node_modules/.pnpm/swr@2.0.3_react@18.2.0/node_modules/swr/_internal/dist/index.mjs
init_compat_module();
var SWRGlobalState = /* @__PURE__ */ new WeakMap();
var EMPTY_CACHE = {};
var INITIAL_CACHE = {};
var noop = () => {
};
var UNDEFINED = (
  /*#__NOINLINE__*/
  noop()
);
var OBJECT = Object;
var isUndefined = (v3) => v3 === UNDEFINED;
var isFunction = (v3) => typeof v3 == "function";
var mergeObjects = (a4, b3) => ({
  ...a4,
  ...b3
});
var STR_UNDEFINED = "undefined";
var isWindowDefined = typeof window != STR_UNDEFINED;
var isDocumentDefined = typeof document != STR_UNDEFINED;
var hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
var createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev = cache2.get(key);
        if (!(key in INITIAL_CACHE)) {
          INITIAL_CACHE[key] = prev;
        }
        state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => {
      if (!isUndefined(key)) {
        if (key in INITIAL_CACHE)
          return INITIAL_CACHE[key];
      }
      return cache2.get(key) || EMPTY_CACHE;
    }
  ];
};
var table = /* @__PURE__ */ new WeakMap();
var counter = 0;
var stableHash = (arg) => {
  const type2 = typeof arg;
  const constructor = arg && arg.constructor;
  const isDate = constructor == Date;
  let result;
  let index2;
  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
    result = table.get(arg);
    if (result)
      return result;
    result = ++counter + "~";
    table.set(arg, result);
    if (constructor == Array) {
      result = "@";
      for (index2 = 0; index2 < arg.length; index2++) {
        result += stableHash(arg[index2]) + ",";
      }
      table.set(arg, result);
    }
    if (constructor == OBJECT) {
      result = "#";
      const keys = OBJECT.keys(arg).sort();
      while (!isUndefined(index2 = keys.pop())) {
        if (!isUndefined(arg[index2])) {
          result += index2 + ":" + stableHash(arg[index2]) + ",";
        }
      }
      table.set(arg, result);
    }
  } else {
    result = isDate ? arg.toJSON() : type2 == "symbol" ? arg.toString() : type2 == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result;
};
var online = true;
var isOnline = () => online;
var [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop,
  noop
];
var isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
var initFocus = (callback) => {
  if (isDocumentDefined) {
    document.addEventListener("visibilitychange", callback);
  }
  onWindowEvent("focus", callback);
  return () => {
    if (isDocumentDefined) {
      document.removeEventListener("visibilitychange", callback);
    }
    offWindowEvent("focus", callback);
  };
};
var initReconnect = (callback) => {
  const onOnline = () => {
    online = true;
    callback();
  };
  const onOffline = () => {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return () => {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
var preset = {
  isOnline,
  isVisible
};
var defaultConfigOptions = {
  initFocus,
  initReconnect
};
var IS_REACT_LEGACY = !bn.useId;
var IS_SERVER = !isWindowDefined || "Deno" in window;
var rAF = (f3) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f3) : setTimeout(f3, 1);
var useIsomorphicLayoutEffect = IS_SERVER ? h2 : s2;
var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
var slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
var serialize = (key) => {
  if (isFunction(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = key;
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [
    key,
    args
  ];
};
var __timestamp = 0;
var getTimestamp = () => ++__timestamp;
var FOCUS_EVENT = 0;
var RECONNECT_EVENT = 1;
var MUTATE_EVENT = 2;
var constants = {
  __proto__: null,
  FOCUS_EVENT,
  RECONNECT_EVENT,
  MUTATE_EVENT
};
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args;
  const options = mergeObjects({
    populateCache: true,
    throwOnError: true
  }, typeof _opts === "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const revalidate = options.revalidate !== false;
  const rollbackOnError = (error2) => {
    return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error2) : rollbackOnErrorOption !== false;
  };
  const throwOnError = options.throwOnError;
  if (isFunction(_key)) {
    const keyFilter = _key;
    const matchedKeys = [];
    const it2 = cache2.keys();
    for (let keyIt = it2.next(); !keyIt.done; keyIt = it2.next()) {
      const key = keyIt.value;
      if (
        // Skip the special useSWRInfinite keys.
        !key.startsWith("$inf$") && keyFilter(cache2.get(key)._k)
      ) {
        matchedKeys.push(key);
      }
    }
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize(_k);
    if (!key)
      return;
    const [get3, set3] = createCacheHelper(cache2, key);
    const [EVENT_REVALIDATORS, MUTATION, FETCH] = SWRGlobalState.get(cache2);
    const revalidators = EVENT_REVALIDATORS[key];
    const startRevalidate = () => {
      if (revalidate) {
        delete FETCH[key];
        if (revalidators && revalidators[0]) {
          return revalidators[0](MUTATE_EVENT).then(() => get3().data);
        }
      }
      return get3().data;
    };
    if (args.length < 3) {
      return startRevalidate();
    }
    let data = _data;
    let error2;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData);
    const state = get3();
    const displayedData = state.data;
    const currentData = state._c;
    const committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData) {
      optimisticData = isFunction(optimisticData) ? optimisticData(committedData) : optimisticData;
      set3({
        data: optimisticData,
        _c: committedData
      });
    }
    if (isFunction(data)) {
      try {
        data = data(committedData);
      } catch (err) {
        error2 = err;
      }
    }
    if (data && isFunction(data.then)) {
      data = await data.catch((err) => {
        error2 = err;
      });
      if (beforeMutationTs !== MUTATION[key][0]) {
        if (error2)
          throw error2;
        return data;
      } else if (error2 && hasOptimisticData && rollbackOnError(error2)) {
        populateCache = true;
        data = committedData;
        set3({
          data,
          _c: UNDEFINED
        });
      }
    }
    if (populateCache) {
      if (!error2) {
        if (isFunction(populateCache)) {
          data = populateCache(data, committedData);
        }
        set3({
          data,
          _c: UNDEFINED
        });
      }
    }
    MUTATION[key][1] = getTimestamp();
    const res = await startRevalidate();
    set3({
      _c: UNDEFINED
    });
    if (error2) {
      if (throwOnError)
        throw error2;
      return;
    }
    return populateCache ? res : data;
  }
}
var revalidateAllKeys = (revalidators, type2) => {
  for (const key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type2);
  }
};
var initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options);
    const EVENT_REVALIDATORS = {};
    const mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop;
    const subscriptions = {};
    const subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      subscriptions[key] = subs;
      subs.push(callback);
      return () => subs.splice(subs.indexOf(callback), 1);
    };
    const setter = (key, value, prev) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs) {
        for (let i3 = subs.length; i3--; ) {
          subs[i3](value, prev);
        }
      }
    };
    const initProvider = () => {
      if (!SWRGlobalState.has(provider)) {
        SWRGlobalState.set(provider, [
          EVENT_REVALIDATORS,
          {},
          {},
          {},
          mutate2,
          setter,
          subscribe
        ]);
        if (!IS_SERVER) {
          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
          unmount = () => {
            releaseFocus && releaseFocus();
            releaseReconnect && releaseReconnect();
            SWRGlobalState.delete(provider);
          };
        }
      }
    };
    initProvider();
    return [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
};
var onErrorRetry = (_3, __, config, revalidate, opts) => {
  const maxRetryCount = config.errorRetryCount;
  const currentRetryCount = opts.retryCount;
  const timeout2 = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout2, opts);
};
var compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);
var [cache, mutate] = initCache(/* @__PURE__ */ new Map());
var defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop,
    onSuccess: noop,
    onError: noop,
    onErrorRetry,
    onDiscarded: noop,
    // switches
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => false,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
);
var mergeConfigs = (a4, b3) => {
  const v3 = mergeObjects(a4, b3);
  if (b3) {
    const { use: u1, fallback: f1 } = a4;
    const { use: u22, fallback: f22 } = b3;
    if (u1 && u22) {
      v3.use = u1.concat(u22);
    }
    if (f1 && f22) {
      v3.fallback = mergeObjects(f1, f22);
    }
  }
  return v3;
};
var SWRConfigContext = B({});
var SWRConfig = (props) => {
  const { value } = props;
  const parentConfig = q2(SWRConfigContext);
  const isFunctionalConfig = isFunction(value);
  const config = F(() => isFunctionalConfig ? value(parentConfig) : value, [
    isFunctionalConfig,
    parentConfig,
    value
  ]);
  const extendedConfig = F(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [
    isFunctionalConfig,
    parentConfig,
    config
  ]);
  const provider = config && config.provider;
  const [cacheContext] = p3(() => provider ? initCache(provider(extendedConfig.cache || cache), config) : UNDEFINED);
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(() => {
    if (cacheContext) {
      cacheContext[2] && cacheContext[2]();
      return cacheContext[3];
    }
  }, []);
  return h(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};
var enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
var use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
var setupDevTools = () => {
  if (enableDevtools) {
    window.__SWR_DEVTOOLS_REACT__ = bn;
  }
};
var normalize = (args) => {
  return isFunction(args[1]) ? [
    args[0],
    args[1],
    args[2] || {}
  ] : [
    args[0],
    null,
    (args[1] === null ? args[2] : args[1]) || {}
  ];
};
var useSWRConfig = () => {
  return mergeObjects(defaultConfig, q2(SWRConfigContext));
};
var middleware = (useSWRNext) => (key_, fetcher_, config) => {
  const fetcher = fetcher_ && ((...args) => {
    const key = serialize(key_)[0];
    const [, , , PRELOAD] = SWRGlobalState.get(cache);
    const req = PRELOAD[key];
    if (req) {
      delete PRELOAD[key];
      return req;
    }
    return fetcher_(...args);
  });
  return useSWRNext(key_, fetcher, config);
};
var BUILT_IN_MIDDLEWARE = use.concat(middleware);
var withArgs = (hook) => {
  return function useSWRArgs(...args) {
    const fallbackConfig = useSWRConfig();
    const [key, fn2, _config] = normalize(args);
    const config = mergeConfigs(fallbackConfig, _config);
    let next = hook;
    const { use: use2 } = config;
    const middleware2 = (use2 || []).concat(BUILT_IN_MIDDLEWARE);
    for (let i3 = middleware2.length; i3--; ) {
      next = middleware2[i3](next);
    }
    return next(key, fn2 || config.fetcher || null, config);
  };
};
var subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return () => {
    const index2 = keyedRevalidators.indexOf(callback);
    if (index2 >= 0) {
      keyedRevalidators[index2] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
setupDevTools();

// node_modules/.pnpm/swr@2.0.3_react@18.2.0/node_modules/swr/core/dist/index.mjs
var WITH_DEDUPE = {
  dedupe: true
};
var useSWRHandler = (_key, fetcher, config) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;
  const [EVENT_REVALIDATORS, MUTATION, FETCH] = SWRGlobalState.get(cache2);
  const [key, fnArg] = serialize(_key);
  const initialMountedRef = _2(false);
  const unmountedRef = _2(false);
  const keyRef = _2(key);
  const fetcherRef = _2(fetcher);
  const configRef = _2(config);
  const getConfig = () => configRef.current;
  const isActive = () => getConfig().isVisible() && getConfig().isOnline();
  const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
  const stateDependencies = _2({}).current;
  const fallback = isUndefined(fallbackData) ? config.fallback[key] : fallbackData;
  const isEqual = (prev, current) => {
    let equal = true;
    for (const _3 in stateDependencies) {
      const t4 = _3;
      if (t4 === "data") {
        if (!compare2(current[t4], prev[t4])) {
          if (isUndefined(prev[t4])) {
            if (!compare2(current[t4], returnedData)) {
              equal = false;
            }
          } else {
            equal = false;
          }
        }
      } else {
        if (current[t4] !== prev[t4]) {
          equal = false;
        }
      }
    }
    return equal;
  };
  const getSnapshot = F(() => {
    const shouldStartRequest = (() => {
      if (!key)
        return false;
      if (!fetcher)
        return false;
      if (!isUndefined(revalidateOnMount))
        return revalidateOnMount;
      if (getConfig().isPaused())
        return false;
      if (suspense)
        return false;
      if (!isUndefined(revalidateIfStale))
        return revalidateIfStale;
      return true;
    })();
    const getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      delete snapshot._k;
      if (!shouldStartRequest) {
        return snapshot;
      }
      return {
        isValidating: true,
        isLoading: true,
        ...snapshot
      };
    };
    let memorizedSnapshot = getSelectedCache(getCache());
    const memorizedInitialSnapshot = getSelectedCache(getInitialCache());
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache());
        return isEqual(newSnapshot, memorizedSnapshot) ? memorizedSnapshot : memorizedSnapshot = newSnapshot;
      },
      () => memorizedInitialSnapshot
    ];
  }, [
    cache2,
    key
  ]);
  const cached = (0, import_shim.useSyncExternalStore)(T2(
    (callback) => subscribeCache(key, (current, prev) => {
      if (!isEqual(prev, current))
        callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]);
  const isInitialMount = !initialMountedRef.current;
  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
  const cachedData = cached.data;
  const data = isUndefined(cachedData) ? fallback : cachedData;
  const error2 = cached.error;
  const laggyDataRef = _2(data);
  const returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data;
  const shouldDoInitialRevalidation = (() => {
    if (hasRevalidator && !isUndefined(error2))
      return false;
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : revalidateIfStale;
    return isUndefined(data) || revalidateIfStale;
  })();
  const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);
  const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
  const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
  const revalidate = T2(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
        return false;
      }
      let newData;
      let startAt;
      let loading = true;
      const opts = revalidateOpts || {};
      const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
      const callbackSafeguard = () => {
        if (IS_REACT_LEGACY) {
          return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
        }
        return key === keyRef.current;
      };
      const finalState = {
        isValidating: false,
        isLoading: false
      };
      const finishRequestAndUpdateState = () => {
        setCache(finalState);
      };
      const cleanupState = () => {
        const requestInfo = FETCH[key];
        if (requestInfo && requestInfo[1] === startAt) {
          delete FETCH[key];
        }
      };
      const initialState = {
        isValidating: true
      };
      if (isUndefined(getCache().data)) {
        initialState.isLoading = true;
      }
      try {
        if (shouldStartNewRequest) {
          setCache(initialState);
          if (config.loadingTimeout && isUndefined(getCache().data)) {
            setTimeout(() => {
              if (loading && callbackSafeguard()) {
                getConfig().onLoadingSlow(key, config);
              }
            }, config.loadingTimeout);
          }
          FETCH[key] = [
            currentFetcher(fnArg),
            getTimestamp()
          ];
        }
        [newData, startAt] = FETCH[key];
        newData = await newData;
        if (shouldStartNewRequest) {
          setTimeout(cleanupState, config.dedupingInterval);
        }
        if (!FETCH[key] || FETCH[key][1] !== startAt) {
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0)) {
          finishRequestAndUpdateState();
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        const cacheData = getCache().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData;
        if (shouldStartNewRequest) {
          if (callbackSafeguard()) {
            getConfig().onSuccess(newData, key, config);
          }
        }
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig();
        const { shouldRetryOnError } = currentConfig;
        if (!currentConfig.isPaused()) {
          finalState.error = err;
          if (shouldStartNewRequest && callbackSafeguard()) {
            currentConfig.onError(err, key, currentConfig);
            if (shouldRetryOnError === true || isFunction(shouldRetryOnError) && shouldRetryOnError(err)) {
              if (isActive()) {
                currentConfig.onErrorRetry(err, key, currentConfig, revalidate, {
                  retryCount: (opts.retryCount || 0) + 1,
                  dedupe: true
                });
              }
            }
          }
        }
      }
      loading = false;
      finishRequestAndUpdateState();
      return true;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  );
  const boundMutate = T2(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => {
      return internalMutate(cache2, keyRef.current, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher;
    configRef.current = config;
    if (!isUndefined(cachedData)) {
      laggyDataRef.current = cachedData;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (!key)
      return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    const onRevalidate = (type2) => {
      if (type2 == constants.FOCUS_EVENT) {
        const now2 = Date.now();
        if (getConfig().revalidateOnFocus && now2 > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now2 + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type2 == constants.RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type2 == constants.MUTATE_EVENT) {
        return revalidate();
      }
      return;
    };
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    setCache({
      _k: fnArg
    });
    if (shouldDoInitialRevalidation) {
      if (isUndefined(data) || IS_SERVER) {
        softRevalidate();
      } else {
        rAF(softRevalidate);
      }
    }
    return () => {
      unmountedRef.current = true;
      unsubEvents();
    };
  }, [
    key
  ]);
  useIsomorphicLayoutEffect(() => {
    let timer3;
    function next() {
      const interval2 = isFunction(refreshInterval) ? refreshInterval(data) : refreshInterval;
      if (interval2 && timer3 !== -1) {
        timer3 = setTimeout(execute, interval2);
      }
    }
    function execute() {
      if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next);
      } else {
        next();
      }
    }
    next();
    return () => {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = -1;
      }
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]);
  x2(returnedData);
  if (suspense && isUndefined(data) && key) {
    if (!IS_REACT_LEGACY && IS_SERVER) {
      throw new Error("Fallback data is required when using suspense in SSR.");
    }
    fetcherRef.current = fetcher;
    configRef.current = config;
    unmountedRef.current = false;
    throw isUndefined(error2) ? revalidate(WITH_DEDUPE) : error2;
  }
  return {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return returnedData;
    },
    get error() {
      stateDependencies.error = true;
      return error2;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    },
    get isLoading() {
      stateDependencies.isLoading = true;
      return isLoading;
    }
  };
};
var SWRConfig2 = OBJECT.defineProperty(SWRConfig, "defaultValue", {
  value: defaultConfig
});
var useSWR = withArgs(useSWRHandler);

// src/Routing.tsx
init_preact_module();
init_hooks_module();

// src/Home.tsx
init_preact_module();

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js
function ascending(a4, b3) {
  return a4 == null || b3 == null ? NaN : a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/descending.js
function descending(a4, b3) {
  return a4 == null || b3 == null ? NaN : b3 < a4 ? -1 : b3 > a4 ? 1 : b3 >= a4 ? 0 : NaN;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisector.js
function bisector(f3) {
  let compare1, compare2, delta;
  if (f3.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x6) => ascending(f3(d3), x6);
    delta = (d3, x6) => f3(d3) - x6;
  } else {
    compare1 = f3 === ascending || f3 === descending ? f3 : zero;
    compare2 = f3;
    delta = f3;
  }
  function left2(a4, x6, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x6) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a4, x6, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x6, x6) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x6) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x6, lo = 0, hi = a4.length) {
    const i3 = left2(a4, x6, lo, hi - 1);
    return i3 > lo && delta(a4[i3 - 1], x6) > -delta(a4[i3], x6) ? i3 - 1 : i3;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/number.js
function number(x6) {
  return x6 === null ? NaN : +x6;
}
function* numbers(values2, valueof2) {
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/count.js
function count(values2, valueof2) {
  let count2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cross.js
function length(array2) {
  return array2.length | 0;
}
function empty(length3) {
  return !(length3 > 0);
}
function arrayify(values2) {
  return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
}
function reducer(reduce2) {
  return (values2) => reduce2(...values2);
}
function cross(...values2) {
  const reduce2 = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
  values2 = values2.map(arrayify);
  const lengths = values2.map(length);
  const j4 = values2.length - 1;
  const index2 = new Array(j4 + 1).fill(0);
  const product = [];
  if (j4 < 0 || lengths.some(empty))
    return product;
  while (true) {
    product.push(index2.map((j5, i4) => values2[i4][j5]));
    let i3 = j4;
    while (++index2[i3] === lengths[i3]) {
      if (i3 === 0)
        return reduce2 ? product.map(reduce2) : product;
      index2[i3--] = 0;
    }
  }
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cumsum.js
function cumsum(values2, valueof2) {
  var sum2 = 0, index2 = 0;
  return Float64Array.from(values2, valueof2 === void 0 ? (v3) => sum2 += +v3 || 0 : (v3) => sum2 += +valueof2(v3, index2++, values2) || 0);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/variance.js
function variance(values2, valueof2) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  }
  if (count2 > 1)
    return sum2 / (count2 - 1);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/deviation.js
function deviation(values2, valueof2) {
  const v3 = variance(values2, valueof2);
  return v3 ? Math.sqrt(v3) : v3;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/extent.js
function extent(values2, valueof2) {
  let min4;
  let max3;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max3 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max3 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  }
  return [min4, max3];
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x6) {
    const p4 = this._partials;
    let i3 = 0;
    for (let j4 = 0; j4 < this._n && j4 < 32; j4++) {
      const y4 = p4[j4], hi = x6 + y4, lo = Math.abs(x6) < Math.abs(y4) ? x6 - (hi - y4) : y4 - (hi - x6);
      if (lo)
        p4[i3++] = lo;
      x6 = hi;
    }
    p4[i3] = x6;
    this._n = i3 + 1;
    return this;
  }
  valueOf() {
    const p4 = this._partials;
    let n2 = this._n, x6, y4, lo, hi = 0;
    if (n2 > 0) {
      hi = p4[--n2];
      while (n2 > 0) {
        x6 = hi;
        y4 = p4[--n2];
        hi = x6 + y4;
        lo = y4 - (hi - x6);
        if (lo)
          break;
      }
      if (n2 > 0 && (lo < 0 && p4[n2 - 1] < 0 || lo > 0 && p4[n2 - 1] > 0)) {
        y4 = lo * 2;
        x6 = hi + y4;
        if (y4 == x6 - hi)
          hi = x6;
      }
    }
    return hi;
  }
};

// node_modules/.pnpm/internmap@2.0.3/node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values2, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values2 != null)
      for (const value of values2)
        this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/identity.js
function identity(x6) {
  return x6;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/group.js
function group(values2, ...keys) {
  return nest(values2, identity, identity, keys);
}
function rollup(values2, reduce2, ...keys) {
  return nest(values2, identity, reduce2, keys);
}
function rollups(values2, reduce2, ...keys) {
  return nest(values2, Array.from, reduce2, keys);
}
function nest(values2, map4, reduce2, keys) {
  return function regroup(values3, i3) {
    if (i3 >= keys.length)
      return reduce2(values3);
    const groups2 = new InternMap();
    const keyof3 = keys[i3++];
    let index2 = -1;
    for (const value of values3) {
      const key = keyof3(value, ++index2, values3);
      const group2 = groups2.get(key);
      if (group2)
        group2.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values4] of groups2) {
      groups2.set(key, regroup(values4, i3));
    }
    return map4(groups2);
  }(values2, 0);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sort.js
function sort(values2, ...F3) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values2 = Array.from(values2);
  let [f3] = F3;
  if (f3 && f3.length !== 2 || F3.length > 1) {
    const index2 = Uint32Array.from(values2, (d3, i3) => i3);
    if (F3.length > 1) {
      F3 = F3.map((f4) => values2.map(f4));
      index2.sort((i3, j4) => {
        for (const f4 of F3) {
          const c6 = ascendingDefined(f4[i3], f4[j4]);
          if (c6)
            return c6;
        }
      });
    } else {
      f3 = values2.map(f3);
      index2.sort((i3, j4) => ascendingDefined(f3[i3], f3[j4]));
    }
    return permute(values2, index2);
  }
  return values2.sort(compareDefined(f3));
}
function compareDefined(compare2 = ascending) {
  if (compare2 === ascending)
    return ascendingDefined;
  if (typeof compare2 !== "function")
    throw new TypeError("compare is not a function");
  return (a4, b3) => {
    const x6 = compare2(a4, b3);
    if (x6 || x6 === 0)
      return x6;
    return (compare2(b3, b3) === 0) - (compare2(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b3) {
  return (a4 == null || !(a4 >= a4)) - (b3 == null || !(b3 >= b3)) || (a4 < b3 ? -1 : a4 > b3 ? 1 : 0);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/groupSort.js
function groupSort(values2, reduce2, key) {
  return (reduce2.length !== 2 ? sort(rollup(values2, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e22 ? 2 : 1;
  let i1, i22, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i22 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i22 / inc > stop)
      --i22;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i22 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i22 * inc > stop)
      --i22;
  }
  if (i22 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start2, stop, count2 * 2);
  return [i1, i22, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse2 = stop < start2, [i1, i22, inc] = reverse2 ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i22 >= i1))
    return [];
  const n2 = i22 - i1 + 1, ticks2 = new Array(n2);
  if (reverse2) {
    if (inc < 0)
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i22 - i3) / -inc;
    else
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i22 - i3) * inc;
  } else {
    if (inc < 0)
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i1 + i3) / -inc;
    else
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse2 = stop < start2, inc = reverse2 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values2) {
  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js
function max(values2, valueof2) {
  let max3;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/maxIndex.js
function maxIndex(values2, valueof2) {
  let max3;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value, maxIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js
function min(values2, valueof2) {
  let min4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/minIndex.js
function minIndex(values2, valueof2) {
  let min4;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quickselect.js
function quickselect(array2, k5, left2 = 0, right2 = Infinity, compare2) {
  k5 = Math.floor(k5);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k5 && k5 <= right2))
    return array2;
  compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n2 = right2 - left2 + 1;
      const m3 = k5 - left2 + 1;
      const z4 = Math.log(n2);
      const s4 = 0.5 * Math.exp(2 * z4 / 3);
      const sd = 0.5 * Math.sqrt(z4 * s4 * (n2 - s4) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k5 - m3 * s4 / n2 + sd));
      const newRight = Math.min(right2, Math.floor(k5 + (n2 - m3) * s4 / n2 + sd));
      quickselect(array2, k5, newLeft, newRight, compare2);
    }
    const t4 = array2[k5];
    let i3 = left2;
    let j4 = right2;
    swap(array2, left2, k5);
    if (compare2(array2[right2], t4) > 0)
      swap(array2, left2, right2);
    while (i3 < j4) {
      swap(array2, i3, j4), ++i3, --j4;
      while (compare2(array2[i3], t4) < 0)
        ++i3;
      while (compare2(array2[j4], t4) > 0)
        --j4;
    }
    if (compare2(array2[left2], t4) === 0)
      swap(array2, left2, j4);
    else
      ++j4, swap(array2, j4, right2);
    if (j4 <= k5)
      left2 = j4 + 1;
    if (k5 <= j4)
      right2 = j4 - 1;
  }
  return array2;
}
function swap(array2, i3, j4) {
  const t4 = array2[i3];
  array2[i3] = array2[j4];
  array2[j4] = t4;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/greatest.js
function greatest(values2, compare2 = ascending) {
  let max3;
  let defined2 = false;
  if (compare2.length === 1) {
    let maxValue;
    for (const element of values2) {
      const value = compare2(element);
      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
        max3 = element;
        maxValue = value;
        defined2 = true;
      }
    }
  } else {
    for (const value of values2) {
      if (defined2 ? compare2(value, max3) > 0 : compare2(value, value) === 0) {
        max3 = value;
        defined2 = true;
      }
    }
  }
  return max3;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quantile.js
function quantile(values2, p4, valueof2) {
  values2 = Float64Array.from(numbers(values2, valueof2));
  if (!(n2 = values2.length) || isNaN(p4 = +p4))
    return;
  if (p4 <= 0 || n2 < 2)
    return min(values2);
  if (p4 >= 1)
    return max(values2);
  var n2, i3 = (n2 - 1) * p4, i0 = Math.floor(i3), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i3 - i0);
}
function quantileSorted(values2, p4, valueof2 = number) {
  if (!(n2 = values2.length) || isNaN(p4 = +p4))
    return;
  if (p4 <= 0 || n2 < 2)
    return +valueof2(values2[0], 0, values2);
  if (p4 >= 1)
    return +valueof2(values2[n2 - 1], n2 - 1, values2);
  var n2, i3 = (n2 - 1) * p4, i0 = Math.floor(i3), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i3 - i0);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values2, min4, max3) {
  const c6 = count(values2), d3 = quantile(values2, 0.75) - quantile(values2, 0.25);
  return c6 && d3 ? Math.ceil((max3 - min4) / (2 * d3 * Math.pow(c6, -1 / 3))) : 1;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values2, min4, max3) {
  const c6 = count(values2), d3 = deviation(values2);
  return c6 && d3 ? Math.ceil((max3 - min4) * Math.cbrt(c6) / (3.49 * d3)) : 1;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mean.js
function mean(values2, valueof2) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  }
  if (count2)
    return sum2 / count2;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/median.js
function median(values2, valueof2) {
  return quantile(values2, 0.5, valueof2);
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mode.js
function mode(values2, valueof2) {
  const counts = new InternMap();
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count2] of counts) {
    if (count2 > modeCount) {
      modeCount = count2;
      modeValue = value;
    }
  }
  return modeValue;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/pairs.js
function pairs(values2, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first2 = false;
  for (const value of values2) {
    if (first2)
      pairs2.push(pairof(previous, value));
    previous = value;
    first2 = true;
  }
  return pairs2;
}
function pair(a4, b3) {
  return [a4, b3];
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step;
  var i3 = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n2);
  while (++i3 < n2) {
    range3[i3] = start2 + i3 * step;
  }
  return range3;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sum.js
function sum(values2, valueof2) {
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value = +value) {
        sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if (value = +valueof2(value, ++index2, values2)) {
        sum2 += value;
      }
    }
  }
  return sum2;
}

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/reverse.js
function reverse(values2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  return Array.from(values2).reverse();
}

// node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/identity.js
function identity_default(x6) {
  return x6;
}

// node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x6) {
  return "translate(" + x6 + ",0)";
}
function translateY(y4) {
  return "translate(0," + y4 + ")";
}
function number2(scale) {
  return (d3) => +scale(d3);
}
function center(scale, offset2) {
  offset2 = Math.max(0, scale.bandwidth() - offset2 * 2) / 2;
  if (scale.round())
    offset2 = Math.round(offset2);
  return (d3) => +scale(d3) + offset2;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k5 = orient === top || orient === left ? -1 : 1, x6 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format3 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale.range(), range0 = +range3[0] + offset2, range1 = +range3[range3.length - 1] + offset2, position2 = (scale.bandwidth ? center : number2)(scale.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x6 + "2", k5 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x6, k5 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d3) {
        return isFinite(d3 = position2(d3)) ? transform2(d3 + offset2) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d3) {
        var p4 = this.parentNode.__axis;
        return transform2((p4 && isFinite(p4 = p4(d3)) ? p4 : position2(d3)) + offset2);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k5 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k5 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k5 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k5 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d3) {
      return transform2(position2(d3) + offset2);
    });
    line2.attr(x6 + "2", k5 * tickSizeInner);
    text2.attr(x6, k5 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_3) {
    return arguments.length ? (scale = _3, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_3) {
    return arguments.length ? (tickArguments = _3 == null ? [] : Array.from(_3), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_3) {
    return arguments.length ? (tickValues = _3 == null ? null : Array.from(_3), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_3) {
    return arguments.length ? (tickFormat2 = _3, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_3) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_3, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_3) {
    return arguments.length ? (tickSizeInner = +_3, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_3) {
    return arguments.length ? (tickSizeOuter = +_3, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_3) {
    return arguments.length ? (tickPadding = +_3, axis2) : tickPadding;
  };
  axis2.offset = function(_3) {
    return arguments.length ? (offset2 = +_3, axis2) : offset2;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}

// node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i3 = 0, n2 = arguments.length, _3 = {}, t4; i3 < n2; ++i3) {
    if (!(t4 = arguments[i3] + "") || t4 in _3 || /[\s.]/.test(t4))
      throw new Error("illegal type: " + t4);
    _3[t4] = [];
  }
  return new Dispatch(_3);
}
function Dispatch(_3) {
  this._ = _3;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    if (t4 && !types.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    return { type: t4, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _3 = this._, T4 = parseTypenames(typename + "", _3), t4, i3 = -1, n2 = T4.length;
    if (arguments.length < 2) {
      while (++i3 < n2)
        if ((t4 = (typename = T4[i3]).type) && (t4 = get(_3[t4], typename.name)))
          return t4;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i3 < n2) {
      if (t4 = (typename = T4[i3]).type)
        _3[t4] = set(_3[t4], typename.name, callback);
      else if (callback == null)
        for (t4 in _3)
          _3[t4] = set(_3[t4], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _3 = this._;
    for (var t4 in _3)
      copy3[t4] = _3[t4].slice();
    return new Dispatch(copy3);
  },
  call: function(type2, that) {
    if ((n2 = arguments.length - 2) > 0)
      for (var args = new Array(n2), i3 = 0, n2, t4; i3 < n2; ++i3)
        args[i3] = arguments[i3 + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t4 = this._[type2], i3 = 0, n2 = t4.length; i3 < n2; ++i3)
      t4[i3].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t4 = this._[type2], i3 = 0, n2 = t4.length; i3 < n2; ++i3)
      t4[i3].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i3 = 0, n2 = type2.length, c6; i3 < n2; ++i3) {
    if ((c6 = type2[i3]).name === name) {
      return c6.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i3 = 0, n2 = type2.length; i3 < n2; ++i3) {
    if (type2[i3].name === name) {
      type2[i3] = noop2, type2 = type2.slice(0, i3).concat(type2.slice(i3 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i3 = prefix.indexOf(":");
  if (i3 >= 0 && (prefix = name.slice(0, i3)) !== "xmlns")
    name = name.slice(i3 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, subgroup = subgroups[j4] = new Array(n2), node, subnode, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && (subnode = select.call(node, node.__data__, i3, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/array.js
function array(x6) {
  return x6 == null ? [] : Array.isArray(x6) ? x6 : Array.from(x6);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        subgroups.push(select.call(node, node.__data__, i3, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match5) {
  return function() {
    return find.call(this.children, match5);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match5) {
  return this.select(match5 == null ? childFirst : childFind(typeof match5 === "function" ? match5 : childMatcher(match5)));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match5) {
  return function() {
    return filter.call(this.children, match5);
  };
}
function selectChildren_default(match5) {
  return this.selectAll(match5 == null ? children : childrenFilter(typeof match5 === "function" ? match5 : childMatcher(match5)));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/filter.js
function filter_default(match5) {
  if (typeof match5 !== "function")
    match5 = matcher_default(match5);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, subgroup = subgroups[j4] = [], node, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && match5.call(node, node.__data__, i3, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/constant.js
function constant_default(x6) {
  return function() {
    return x6;
  };
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group2, enter, update, exit, data) {
  var i3 = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i3 < dataLength; ++i3) {
    if (node = group2[i3]) {
      node.__data__ = data[i3];
      update[i3] = node;
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (; i3 < groupLength; ++i3) {
    if (node = group2[i3]) {
      exit[i3] = node;
    }
  }
}
function bindKey(parent, group2, enter, update, exit, data, key) {
  var i3, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i3 = 0; i3 < groupLength; ++i3) {
    if (node = group2[i3]) {
      keyValues[i3] = keyValue = key.call(node, node.__data__, i3, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i3] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i3 = 0; i3 < dataLength; ++i3) {
    keyValue = key.call(parent, data[i3], i3, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i3] = node;
      node.__data__ = data[i3];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (i3 = 0; i3 < groupLength; ++i3) {
    if ((node = group2[i3]) && nodeByKeyValue.get(keyValues[i3]) === node) {
      exit[i3] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    var parent = parents[j4], group2 = groups2[j4], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j4, parents)), dataLength = data.length, enterGroup = enter[j4] = new Array(dataLength), updateGroup = update[j4] = new Array(dataLength), exitGroup = exit[j4] = new Array(groupLength);
    bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j4 = 0; j4 < m3; ++j4) {
    for (var group0 = groups0[j4], group1 = groups1[j4], n2 = group0.length, merge2 = merges[j4] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge2[i3] = node;
      }
    }
  }
  for (; j4 < m0; ++j4) {
    merges[j4] = groups0[j4];
  }
  return new Selection(merges, this._parents);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j4 = -1, m3 = groups2.length; ++j4 < m3; ) {
    for (var group2 = groups2[j4], i3 = group2.length - 1, next = group2[i3], node; --i3 >= 0; ) {
      if (node = group2[i3]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sort.js
function sort_default(compare2) {
  if (!compare2)
    compare2 = ascending2;
  function compareNode(a4, b3) {
    return a4 && b3 ? compare2(a4.__data__, b3.__data__) : !a4 - !b3;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, sortgroup = sortgroups[j4] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        sortgroup[i3] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a4, b3) {
  return a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j4 = 0, m3 = groups2.length; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], i3 = 0, n2 = group2.length; i3 < n2; ++i3) {
      var node = group2[i3];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j4 = 0, m3 = groups2.length; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], i3 = 0, n2 = group2.length, node; i3 < n2; ++i3) {
      if (node = group2[i3])
        callback.call(node, node.__data__, i3, group2);
    }
  }
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v3);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v3);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v3, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      delete this[name];
    else
      this[name] = v3;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 >= 0) {
      this._names.splice(i3, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i3 = -1, n2 = names.length;
  while (++i3 < n2)
    list.add(names[i3]);
}
function classedRemove(node, names) {
  var list = classList(node), i3 = -1, n2 = names.length;
  while (++i3 < n2)
    list.remove(names[i3]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i3 = -1, n2 = names.length;
    while (++i3 < n2)
      if (!list.contains(names[i3]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.textContent = v3 == null ? "" : v3;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.innerHTML = v3 == null ? "" : v3;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create3 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before2) {
  var create3 = typeof name === "function" ? name : creator_default(name), select = before2 == null ? constantNull : typeof before2 === "function" ? before2 : selector_default(before2);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    return { type: t4, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j4 = 0, i3 = -1, m3 = on2.length, o3; j4 < m3; ++j4) {
      if (o3 = on2[j4], (!typename.type || o3.type === typename.type) && o3.name === typename.name) {
        this.removeEventListener(o3.type, o3.listener, o3.options);
      } else {
        on2[++i3] = o3;
      }
    }
    if (++i3)
      on2.length = i3;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o3, listener = contextListener(value);
    if (on2)
      for (var j4 = 0, m3 = on2.length; j4 < m3; ++j4) {
        if ((o3 = on2[j4]).type === typename.type && o3.name === typename.name) {
          this.removeEventListener(o3.type, o3.listener, o3.options);
          this.addEventListener(o3.type, o3.listener = listener, o3.options = options);
          o3.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o3 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on2)
      this.__on = [o3];
    else
      on2.push(o3);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i3, n2 = typenames.length, t4;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j4 = 0, m3 = on2.length, o3; j4 < m3; ++j4) {
        for (i3 = 0, o3 = on2[j4]; i3 < n2; ++i3) {
          if ((t4 = typenames[i3]).type === o3.type && t4.name === o3.name) {
            return o3.value;
          }
        }
      }
    return;
  }
  on2 = value ? onAdd : onRemove;
  for (i3 = 0; i3 < n2; ++i3)
    this.each(on2(typenames[i3], value, options));
  return this;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j4 = 0, m3 = groups2.length; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], i3 = 0, n2 = group2.length, node; i3 < n2; ++i3) {
      if (node = group2[i3])
        yield node;
    }
  }
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point6 = svg.createSVGPoint();
      point6.x = event.clientX, point6.y = event.clientY;
      point6 = point6.matrixTransform(node.getScreenCTM().inverse());
      return [point6.x, point6.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l3;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l3 = m3[1].length, m3 = parseInt(m3[1], 16), l3 === 6 ? rgbn(m3) : l3 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l3 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l3 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r3, g4, b3, a4) {
  if (a4 <= 0)
    r3 = g4 = b3 = NaN;
  return new Rgb(r3, g4, b3, a4);
}
function rgbConvert(o3) {
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Rgb();
  o3 = o3.rgb();
  return new Rgb(o3.r, o3.g, o3.b, o3.opacity);
}
function rgb(r3, g4, b3, opacity2) {
  return arguments.length === 1 ? rgbConvert(r3) : new Rgb(r3, g4, b3, opacity2 == null ? 1 : opacity2);
}
function Rgb(r3, g4, b3, opacity2) {
  this.r = +r3;
  this.g = +g4;
  this.b = +b3;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k5) {
    k5 = k5 == null ? brighter : Math.pow(brighter, k5);
    return new Rgb(this.r * k5, this.g * k5, this.b * k5, this.opacity);
  },
  darker(k5) {
    k5 = k5 == null ? darker : Math.pow(darker, k5);
    return new Rgb(this.r * k5, this.g * k5, this.b * k5, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h3, s4, l3, a4) {
  if (a4 <= 0)
    h3 = s4 = l3 = NaN;
  else if (l3 <= 0 || l3 >= 1)
    h3 = s4 = NaN;
  else if (s4 <= 0)
    h3 = NaN;
  return new Hsl(h3, s4, l3, a4);
}
function hslConvert(o3) {
  if (o3 instanceof Hsl)
    return new Hsl(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Hsl();
  if (o3 instanceof Hsl)
    return o3;
  o3 = o3.rgb();
  var r3 = o3.r / 255, g4 = o3.g / 255, b3 = o3.b / 255, min4 = Math.min(r3, g4, b3), max3 = Math.max(r3, g4, b3), h3 = NaN, s4 = max3 - min4, l3 = (max3 + min4) / 2;
  if (s4) {
    if (r3 === max3)
      h3 = (g4 - b3) / s4 + (g4 < b3) * 6;
    else if (g4 === max3)
      h3 = (b3 - r3) / s4 + 2;
    else
      h3 = (r3 - g4) / s4 + 4;
    s4 /= l3 < 0.5 ? max3 + min4 : 2 - max3 - min4;
    h3 *= 60;
  } else {
    s4 = l3 > 0 && l3 < 1 ? 0 : h3;
  }
  return new Hsl(h3, s4, l3, o3.opacity);
}
function hsl(h3, s4, l3, opacity2) {
  return arguments.length === 1 ? hslConvert(h3) : new Hsl(h3, s4, l3, opacity2 == null ? 1 : opacity2);
}
function Hsl(h3, s4, l3, opacity2) {
  this.h = +h3;
  this.s = +s4;
  this.l = +l3;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k5) {
    k5 = k5 == null ? brighter : Math.pow(brighter, k5);
    return new Hsl(this.h, this.s, this.l * k5, this.opacity);
  },
  darker(k5) {
    k5 = k5 == null ? darker : Math.pow(darker, k5);
    return new Hsl(this.h, this.s, this.l * k5, this.opacity);
  },
  rgb() {
    var h3 = this.h % 360 + (this.h < 0) * 360, s4 = isNaN(h3) || isNaN(this.s) ? 0 : this.s, l3 = this.l, m22 = l3 + (l3 < 0.5 ? l3 : 1 - l3) * s4, m1 = 2 * l3 - m22;
    return new Rgb(
      hsl2rgb(h3 >= 240 ? h3 - 240 : h3 + 120, m1, m22),
      hsl2rgb(h3, m1, m22),
      hsl2rgb(h3 < 120 ? h3 + 240 : h3 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h3, m1, m22) {
  return (h3 < 60 ? m1 + (m22 - m1) * h3 / 60 : h3 < 180 ? m22 : h3 < 240 ? m1 + (m22 - m1) * (240 - h3) / 60 : m1) * 255;
}

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/lab.js
var K4 = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t22 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o3) {
  if (o3 instanceof Lab)
    return new Lab(o3.l, o3.a, o3.b, o3.opacity);
  if (o3 instanceof Hcl)
    return hcl2lab(o3);
  if (!(o3 instanceof Rgb))
    o3 = rgbConvert(o3);
  var r3 = rgb2lrgb(o3.r), g4 = rgb2lrgb(o3.g), b3 = rgb2lrgb(o3.b), y4 = xyz2lab((0.2225045 * r3 + 0.7168786 * g4 + 0.0606169 * b3) / Yn), x6, z4;
  if (r3 === g4 && g4 === b3)
    x6 = z4 = y4;
  else {
    x6 = xyz2lab((0.4360747 * r3 + 0.3850649 * g4 + 0.1430804 * b3) / Xn);
    z4 = xyz2lab((0.0139322 * r3 + 0.0971045 * g4 + 0.7141733 * b3) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x6 - y4), 200 * (y4 - z4), o3.opacity);
}
function lab(l3, a4, b3, opacity2) {
  return arguments.length === 1 ? labConvert(l3) : new Lab(l3, a4, b3, opacity2 == null ? 1 : opacity2);
}
function Lab(l3, a4, b3, opacity2) {
  this.l = +l3;
  this.a = +a4;
  this.b = +b3;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend(Color, {
  brighter(k5) {
    return new Lab(this.l + K4 * (k5 == null ? 1 : k5), this.a, this.b, this.opacity);
  },
  darker(k5) {
    return new Lab(this.l - K4 * (k5 == null ? 1 : k5), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x6 = isNaN(this.a) ? y4 : y4 + this.a / 500, z4 = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x6 = Xn * lab2xyz(x6);
    y4 = Yn * lab2xyz(y4);
    z4 = Zn * lab2xyz(z4);
    return new Rgb(
      lrgb2rgb(3.1338561 * x6 - 1.6168667 * y4 - 0.4906146 * z4),
      lrgb2rgb(-0.9787684 * x6 + 1.9161415 * y4 + 0.033454 * z4),
      lrgb2rgb(0.0719453 * x6 - 0.2289914 * y4 + 1.4052427 * z4),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t22 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t22 * (t4 - t0);
}
function lrgb2rgb(x6) {
  return 255 * (x6 <= 31308e-7 ? 12.92 * x6 : 1.055 * Math.pow(x6, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x6) {
  return (x6 /= 255) <= 0.04045 ? x6 / 12.92 : Math.pow((x6 + 0.055) / 1.055, 2.4);
}
function hclConvert(o3) {
  if (o3 instanceof Hcl)
    return new Hcl(o3.h, o3.c, o3.l, o3.opacity);
  if (!(o3 instanceof Lab))
    o3 = labConvert(o3);
  if (o3.a === 0 && o3.b === 0)
    return new Hcl(NaN, 0 < o3.l && o3.l < 100 ? 0 : NaN, o3.l, o3.opacity);
  var h3 = Math.atan2(o3.b, o3.a) * degrees;
  return new Hcl(h3 < 0 ? h3 + 360 : h3, Math.sqrt(o3.a * o3.a + o3.b * o3.b), o3.l, o3.opacity);
}
function hcl(h3, c6, l3, opacity2) {
  return arguments.length === 1 ? hclConvert(h3) : new Hcl(h3, c6, l3, opacity2 == null ? 1 : opacity2);
}
function Hcl(h3, c6, l3, opacity2) {
  this.h = +h3;
  this.c = +c6;
  this.l = +l3;
  this.opacity = +opacity2;
}
function hcl2lab(o3) {
  if (isNaN(o3.h))
    return new Lab(o3.l, 0, 0, o3.opacity);
  var h3 = o3.h * radians;
  return new Lab(o3.l, Math.cos(h3) * o3.c, Math.sin(h3) * o3.c, o3.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k5) {
    return new Hcl(this.h, this.c, this.l + K4 * (k5 == null ? 1 : k5), this.opacity);
  },
  darker(k5) {
    return new Hcl(this.h, this.c, this.l - K4 * (k5 == null ? 1 : k5), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/cubehelix.js
var A5 = -0.14861;
var B4 = 1.78277;
var C3 = -0.29227;
var D4 = -0.90649;
var E2 = 1.97294;
var ED = E2 * D4;
var EB = E2 * B4;
var BC_DA = B4 * C3 - D4 * A5;
function cubehelixConvert(o3) {
  if (o3 instanceof Cubehelix)
    return new Cubehelix(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Rgb))
    o3 = rgbConvert(o3);
  var r3 = o3.r / 255, g4 = o3.g / 255, b3 = o3.b / 255, l3 = (BC_DA * b3 + ED * r3 - EB * g4) / (BC_DA + ED - EB), bl = b3 - l3, k5 = (E2 * (g4 - l3) - C3 * bl) / D4, s4 = Math.sqrt(k5 * k5 + bl * bl) / (E2 * l3 * (1 - l3)), h3 = s4 ? Math.atan2(k5, bl) * degrees - 120 : NaN;
  return new Cubehelix(h3 < 0 ? h3 + 360 : h3, s4, l3, o3.opacity);
}
function cubehelix(h3, s4, l3, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h3) : new Cubehelix(h3, s4, l3, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h3, s4, l3, opacity2) {
  this.h = +h3;
  this.s = +s4;
  this.l = +l3;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k5) {
    k5 = k5 == null ? brighter : Math.pow(brighter, k5);
    return new Cubehelix(this.h, this.s, this.l * k5, this.opacity);
  },
  darker(k5) {
    k5 = k5 == null ? darker : Math.pow(darker, k5);
    return new Cubehelix(this.h, this.s, this.l * k5, this.opacity);
  },
  rgb() {
    var h3 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l3 = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l3 * (1 - l3), cosh = Math.cos(h3), sinh = Math.sin(h3);
    return new Rgb(
      255 * (l3 + a4 * (A5 * cosh + B4 * sinh)),
      255 * (l3 + a4 * (C3 * cosh + D4 * sinh)),
      255 * (l3 + a4 * (E2 * cosh)),
      this.opacity
    );
  }
}));

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v22, v3) {
  var t23 = t13 * t13, t32 = t23 * t13;
  return ((1 - 3 * t13 + 3 * t23 - t32) * v0 + (4 - 6 * t23 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t23 - 3 * t32) * v22 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n2 = values2.length - 1;
  return function(t4) {
    var i3 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n2 - 1) : Math.floor(t4 * n2), v1 = values2[i3], v22 = values2[i3 + 1], v0 = i3 > 0 ? values2[i3 - 1] : 2 * v1 - v22, v3 = i3 < n2 - 1 ? values2[i3 + 2] : 2 * v22 - v1;
    return basis((t4 - i3 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n2 = values2.length;
  return function(t4) {
    var i3 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n2), v0 = values2[(i3 + n2 - 1) % n2], v1 = values2[i3 % n2], v22 = values2[(i3 + 1) % n2], v3 = values2[(i3 + 2) % n2];
    return basis((t4 - i3 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x6) => () => x6;

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js
function linear(a4, d3) {
  return function(t4) {
    return a4 + t4 * d3;
  };
}
function exponential(a4, b3, y4) {
  return a4 = Math.pow(a4, y4), b3 = Math.pow(b3, y4) - a4, y4 = 1 / y4, function(t4) {
    return Math.pow(a4 + t4 * b3, y4);
  };
}
function hue(a4, b3) {
  var d3 = b3 - a4;
  return d3 ? linear(a4, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default2(isNaN(a4) ? b3 : a4);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a4, b3) {
    return b3 - a4 ? exponential(a4, b3, y4) : constant_default2(isNaN(a4) ? b3 : a4);
  };
}
function nogamma(a4, b3) {
  var d3 = b3 - a4;
  return d3 ? linear(a4, d3) : constant_default2(isNaN(a4) ? b3 : a4);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color3 = gamma(y4);
  function rgb2(start2, end) {
    var r3 = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g4 = color3(start2.g, end.g), b3 = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.r = r3(t4);
      start2.g = g4(t4);
      start2.b = b3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r3 = new Array(n2), g4 = new Array(n2), b3 = new Array(n2), i3, color3;
    for (i3 = 0; i3 < n2; ++i3) {
      color3 = rgb(colors[i3]);
      r3[i3] = color3.r || 0;
      g4[i3] = color3.g || 0;
      b3[i3] = color3.b || 0;
    }
    r3 = spline(r3);
    g4 = spline(g4);
    b3 = spline(b3);
    color3.opacity = 1;
    return function(t4) {
      color3.r = r3(t4);
      color3.g = g4(t4);
      color3.b = b3(t4);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a4, b3) {
  if (!b3)
    b3 = [];
  var n2 = a4 ? Math.min(b3.length, a4.length) : 0, c6 = b3.slice(), i3;
  return function(t4) {
    for (i3 = 0; i3 < n2; ++i3)
      c6[i3] = a4[i3] * (1 - t4) + b3[i3] * t4;
    return c6;
  };
}
function isNumberArray(x6) {
  return ArrayBuffer.isView(x6) && !(x6 instanceof DataView);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/array.js
function genericArray(a4, b3) {
  var nb = b3 ? b3.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x6 = new Array(na), c6 = new Array(nb), i3;
  for (i3 = 0; i3 < na; ++i3)
    x6[i3] = value_default(a4[i3], b3[i3]);
  for (; i3 < nb; ++i3)
    c6[i3] = b3[i3];
  return function(t4) {
    for (i3 = 0; i3 < na; ++i3)
      c6[i3] = x6[i3](t4);
    return c6;
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/date.js
function date_default(a4, b3) {
  var d3 = /* @__PURE__ */ new Date();
  return a4 = +a4, b3 = +b3, function(t4) {
    return d3.setTime(a4 * (1 - t4) + b3 * t4), d3;
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js
function number_default(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t4) {
    return a4 * (1 - t4) + b3 * t4;
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/object.js
function object_default(a4, b3) {
  var i3 = {}, c6 = {}, k5;
  if (a4 === null || typeof a4 !== "object")
    a4 = {};
  if (b3 === null || typeof b3 !== "object")
    b3 = {};
  for (k5 in b3) {
    if (k5 in a4) {
      i3[k5] = value_default(a4[k5], b3[k5]);
    } else {
      c6[k5] = b3[k5];
    }
  }
  return function(t4) {
    for (k5 in i3)
      c6[k5] = i3[k5](t4);
    return c6;
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b3) {
  return function() {
    return b3;
  };
}
function one(b3) {
  return function(t4) {
    return b3(t4) + "";
  };
}
function string_default(a4, b3) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i3 = -1, s4 = [], q4 = [];
  a4 = a4 + "", b3 = b3 + "";
  while ((am = reA.exec(a4)) && (bm = reB.exec(b3))) {
    if ((bs = bm.index) > bi) {
      bs = b3.slice(bi, bs);
      if (s4[i3])
        s4[i3] += bs;
      else
        s4[++i3] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s4[i3])
        s4[i3] += bm;
      else
        s4[++i3] = bm;
    } else {
      s4[++i3] = null;
      q4.push({ i: i3, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b3.length) {
    bs = b3.slice(bi);
    if (s4[i3])
      s4[i3] += bs;
    else
      s4[++i3] = bs;
  }
  return s4.length < 2 ? q4[0] ? one(q4[0].x) : zero2(b3) : (b3 = q4.length, function(t4) {
    for (var i4 = 0, o3; i4 < b3; ++i4)
      s4[(o3 = q4[i4]).i] = o3.x(t4);
    return s4.join("");
  });
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js
function value_default(a4, b3) {
  var t4 = typeof b3, c6;
  return b3 == null || t4 === "boolean" ? constant_default2(b3) : (t4 === "number" ? number_default : t4 === "string" ? (c6 = color(b3)) ? (b3 = c6, rgb_default) : string_default : b3 instanceof color ? rgb_default : b3 instanceof Date ? date_default : isNumberArray(b3) ? numberArray_default : Array.isArray(b3) ? genericArray : typeof b3.valueOf !== "function" && typeof b3.toString !== "function" || isNaN(b3) ? object_default : number_default)(a4, b3);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/round.js
function round_default(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t4) {
    return Math.round(a4 * (1 - t4) + b3 * t4);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b3, c6, d3, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b3 * b3))
    a4 /= scaleX, b3 /= scaleX;
  if (skewX = a4 * c6 + b3 * d3)
    c6 -= a4 * skewX, d3 -= b3 * skewX;
  if (scaleY = Math.sqrt(c6 * c6 + d3 * d3))
    c6 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a4 * d3 < b3 * c6)
    a4 = -a4, b3 = -b3, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b3, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s4) {
    return s4.length ? s4.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s4, q4) {
    if (xa !== xb || ya !== yb) {
      var i3 = s4.push("translate(", null, pxComma, null, pxParen);
      q4.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s4.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a4, b3, s4, q4) {
    if (a4 !== b3) {
      if (a4 - b3 > 180)
        b3 += 360;
      else if (b3 - a4 > 180)
        a4 += 360;
      q4.push({ i: s4.push(pop(s4) + "rotate(", null, degParen) - 2, x: number_default(a4, b3) });
    } else if (b3) {
      s4.push(pop(s4) + "rotate(" + b3 + degParen);
    }
  }
  function skewX(a4, b3, s4, q4) {
    if (a4 !== b3) {
      q4.push({ i: s4.push(pop(s4) + "skewX(", null, degParen) - 2, x: number_default(a4, b3) });
    } else if (b3) {
      s4.push(pop(s4) + "skewX(" + b3 + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s4, q4) {
    if (xa !== xb || ya !== yb) {
      var i3 = s4.push(pop(s4) + "scale(", null, ",", null, ")");
      q4.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s4.push(pop(s4) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b3) {
    var s4 = [], q4 = [];
    a4 = parse2(a4), b3 = parse2(b3);
    translate2(a4.translateX, a4.translateY, b3.translateX, b3.translateY, s4, q4);
    rotate(a4.rotate, b3.rotate, s4, q4);
    skewX(a4.skewX, b3.skewX, s4, q4);
    scale(a4.scaleX, a4.scaleY, b3.scaleX, b3.scaleY, s4, q4);
    a4 = b3 = null;
    return function(t4) {
      var i3 = -1, n2 = q4.length, o3;
      while (++i3 < n2)
        s4[(o3 = q4[i3]).i] = o3.x(t4);
      return s4.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h3 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s4 = nogamma(start2.s, end.s), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h3(t4);
      start2.s = s4(t4);
      start2.l = l3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l3 = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b3 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
  return function(t4) {
    start2.l = l3(t4);
    start2.a = a4(t4);
    start2.b = b3(t4);
    start2.opacity = opacity2(t4);
    return start2 + "";
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h3 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h3(t4);
      start2.c = c6(t4);
      start2.l = l3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start2, end) {
      var h3 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s4 = nogamma(start2.s, end.s), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t4) {
        start2.h = h3(t4);
        start2.s = s4(t4);
        start2.l = l3(Math.pow(t4, y4));
        start2.opacity = opacity2(t4);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values2) {
  if (values2 === void 0)
    values2 = interpolate, interpolate = value_default;
  var i3 = 0, n2 = values2.length - 1, v3 = values2[0], I4 = new Array(n2 < 0 ? 0 : n2);
  while (i3 < n2)
    I4[i3] = interpolate(v3, v3 = values2[++i3]);
  return function(t4) {
    var i4 = Math.max(0, Math.min(n2 - 1, Math.floor(t4 *= n2)));
    return I4[i4](t4 - i4);
  };
}

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n2) {
  var samples = new Array(n2);
  for (var i3 = 0; i3 < n2; ++i3)
    samples[i3] = interpolator(i3 / (n2 - 1));
  return samples;
}

// node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
  setTimeout(f3, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer2.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer2(callback, delay, time2) {
  var t4 = new Timer();
  t4.restart(callback, delay, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e3;
  while (t4) {
    if ((e3 = clockNow - t4._time) >= 0)
      t4._call.call(void 0, e3);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t23, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t23 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t23 : taskHead = t23;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t4 = new Timer();
  delay = delay == null ? 0 : +delay;
  t4.restart((elapsed) => {
    t4.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t4;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group2, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group: group2,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer2(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i3, j4, n2, o3;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i3 in schedules) {
      o3 = schedules[i3];
      if (o3.name !== self2.name)
        continue;
      if (o3.state === STARTED)
        return timeout_default(start2);
      if (o3.state === RUNNING) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("interrupt", node, node.__data__, o3.index, o3.group);
        delete schedules[i3];
      } else if (+i3 < id2) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("cancel", node, node.__data__, o3.index, o3.group);
        delete schedules[i3];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n2 = self2.tween.length);
    for (i3 = 0, j4 = -1; i3 < n2; ++i3) {
      if (o3 = self2.tween[i3].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j4] = o3;
      }
    }
    tween.length = j4 + 1;
  }
  function tick(elapsed) {
    var t4 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i3 = -1, n2 = tween.length;
    while (++i3 < n2) {
      tween[i3].call(node, t4);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i3 in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i3;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i3 in schedules) {
    if ((schedule = schedules[i3]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i3];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i3 = 0, n2 = tween1.length; i3 < n2; ++i3) {
        if (tween1[i3].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i3, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = { name, value }, i3 = 0, n2 = tween1.length; i3 < n2; ++i3) {
        if (tween1[i3].name === name) {
          tween1[i3] = t4;
          break;
        }
      }
      if (i3 === n2)
        tween1.push(t4);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i3 = 0, n2 = tween.length, t4; i3 < n2; ++i3) {
      if ((t4 = tween[i3]).name === name) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a4, b3) {
  var c6;
  return (typeof b3 === "number" ? number_default : b3 instanceof color ? rgb_default : (c6 = color(b3)) ? (b3 = c6, rgb_default) : string_default)(a4, b3);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i3 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i3, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i3, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i3) {
  return function(t4) {
    this.setAttribute(name, i3.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i3) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i3.call(this, t4));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && attrInterpolateNS(fullname, i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && attrInterpolate(name, i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (typeof v3 !== "function")
      throw new Error();
    set2(this, id2).ease = v3;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/filter.js
function filter_default2(match5) {
  if (typeof match5 !== "function")
    match5 = matcher_default(match5);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, subgroup = subgroups[j4] = [], node, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && match5.call(node, node.__data__, i3, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j4 = 0; j4 < m3; ++j4) {
    for (var group0 = groups0[j4], group1 = groups1[j4], n2 = group0.length, merge2 = merges[j4] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge2[i3] = node;
      }
    }
  }
  for (; j4 < m0; ++j4) {
    merges[j4] = groups0[j4];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t4) {
    var i3 = t4.indexOf(".");
    if (i3 >= 0)
      t4 = t4.slice(0, i3);
    return !t4 || t4 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on2 = schedule.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i3 in this.__transition)
      if (+i3 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, subgroup = subgroups[j4] = new Array(n2), node, subnode, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && (subnode = select.call(node, node.__data__, i3, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
        schedule_default(subgroup[i3], name, id2, i3, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        for (var children2 = select.call(node, node.__data__, i3, group2), child, inherit3 = get2(node, id2), k5 = 0, l3 = children2.length; k5 < l3; ++k5) {
          if (child = children2[k5]) {
            schedule_default(child, name, id2, k5, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on2 = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i3 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i3)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i3, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i3, value), priority).on("end.style." + name, null);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i3, priority) {
  return function(t4) {
    this.style.setProperty(name, i3.call(this, t4), priority);
  };
}
function styleTween(name, value, priority) {
  var t4, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t4 = (i0 = i3) && styleInterpolate(name, i3, priority);
    return t4;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i3) {
  return function(t4) {
    this.textContent = i3.call(this, t4);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && textInterpolate(i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m3 = groups2.length, j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        var inherit3 = get2(node, id0);
        schedule_default(node, name, id1, i3, group2, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on2 = schedule.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/cubic.js
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j4 = 0; j4 < m3; ++j4) {
    for (var group2 = groups2[j4], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        schedule_default(node, name, id2, i3, group2, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/.pnpm/d3-brush@3.0.0/node_modules/d3-brush/src/brush.js
var { abs, max: max2, min: min2 } = Math;
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number22(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
var X3 = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x6, e3) {
    return x6 == null ? null : [[+x6[0], e3[0][1]], [+x6[1], e3[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y3 = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e3) {
    return y4 == null ? null : [[e3[0][0], +y4[0]], [e3[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t4) {
  return { type: t4 };
}

// node_modules/.pnpm/d3-path@3.1.0/node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon2 = 1e-6;
var tauEpsilon = tau - epsilon2;
function append(strings2) {
  this._ += strings2[0];
  for (let i3 = 1, n2 = strings2.length; i3 < n2; ++i3) {
    this._ += arguments[i3] + strings2[i3];
  }
}
function appendRound(digits) {
  let d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append;
  const k5 = 10 ** d3;
  return function(strings2) {
    this._ += strings2[0];
    for (let i3 = 1, n2 = strings2.length; i3 < n2; ++i3) {
      this._ += Math.round(arguments[i3] * k5) / k5 + strings2[i3];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x6, y4) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x6, y4) {
    this._append`L${this._x1 = +x6},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y12, x6, y4) {
    this._append`Q${+x12},${+y12},${this._x1 = +x6},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x6, y4) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x6},${this._y1 = +y4}`;
  }
  arcTo(x12, y12, x22, y22, r3) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r3 = +r3;
    if (r3 < 0)
      throw new Error(`negative radius: ${r3}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r3) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l3 = r3 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l3 / l01, t21 = l3 / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r3},${r3},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x6, y4, r3, a0, a1, ccw) {
    x6 = +x6, y4 = +y4, r3 = +r3, ccw = !!ccw;
    if (r3 < 0)
      throw new Error(`negative radius: ${r3}`);
    let dx = r3 * Math.cos(a0), dy = r3 * Math.sin(a0), x05 = x6 + dx, y05 = y4 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r3)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r3},${r3},0,1,${cw},${x6 - dx},${y4 - dy}A${r3},${r3},0,1,${cw},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r3},${r3},0,${+(da >= pi)},${cw},${this._x1 = x6 + r3 * Math.cos(a1)},${this._y1 = y4 + r3 * Math.sin(a1)}`;
    }
  }
  rect(x6, y4, w4, h3) {
    this._append`M${this._x0 = this._x1 = +x6},${this._y0 = this._y1 = +y4}h${w4 = +w4}v${+h3}h${-w4}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i3) {
    return JSON.stringify(name) + ": d[" + i3 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f3) {
  var object = objectConverter(columns);
  return function(row, i3) {
    return f3(object(row), i3, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s4 = value + "", length3 = s4.length;
  return length3 < width ? new Array(width - length3 + 1).join(0) + s4 : s4;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date2) {
  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds2, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter2) {
  var reFormat = new RegExp('["' + delimiter2 + "\n\r]"), DELIMITER = delimiter2.charCodeAt(0);
  function parse2(text2, f3) {
    var convert2, columns, rows = parseRows(text2, function(row, i3) {
      if (convert2)
        return convert2(row, i3 - 1);
      columns = row, convert2 = f3 ? customConverter(row, f3) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f3) {
    var rows = [], N3 = text2.length, I4 = 0, n2 = 0, t4, eof = N3 <= 0, eol = false;
    if (text2.charCodeAt(N3 - 1) === NEWLINE)
      --N3;
    if (text2.charCodeAt(N3 - 1) === RETURN)
      --N3;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i3, j4 = I4, c6;
      if (text2.charCodeAt(j4) === QUOTE) {
        while (I4++ < N3 && text2.charCodeAt(I4) !== QUOTE || text2.charCodeAt(++I4) === QUOTE)
          ;
        if ((i3 = I4) >= N3)
          eof = true;
        else if ((c6 = text2.charCodeAt(I4++)) === NEWLINE)
          eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I4) === NEWLINE)
            ++I4;
        }
        return text2.slice(j4 + 1, i3 - 1).replace(/""/g, '"');
      }
      while (I4 < N3) {
        if ((c6 = text2.charCodeAt(i3 = I4++)) === NEWLINE)
          eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I4) === NEWLINE)
            ++I4;
        } else if (c6 !== DELIMITER)
          continue;
        return text2.slice(j4, i3);
      }
      return eof = true, text2.slice(j4, N3);
    }
    while ((t4 = token()) !== EOF) {
      var row = [];
      while (t4 !== EOL && t4 !== EOF)
        row.push(t4), t4 = token();
      if (f3 && (row = f3(row, n2++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter2);
    });
  }
  function format3(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter2)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter2);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse: parse2,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number6, m3;
    if (!value)
      value = null;
    else if (value === "true")
      value = true;
    else if (value === "false")
      value = false;
    else if (value === "NaN")
      value = NaN;
    else if (!isNaN(number6 = +value))
      value = number6;
    else if (m3 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7])
        value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else
      continue;
    object[key] = value;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/.pnpm/d3-fetch@3.0.1/node_modules/d3-fetch/src/text.js
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text_default3(input, init2) {
  return fetch(input, init2).then(responseText);
}

// node_modules/.pnpm/d3-fetch@3.0.1/node_modules/d3-fetch/src/dsv.js
function dsvParse(parse2) {
  return function(input, init2, row) {
    if (arguments.length === 2 && typeof init2 === "function")
      row = init2, init2 = void 0;
    return text_default3(input, init2).then(function(response) {
      return parse2(response, row);
    });
  };
}
var csv2 = dsvParse(csvParse);
var tsv2 = dsvParse(tsvParse);

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x6) {
  return Math.abs(x6 = Math.round(x6)) >= 1e21 ? x6.toLocaleString("en").replace(/,/g, "") : x6.toString(10);
}
function formatDecimalParts(x6, p4) {
  if ((i3 = (x6 = p4 ? x6.toExponential(p4 - 1) : x6.toExponential()).indexOf("e")) < 0)
    return null;
  var i3, coefficient = x6.slice(0, i3);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x6.slice(i3 + 1)
  ];
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/exponent.js
function exponent_default(x6) {
  return x6 = formatDecimalParts(Math.abs(x6)), x6 ? x6[1] : NaN;
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i3 = value.length, t4 = [], j4 = 0, g4 = grouping[0], length3 = 0;
    while (i3 > 0 && g4 > 0) {
      if (length3 + g4 + 1 > width)
        g4 = Math.max(1, width - length3);
      t4.push(value.substring(i3 -= g4, i3 + g4));
      if ((length3 += g4 + 1) > width)
        break;
      g4 = grouping[j4 = (j4 + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i3) {
      return numerals[+i3];
    });
  };
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match5 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match5;
  return new FormatSpecifier({
    fill: match5[1],
    align: match5[2],
    sign: match5[3],
    symbol: match5[4],
    zero: match5[5],
    width: match5[6],
    comma: match5[7],
    precision: match5[8] && match5[8].slice(1),
    trim: match5[9],
    type: match5[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s4) {
  out:
    for (var n2 = s4.length, i3 = 1, i0 = -1, i1; i3 < n2; ++i3) {
      switch (s4[i3]) {
        case ".":
          i0 = i1 = i3;
          break;
        case "0":
          if (i0 === 0)
            i0 = i3;
          i1 = i3;
          break;
        default:
          if (!+s4[i3])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s4.slice(0, i0) + s4.slice(i1 + 1) : s4;
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x6, p4) {
  var d3 = formatDecimalParts(x6, p4);
  if (!d3)
    return x6 + "";
  var coefficient = d3[0], exponent = d3[1], i3 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i3 === n2 ? coefficient : i3 > n2 ? coefficient + new Array(i3 - n2 + 1).join("0") : i3 > 0 ? coefficient.slice(0, i3) + "." + coefficient.slice(i3) : "0." + new Array(1 - i3).join("0") + formatDecimalParts(x6, Math.max(0, p4 + i3 - 1))[0];
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x6, p4) {
  var d3 = formatDecimalParts(x6, p4);
  if (!d3)
    return x6 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x6, p4) => (x6 * 100).toFixed(p4),
  "b": (x6) => Math.round(x6).toString(2),
  "c": (x6) => x6 + "",
  "d": formatDecimal_default,
  "e": (x6, p4) => x6.toExponential(p4),
  "f": (x6, p4) => x6.toFixed(p4),
  "g": (x6, p4) => x6.toPrecision(p4),
  "o": (x6) => Math.round(x6).toString(8),
  "p": (x6, p4) => formatRounded_default(x6 * 100, p4),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x6) => Math.round(x6).toString(16).toUpperCase(),
  "x": (x6) => Math.round(x6).toString(16)
};

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/identity.js
function identity_default2(x6) {
  return x6;
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/locale.js
var map2 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale7) {
  var group2 = locale7.grouping === void 0 || locale7.thousands === void 0 ? identity_default2 : formatGroup_default(map2.call(locale7.grouping, Number), locale7.thousands + ""), currencyPrefix = locale7.currency === void 0 ? "" : locale7.currency[0] + "", currencySuffix = locale7.currency === void 0 ? "" : locale7.currency[1] + "", decimal = locale7.decimal === void 0 ? "." : locale7.decimal + "", numerals = locale7.numerals === void 0 ? identity_default2 : formatNumerals_default(map2.call(locale7.numerals, String)), percent = locale7.percent === void 0 ? "%" : locale7.percent + "", minus = locale7.minus === void 0 ? "\u2212" : locale7.minus + "", nan = locale7.nan === void 0 ? "NaN" : locale7.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i3, n2, c6;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i3 = -1, n2 = value.length;
          while (++i3 < n2) {
            if (c6 = value.charCodeAt(i3), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value.slice(i3 + 1) : value.slice(i3)) + valueSuffix;
              value = value.slice(0, i3);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero3)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k5 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f3(k5 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var quarterPi = pi2 / 4;
var tau2 = pi2 * 2;
var degrees3 = 180 / pi2;
var radians2 = pi2 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x6) {
  return x6 > 0 ? 1 : x6 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x6) {
  return x6 > 1 ? 0 : x6 < -1 ? pi2 : Math.acos(x6);
}
function asin(x6) {
  return x6 > 1 ? halfPi : x6 < -1 ? -halfPi : Math.asin(x6);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/noop.js
function noop3() {
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i3 = -1, n2 = features.length;
    while (++i3 < n2)
      streamGeometry(features[i3].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      object = coordinates[i3], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      streamLine(coordinates[i3], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      streamPolygon(coordinates[i3], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i3 = -1, n2 = geometries.length;
    while (++i3 < n2)
      streamGeometry(geometries[i3], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i3 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i3 < n2)
    coordinate = coordinates[i3], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i3 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i3 < n2)
    streamLine(coordinates[i3], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a4, b3) {
  return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2];
}
function cartesianCross(a4, b3) {
  return [a4[1] * b3[2] - a4[2] * b3[1], a4[2] * b3[0] - a4[0] * b3[2], a4[0] * b3[1] - a4[1] * b3[0]];
}
function cartesianAddInPlace(a4, b3) {
  a4[0] += b3[0], a4[1] += b3[1], a4[2] += b3[2];
}
function cartesianScale(vector, k5) {
  return [vector[0] * k5, vector[1] * k5, vector[2] * k5];
}
function cartesianNormalizeInPlace(d3) {
  var l3 = sqrt(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
  d3[0] /= l3, d3[1] /= l3, d3[2] /= l3;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/compose.js
function compose_default(a4, b3) {
  function compose2(x6, y4) {
    return x6 = a4(x6, y4), b3(x6[0], x6[1]);
  }
  if (a4.invert && b3.invert)
    compose2.invert = function(x6, y4) {
      return x6 = b3.invert(x6, y4), x6 && a4.invert(x6[0], x6[1]);
    };
  return compose2;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  if (abs2(lambda) > pi2)
    lambda -= Math.round(lambda / tau2) * tau2;
  return [lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi2)
      lambda -= Math.round(lambda / tau2) * tau2;
    return [lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x6 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z4 = sin(phi), k5 = z4 * cosDeltaPhi + x6 * sinDeltaPhi;
    return [
      atan2(y4 * cosDeltaGamma - k5 * sinDeltaGamma, x6 * cosDeltaPhi - z4 * sinDeltaPhi),
      asin(k5 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x6 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z4 = sin(phi), k5 = z4 * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan2(y4 * cosDeltaGamma + z4 * sinDeltaGamma, x6 * cosDeltaPhi + k5 * sinDeltaPhi),
      asin(k5 * cosDeltaPhi - x6 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/circle.js
function circleStream(stream, radius2, delta, direction, t03, t13) {
  if (!delta)
    return;
  var cosRadius = cos(radius2), sinRadius = sin(radius2), step = direction * delta;
  if (t03 == null) {
    t03 = radius2 + direction * tau2;
    t13 = radius2 - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13)
      t03 += direction * tau2;
  }
  for (var point6, t4 = t03; direction > 0 ? t4 > t13 : t4 < t13; t4 -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos(t4), -sinRadius * sin(t4)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius2 = acos(-point6[1]);
  return ((-point6[2] < 0 ? -radius2 : radius2) + tau2 - epsilon3) % tau2;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line2;
  return {
    point: function(x6, y4, m3) {
      line2.push([x6, y4, m3]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop3,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line2 = null;
      return result;
    }
  };
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b3) {
  return abs2(a4[0] - b3[0]) < epsilon3 && abs2(a4[1] - b3[1]) < epsilon3;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points, other, entry) {
  this.x = point6;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i3, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0)
      return;
    var n3, p0 = segment[0], p1 = segment[n3], x6;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i3 = 0; i3 < n3; ++i3)
          stream.point((p0 = segment[i3])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x6 = new Intersection(p0, segment, null, true));
    clip.push(x6.o = new Intersection(p0, null, x6, false));
    subject.push(x6 = new Intersection(p1, segment, null, false));
    clip.push(x6.o = new Intersection(p1, null, x6, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i3 = 0, n2 = clip.length; i3 < n2; ++i3) {
    clip[i3].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point6;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i3 = 0, n2 = points.length; i3 < n2; ++i3)
            stream.point((point6 = points[i3])[0], point6[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i3 = points.length - 1; i3 >= 0; --i3)
            stream.point((point6 = points[i3])[0], point6[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array2) {
  if (!(n2 = array2.length))
    return;
  var n2, i3 = 0, a4 = array2[0], b3;
  while (++i3 < n2) {
    a4.n = b3 = array2[i3];
    b3.p = a4;
    a4 = b3;
  }
  a4.n = b3 = array2[0];
  b3.p = a4;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi2 ? point6[0] : sign(point6[0]) * ((abs2(point6[0]) + pi2) % tau2 - pi2);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi = point6[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi = halfPi + epsilon3;
  else if (sinPhi === -1)
    phi = -halfPi - epsilon3;
  for (var i3 = 0, n2 = polygon.length; i3 < n2; ++i3) {
    if (!(m3 = (ring = polygon[i3]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j4 = 0; j4 < m3; ++j4, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j4], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi2, k5 = sinPhi0 * sinPhi1;
      sum2.add(atan2(k5 * sign3 * sin(absDelta), cosPhi0 * cosPhi1 + k5 * cos(absDelta)));
      angle += antimeridian ? delta + sign3 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon3 || angle < epsilon3 && sum2 < -epsilon22) ^ winding & 1;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line2 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi) {
      if (pointVisible(lambda, phi))
        sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line2.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line2.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i3, n2 = ringSegments.length, m3, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i3 = 0; i3 < m3; ++i3)
            sink.point((point7 = segment[i3])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b3) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi - epsilon3 : halfPi - a4[1]) - ((b3 = b3.x)[0] < 0 ? b3[1] - halfPi - epsilon3 : halfPi - b3[1]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi2, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi2 : -pi2, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi2) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi2) {
        if (abs2(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi2, phi);
    stream.point(0, phi);
    stream.point(pi2, phi);
    stream.point(pi2, 0);
    stream.point(pi2, -phi);
    stream.point(0, -phi);
    stream.point(-pi2, -phi);
    stream.point(-pi2, 0);
    stream.point(-pi2, phi);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi2 : -pi2;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/circle.js
function circle_default(radius2) {
  var cr = cos(radius2), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v3 = visible(lambda, phi), c6 = smallRadius ? v3 ? 0 : code(lambda, phi) : v3 ? code(lambda + (lambda < 0 ? pi2 : -pi2), phi) : 0;
        if (!point0 && (v00 = v0 = v3))
          stream.lineStart();
        if (v3 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v3 !== v0) {
          clean = 0;
          if (v3) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v3) {
          var t4;
          if (!(c6 & c0) && (t4 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1]);
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v3, c0 = c6;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a4, b3, two) {
    var pa = cartesian(a4), pb = cartesian(b3);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a4;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B5 = cartesianScale(n2, c22);
    cartesianAddInPlace(A6, B5);
    var u3 = n1xn2, w4 = cartesianDot(A6, u3), uu = cartesianDot(u3, u3), t23 = w4 * w4 - uu * (cartesianDot(A6, A6) - 1);
    if (t23 < 0)
      return;
    var t4 = sqrt(t23), q4 = cartesianScale(u3, (-w4 - t4) / uu);
    cartesianAddInPlace(q4, A6);
    q4 = spherical(q4);
    if (!two)
      return q4;
    var lambda0 = a4[0], lambda1 = b3[0], phi0 = a4[1], phi1 = b3[1], z4;
    if (lambda1 < lambda0)
      z4 = lambda0, lambda0 = lambda1, lambda1 = z4;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi2) < epsilon3, meridian = polar || delta2 < epsilon3;
    if (!polar && phi1 < phi0)
      z4 = phi0, phi0 = phi1, phi1 = z4;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q4[1] < (abs2(q4[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q4[1] && q4[1] <= phi1 : delta2 > pi2 ^ (lambda0 <= q4[0] && q4[0] <= lambda1)) {
      var q1 = cartesianScale(u3, (-w4 + t4) / uu);
      cartesianAddInPlace(q1, A6);
      return [q4, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r3 = smallRadius ? radius2 : pi2 - radius2, code2 = 0;
    if (lambda < -r3)
      code2 |= 1;
    else if (lambda > r3)
      code2 |= 2;
    if (phi < -r3)
      code2 |= 4;
    else if (phi > r3)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi2, radius2 - pi2]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/line.js
function line_default(a4, b3, x05, y05, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b3[0], by = b3[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r3;
  r3 = x05 - ax;
  if (!dx && r3 > 0)
    return;
  r3 /= dx;
  if (dx < 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  } else if (dx > 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  }
  r3 = x12 - ax;
  if (!dx && r3 < 0)
    return;
  r3 /= dx;
  if (dx < 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  } else if (dx > 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  }
  r3 = y05 - ay;
  if (!dy && r3 > 0)
    return;
  r3 /= dy;
  if (dy < 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  } else if (dy > 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  }
  r3 = y12 - ay;
  if (!dy && r3 < 0)
    return;
  r3 /= dy;
  if (dy < 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  } else if (dy > 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  }
  if (t03 > 0)
    a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;
  if (t13 < 1)
    b3[0] = ax + t13 * dx, b3[1] = ay + t13 * dy;
  return true;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x6, y4) {
    return x05 <= x6 && x6 <= x12 && y05 <= y4 && y4 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x12, a4 > 1 ? y12 : y05);
      while ((a4 = (a4 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p4, direction) {
    return abs2(p4[0] - x05) < epsilon3 ? direction > 0 ? 0 : 3 : abs2(p4[0] - x12) < epsilon3 ? direction > 0 ? 2 : 1 : abs2(p4[1] - y05) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b3) {
    return comparePoint(a4.x, b3.x);
  }
  function comparePoint(a4, b3) {
    var ca = corner(a4, 1), cb = corner(b3, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b3[1] - a4[1] : ca === 1 ? a4[0] - b3[0] : ca === 2 ? a4[1] - b3[1] : b3[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x6, y4) {
      if (visible(x6, y4))
        activeStream.point(x6, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i3 = 0, n2 = polygon.length; i3 < n2; ++i3) {
        for (var ring2 = polygon[i3], j4 = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j4 < m3; ++j4) {
          a0 = b0, a1 = b1, point7 = ring2[j4], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first2 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x6, y4) {
      var v3 = visible(x6, y4);
      if (polygon)
        ring.push([x6, y4]);
      if (first2) {
        x__ = x6, y__ = y4, v__ = v3;
        first2 = false;
        if (v3) {
          activeStream.lineStart();
          activeStream.point(x6, y4);
        }
      } else {
        if (v3 && v_)
          activeStream.point(x6, y4);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b3 = [x6 = Math.max(clipMin, Math.min(clipMax, x6)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default(a4, b3, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b3[0], b3[1]);
            if (!v3)
              activeStream.lineEnd();
            clean = false;
          } else if (v3) {
            activeStream.lineStart();
            activeStream.point(x6, y4);
            clean = false;
          }
        }
      }
      x_ = x6, y_ = y4, v_ = v3;
    }
    return clipStream;
  };
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/identity.js
var identity_default3 = (x6) => x6;

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/area.js
var areaSum = new Adder();
var areaRingSum = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream = {
  point: noop3,
  lineStart: noop3,
  lineEnd: noop3,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop3;
    areaSum.add(abs2(areaRingSum));
    areaRingSum = new Adder();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x6, y4) {
  areaStream.point = areaPoint;
  x00 = x0 = x6, y00 = y0 = y4;
}
function areaPoint(x6, y4) {
  areaRingSum.add(y0 * x6 - x0 * y4);
  x0 = x6, y0 = y4;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream;

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop3,
  lineEnd: noop3,
  polygonStart: noop3,
  polygonEnd: noop3,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x6, y4) {
  if (x6 < x02)
    x02 = x6;
  if (x6 > x1)
    x1 = x6;
  if (y4 < y02)
    y02 = y4;
  if (y4 > y1)
    y1 = y4;
}
var bounds_default = boundsStream;

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint(x6, y4) {
  X0 += x6;
  Y0 += y4;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x6, y4) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x6, y03 = y4);
}
function centroidPointLine(x6, y4) {
  var dx = x6 - x03, dy = y4 - y03, z4 = sqrt(dx * dx + dy * dy);
  X1 += z4 * (x03 + x6) / 2;
  Y1 += z4 * (y03 + y4) / 2;
  Z1 += z4;
  centroidPoint(x03 = x6, y03 = y4);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x6, y4) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x6, y002 = y03 = y4);
}
function centroidPointRing(x6, y4) {
  var dx = x6 - x03, dy = y4 - y03, z4 = sqrt(dx * dx + dy * dy);
  X1 += z4 * (x03 + x6) / 2;
  Y1 += z4 * (y03 + y4) / 2;
  Z1 += z4;
  z4 = y03 * x6 - x03 * y4;
  X22 += z4 * (x03 + x6);
  Y22 += z4 * (y03 + y4);
  Z22 += z4 * 3;
  centroidPoint(x03 = x6, y03 = y4);
}
var centroid_default = centroidStream;

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_3) {
    return this._radius = _3, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x6, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x6, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x6, y4);
        break;
      }
      default: {
        this._context.moveTo(x6 + this._radius, y4);
        this._context.arc(x6, y4, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop3
};

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop3,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop3;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length3 = +lengthSum;
    lengthSum = new Adder();
    return length3;
  }
};
function lengthPointFirst(x6, y4) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x6, y003 = y04 = y4;
}
function lengthPoint(x6, y4) {
  x04 -= x6, y04 -= y4;
  lengthSum.add(sqrt(x04 * x04 + y04 * y04));
  x04 = x6, y04 = y4;
}
var measure_default = lengthStream;

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_3) {
    this._radius = +_3;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x6, y4) {
    switch (this._point) {
      case 0: {
        this._append`M${x6},${y4}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x6},${y4}`;
        break;
      }
      default: {
        this._append`M${x6},${y4}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r3 = this._radius;
          const s4 = this._;
          this._ = "";
          this._append`m0,${r3}a${r3},${r3} 0 1,1 0,${-2 * r3}a${r3},${r3} 0 1,1 0,${2 * r3}z`;
          cacheRadius = r3;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s4;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings2) {
  let i3 = 1;
  this._ += strings2[0];
  for (const j4 = strings2.length; i3 < j4; ++i3) {
    this._ += arguments[i3] + strings2[i3];
  }
}
function appendRound2(digits) {
  const d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append2;
  if (d3 !== cacheDigits) {
    const k5 = 10 ** d3;
    cacheDigits = d3;
    cacheAppend = function append3(strings2) {
      let i3 = 1;
      this._ += strings2[0];
      for (const j4 = strings2.length; i3 < j4; ++i3) {
        this._ += Math.round(arguments[i3] * k5) / k5 + strings2[i3];
      }
    };
  }
  return cacheAppend;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/path/index.js
function path_default(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default));
    return area_default.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_3) {
    if (!arguments.length)
      return projection3;
    projectionStream = _3 == null ? (projection3 = null, identity_default3) : (projection3 = _3).stream;
    return path2;
  };
  path2.context = function(_3) {
    if (!arguments.length)
      return context;
    contextStream = _3 == null ? (context = null, new PathString(digits)) : new PathContext(context = _3);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_3) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _3 === "function" ? _3 : (contextStream.pointRadius(+_3), +_3);
    return path2;
  };
  path2.digits = function(_3) {
    if (!arguments.length)
      return digits;
    if (_3 == null)
      digits = null;
    else {
      const d3 = Math.floor(_3);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_3}`);
      digits = d3;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s4 = new TransformStream();
    for (var key in methods)
      s4[key] = methods[key];
    s4.stream = stream;
    return s4;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x6, y4) {
    this.stream.point(x6, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent3, object) {
  return fit(projection3, function(b3) {
    var w4 = extent3[1][0] - extent3[0][0], h3 = extent3[1][1] - extent3[0][1], k5 = Math.min(w4 / (b3[1][0] - b3[0][0]), h3 / (b3[1][1] - b3[0][1])), x6 = +extent3[0][0] + (w4 - k5 * (b3[1][0] + b3[0][0])) / 2, y4 = +extent3[0][1] + (h3 - k5 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k5).translate([x6, y4]);
  }, object);
}
function fitSize(projection3, size, object) {
  return fitExtent(projection3, [[0, 0], size], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b3) {
    var w4 = +width, k5 = w4 / (b3[1][0] - b3[0][0]), x6 = (w4 - k5 * (b3[1][0] + b3[0][0])) / 2, y4 = -k5 * b3[0][1];
    projection3.scale(150 * k5).translate([x6, y4]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b3) {
    var h3 = +height, k5 = h3 / (b3[1][1] - b3[0][1]), x6 = -k5 * b3[0][0], y4 = (h3 - k5 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k5).translate([x6, y4]);
  }, object);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians2);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x6, y4) {
      x6 = project2(x6, y4);
      this.stream.point(x6[0], x6[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b3 = b0 + b1, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b3 * b3 + c6 * c6), phi2 = asin(c6 /= m3), lambda2 = abs2(abs2(c6) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan2(b3, a4), p4 = project2(lambda2, phi2), x22 = p4[0], y22 = p4[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a4 /= m3, b3 /= m3, c6, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a4, b3, c6, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x6, y4) {
      x6 = project2(x6, y4);
      stream.point(x6[0], x6[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c6 = cartesian([lambda, phi]), p4 = project2(lambda, phi);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p4[0], y05 = p4[1], lambda0 = lambda, a0 = c6[0], b0 = c6[1], c0 = c6[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x6, y4) {
    this.stream.point(x6 * radians2, y4 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x6, y4) {
      var r3 = rotate(x6, y4);
      return this.stream.point(r3[0], r3[1]);
    }
  });
}
function scaleTranslate(k5, dx, dy, sx, sy) {
  function transform2(x6, y4) {
    x6 *= sx;
    y4 *= sy;
    return [dx + k5 * x6, dy - k5 * y4];
  }
  transform2.invert = function(x6, y4) {
    return [(x6 - dx) / k5 * sx, (dy - y4) / k5 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k5, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k5, dx, dy, sx, sy);
  var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a4 = cosAlpha * k5, b3 = sinAlpha * k5, ai = cosAlpha / k5, bi = sinAlpha / k5, ci = (sinAlpha * dy - cosAlpha * dx) / k5, fi = (sinAlpha * dx + cosAlpha * dy) / k5;
  function transform2(x6, y4) {
    x6 *= sx;
    y4 *= sy;
    return [a4 * x6 - b3 * y4 + dx, dy - b3 * x6 - a4 * y4];
  }
  transform2.invert = function(x6, y4) {
    return [sx * (ai * x6 - bi * y4 + ci), sy * (fi - bi * x6 - ai * y4)];
  };
  return transform2;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k5 = 150, x6 = 480, y4 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point6) {
    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
  }
  function invert(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees3, point6[1] * degrees3];
  }
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_3) {
    return arguments.length ? (preclip = _3, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_3) {
    return arguments.length ? (postclip = _3, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_3) {
    return arguments.length ? (preclip = +_3 ? circle_default(theta = _3 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection3.clipExtent = function(_3) {
    return arguments.length ? (postclip = _3 == null ? (x05 = y05 = x12 = y12 = null, identity_default3) : clipRectangle(x05 = +_3[0][0], y05 = +_3[0][1], x12 = +_3[1][0], y12 = +_3[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_3) {
    return arguments.length ? (k5 = +_3, recenter()) : k5;
  };
  projection3.translate = function(_3) {
    return arguments.length ? (x6 = +_3[0], y4 = +_3[1], recenter()) : [x6, y4];
  };
  projection3.center = function(_3) {
    return arguments.length ? (lambda = _3[0] % 360 * radians2, phi = _3[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
  };
  projection3.rotate = function(_3) {
    return arguments.length ? (deltaLambda = _3[0] % 360 * radians2, deltaPhi = _3[1] % 360 * radians2, deltaGamma = _3.length > 2 ? _3[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_3) {
    return arguments.length ? (alpha = _3 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_3) {
    return arguments.length ? (sx = _3 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_3) {
    return arguments.length ? (sy = _3 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_3) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _3 * _3), reset()) : sqrt(delta2);
  };
  projection3.fitExtent = function(extent3, object) {
    return fitExtent(projection3, extent3, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k5, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi)), transform2 = scaleTranslateRotate(k5, x6 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection3.invert = project2.invert && invert;
    return recenter();
  };
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi2 / 3, m3 = projectionMutator(projectAt), p4 = m3(phi0, phi1);
  p4.parallels = function(_3) {
    return arguments.length ? m3(phi0 = _3[0] * radians2, phi1 = _3[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
  };
  return p4;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x6, y4) {
    return [x6 / cosPhi0, asin(y4 * cosPhi0)];
  };
  return forward;
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin(y05), n2 = (sy0 + sin(y12)) / 2;
  if (abs2(n2) < epsilon3)
    return cylindricalEqualAreaRaw(y05);
  var c6 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt(c6) / n2;
  function project2(x6, y4) {
    var r3 = sqrt(c6 - 2 * n2 * sin(y4)) / n2;
    return [r3 * sin(x6 *= n2), r0 - r3 * cos(x6)];
  }
  project2.invert = function(x6, y4) {
    var r0y = r0 - y4, l3 = atan2(x6, abs2(r0y)) * sign(r0y);
    if (r0y * n2 < 0)
      l3 -= pi2 * sign(x6) * sign(r0y);
    return [l3 / n2, asin((c6 - (x6 * x6 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x6, y4) {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].point(x6, y4);
    },
    sphere: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].sphere();
    },
    lineStart: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].lineStart();
    },
    lineEnd: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].lineEnd();
    },
    polygonStart: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].polygonStart();
    },
    polygonEnd: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x6, y4) {
    point6 = [x6, y4];
  } };
  function albersUsa(coordinates) {
    var x6 = coordinates[0], y4 = coordinates[1];
    return point6 = null, (lower48Point.point(x6, y4), point6) || (alaskaPoint.point(x6, y4), point6) || (hawaiiPoint.point(x6, y4), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k5 = lower48.scale(), t4 = lower48.translate(), x6 = (coordinates[0] - t4[0]) / k5, y4 = (coordinates[1] - t4[1]) / k5;
    return (y4 >= 0.12 && y4 < 0.234 && x6 >= -0.425 && x6 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x6 >= -0.214 && x6 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_3) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_3), alaska.precision(_3), hawaii.precision(_3);
    return reset();
  };
  albersUsa.scale = function(_3) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_3), alaska.scale(_3 * 0.35), hawaii.scale(_3);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_3) {
    if (!arguments.length)
      return lower48.translate();
    var k5 = lower48.scale(), x6 = +_3[0], y4 = +_3[1];
    lower48Point = lower48.translate(_3).clipExtent([[x6 - 0.455 * k5, y4 - 0.238 * k5], [x6 + 0.455 * k5, y4 + 0.238 * k5]]).stream(pointStream);
    alaskaPoint = alaska.translate([x6 - 0.307 * k5, y4 + 0.201 * k5]).clipExtent([[x6 - 0.425 * k5 + epsilon3, y4 + 0.12 * k5 + epsilon3], [x6 - 0.214 * k5 - epsilon3, y4 + 0.234 * k5 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x6 - 0.205 * k5, y4 + 0.212 * k5]).clipExtent([[x6 - 0.214 * k5 + epsilon3, y4 + 0.166 * k5 + epsilon3], [x6 - 0.115 * k5 - epsilon3, y4 + 0.234 * k5 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent3, object) {
    return fitExtent(albersUsa, extent3, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale) {
  return function(x6, y4) {
    var cx = cos(x6), cy = cos(y4), k5 = scale(cx * cy);
    if (k5 === Infinity)
      return [2, 0];
    return [
      k5 * cy * sin(x6),
      k5 * sin(y4)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x6, y4) {
    var z4 = sqrt(x6 * x6 + y4 * y4), c6 = angle(z4), sc = sin(c6), cc = cos(c6);
    return [
      atan2(x6 * sc, z4 * cc),
      asin(z4 && y4 * sc / z4)
    ];
  };
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z4) {
  return 2 * asin(z4 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
  return (c6 = acos(c6)) && c6 / sin(c6);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z4) {
  return z4;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}
mercatorRaw.invert = function(x6, y4) {
  return [x6, 2 * atan(exp(y4)) - halfPi];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project2) {
  var m3 = projection(project2), center2 = m3.center, scale = m3.scale, translate2 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
  m3.scale = function(_3) {
    return arguments.length ? (scale(_3), reclip()) : scale();
  };
  m3.translate = function(_3) {
    return arguments.length ? (translate2(_3), reclip()) : translate2();
  };
  m3.center = function(_3) {
    return arguments.length ? (center2(_3), reclip()) : center2();
  };
  m3.clipExtent = function(_3) {
    return arguments.length ? (_3 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_3[0][0], y05 = +_3[0][1], x12 = +_3[1][0], y12 = +_3[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k5 = pi2 * scale(), t4 = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t4[0] - k5, t4[1] - k5], [t4[0] + k5, t4[1] + k5]] : project2 === mercatorRaw ? [[Math.max(t4[0] - k5, x05), y05], [Math.min(t4[0] + k5, x12), y12]] : [[x05, Math.max(t4[1] - k5, y05)], [x12, Math.min(t4[1] + k5, y12)]]);
  }
  return reclip();
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi + y4) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos(y05), n2 = y05 === y12 ? sin(y05) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y05)), f3 = cy0 * pow(tany(y05), n2) / n2;
  if (!n2)
    return mercatorRaw;
  function project2(x6, y4) {
    if (f3 > 0) {
      if (y4 < -halfPi + epsilon3)
        y4 = -halfPi + epsilon3;
    } else {
      if (y4 > halfPi - epsilon3)
        y4 = halfPi - epsilon3;
    }
    var r3 = f3 / pow(tany(y4), n2);
    return [r3 * sin(n2 * x6), f3 - r3 * cos(n2 * x6)];
  }
  project2.invert = function(x6, y4) {
    var fy = f3 - y4, r3 = sign(n2) * sqrt(x6 * x6 + fy * fy), l3 = atan2(x6, abs2(fy)) * sign(fy);
    if (fy * n2 < 0)
      l3 -= pi2 * sign(x6) * sign(fy);
    return [l3 / n2, 2 * atan(pow(f3 / r3, 1 / n2)) - halfPi];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos(y05), n2 = y05 === y12 ? sin(y05) : (cy0 - cos(y12)) / (y12 - y05), g4 = cy0 / n2 + y05;
  if (abs2(n2) < epsilon3)
    return equirectangularRaw;
  function project2(x6, y4) {
    var gy = g4 - y4, nx = n2 * x6;
    return [gy * sin(nx), g4 - gy * cos(nx)];
  }
  project2.invert = function(x6, y4) {
    var gy = g4 - y4, l3 = atan2(x6, abs2(gy)) * sign(gy);
    if (gy * n2 < 0)
      l3 -= pi2 * sign(x6) * sign(gy);
    return [l3 / n2, g4 - sign(n2) * sqrt(x6 * x6 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A32 = 893e-6;
var A42 = 3796e-6;
var M4 = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l3 = asin(M4 * sin(phi)), l22 = l3 * l3, l6 = l22 * l22 * l22;
  return [
    lambda * cos(l3) / (M4 * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22))),
    l3 * (A1 + A22 * l22 + l6 * (A32 + A42 * l22))
  ];
}
equalEarthRaw.invert = function(x6, y4) {
  var l3 = y4, l22 = l3 * l3, l6 = l22 * l22 * l22;
  for (var i3 = 0, delta, fy, fpy; i3 < iterations; ++i3) {
    fy = l3 * (A1 + A22 * l22 + l6 * (A32 + A42 * l22)) - y4;
    fpy = A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22);
    l3 -= delta = fy / fpy, l22 = l3 * l3, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M4 * x6 * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22)) / cos(l3),
    asin(sin(l3) / M4)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x6, y4) {
  var cy = cos(y4), k5 = cos(x6) * cy;
  return [cy * sin(x6) / k5, sin(y4) / k5];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x6, y4) {
  return [cos(y4) * sin(x6), sin(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x6, y4) {
  var cy = cos(y4), k5 = 1 + cos(x6) * cy;
  return [cy * sin(x6) / k5, sin(y4) / k5];
}
stereographicRaw.invert = azimuthalInvert(function(z4) {
  return 2 * atan(z4);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/.pnpm/d3-geo@3.1.1/node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x6, y4) {
  return [-y4, 2 * atan(exp(x6)) - halfPi];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;
  m3.center = function(_3) {
    return arguments.length ? center2([-_3[1], _3[0]]) : (_3 = center2(), [_3[1], -_3[0]]);
  };
  m3.rotate = function(_3) {
    return arguments.length ? rotate([_3[0], _3[1], _3.length > 2 ? _3[2] + 90 : 90]) : (_3 = rotate(), [_3[0], _3[1], _3[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale(d3) {
    let i3 = index2.get(d3);
    if (i3 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d3, i3 = domain.push(d3) - 1);
    }
    return range3[i3 % range3.length];
  }
  scale.domain = function(_3) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _3) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_3) {
    return arguments.length ? (range3 = Array.from(_3), scale) : range3.slice();
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange2 = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n2 = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = range(n2).map(function(i3) {
      return start2 + step * i3;
    });
    return ordinalRange2(reverse2 ? values2.reverse() : values2);
  }
  scale.domain = function(_3) {
    return arguments.length ? (domain(_3), rescale()) : domain();
  };
  scale.range = function(_3) {
    return arguments.length ? ([r0, r1] = _3, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_3) {
    return [r0, r1] = _3, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_3) {
    return arguments.length ? (round = !!_3, rescale()) : round;
  };
  scale.padding = function(_3) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_3), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_3) {
    return arguments.length ? (paddingInner = Math.min(1, _3), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_3) {
    return arguments.length ? (paddingOuter = +_3, rescale()) : paddingOuter;
  };
  scale.align = function(_3) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _3)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/constant.js
function constants2(x6) {
  return function() {
    return x6;
  };
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/number.js
function number3(x6) {
  return +x6;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x6) {
  return x6;
}
function normalize2(a4, b3) {
  return (b3 -= a4 = +a4) ? function(x6) {
    return (x6 - a4) / b3;
  } : constants2(isNaN(b3) ? NaN : 0.5);
}
function clamper(a4, b3) {
  var t4;
  if (a4 > b3)
    t4 = a4, a4 = b3, b3 = t4;
  return function(x6) {
    return Math.max(a4, Math.min(b3, x6));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0)
    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
  return function(x6) {
    return r0(d0(x6));
  };
}
function polymap(domain, range3, interpolate) {
  var j4 = Math.min(domain.length, range3.length) - 1, d3 = new Array(j4), r3 = new Array(j4), i3 = -1;
  if (domain[j4] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i3 < j4) {
    d3[i3] = normalize2(domain[i3], domain[i3 + 1]);
    r3[i3] = interpolate(range3[i3], range3[i3 + 1]);
  }
  return function(x6) {
    var i4 = bisect_default(domain, x6, 1, j4) - 1;
    return r3[i4](d3[i4](x6));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range3.length);
    if (clamp !== identity3)
      clamp = clamper(domain[0], domain[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : (output || (output = piecewise2(domain.map(transform2), range3, interpolate)))(transform2(clamp(x6)));
  }
  scale.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise2(range3, domain.map(transform2), number_default)))(y4)));
  };
  scale.domain = function(_3) {
    return arguments.length ? (domain = Array.from(_3, number3), rescale()) : domain.slice();
  };
  scale.range = function(_3) {
    return arguments.length ? (range3 = Array.from(_3), rescale()) : range3.slice();
  };
  scale.rangeRound = function(_3) {
    return range3 = Array.from(_3), interpolate = round_default, rescale();
  };
  scale.clamp = function(_3) {
    return arguments.length ? (clamp = _3 ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale.interpolate = function(_3) {
    return arguments.length ? (interpolate = _3, rescale()) : interpolate;
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  return function(t4, u3) {
    transform2 = t4, untransform = u3;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity3, identity3);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d3 = domain();
    return ticks(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d3 = domain();
    return tickFormat(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d3 = domain();
    var i0 = 0;
    var i1 = d3.length - 1;
    var start2 = d3[i0];
    var stop = d3[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d3[i0] = start2;
        d3[i1] = stop;
        return domain(d3);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/identity.js
function identity4(domain) {
  var unknown;
  function scale(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : x6;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_3) {
    return arguments.length ? (domain = Array.from(_3, number3), scale) : domain.slice();
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  scale.copy = function() {
    return identity4(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x05 = domain[i0], x12 = domain[i1], t4;
  if (x12 < x05) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x05, x05 = x12, x12 = t4;
  }
  domain[i0] = interval2.floor(x05);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/log.js
function transformLog(x6) {
  return Math.log(x6);
}
function transformExp(x6) {
  return Math.exp(x6);
}
function transformLogn(x6) {
  return -Math.log(-x6);
}
function transformExpn(x6) {
  return -Math.exp(-x6);
}
function pow10(x6) {
  return isFinite(x6) ? +("1e" + x6) : x6 < 0 ? 0 : x6;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : (x6) => Math.pow(base2, x6);
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), (x6) => Math.log(x6) / base2);
}
function reflect(f3) {
  return (x6, k5) => -f3(-x6, k5);
}
function loggish(transform2) {
  const scale = transform2(transformLog, transformExp);
  const domain = scale.domain;
  let base2 = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_3) {
    return arguments.length ? (base2 = +_3, rescale()) : base2;
  };
  scale.domain = function(_3) {
    return arguments.length ? (domain(_3), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d3 = domain();
    let u3 = d3[0];
    let v3 = d3[d3.length - 1];
    const r3 = v3 < u3;
    if (r3)
      [u3, v3] = [v3, u3];
    let i3 = logs(u3);
    let j4 = logs(v3);
    let k5;
    let t4;
    const n2 = count2 == null ? 10 : +count2;
    let z4 = [];
    if (!(base2 % 1) && j4 - i3 < n2) {
      i3 = Math.floor(i3), j4 = Math.ceil(j4);
      if (u3 > 0)
        for (; i3 <= j4; ++i3) {
          for (k5 = 1; k5 < base2; ++k5) {
            t4 = i3 < 0 ? k5 / pows(-i3) : k5 * pows(i3);
            if (t4 < u3)
              continue;
            if (t4 > v3)
              break;
            z4.push(t4);
          }
        }
      else
        for (; i3 <= j4; ++i3) {
          for (k5 = base2 - 1; k5 >= 1; --k5) {
            t4 = i3 > 0 ? k5 / pows(-i3) : k5 * pows(i3);
            if (t4 < u3)
              continue;
            if (t4 > v3)
              break;
            z4.push(t4);
          }
        }
      if (z4.length * 2 < n2)
        z4 = ticks(u3, v3, n2);
    } else {
      z4 = ticks(i3, j4, Math.min(j4 - i3, n2)).map(pows);
    }
    return r3 ? z4.reverse() : z4;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base2 === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base2 % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k5 = Math.max(1, base2 * count2 / scale.ticks().length);
    return (d3) => {
      let i3 = d3 / pows(Math.round(logs(d3)));
      if (i3 * base2 < base2 - 0.5)
        i3 *= base2;
      return i3 <= k5 ? specifier(d3) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x6) => pows(Math.floor(logs(x6))),
      ceil: (x6) => pows(Math.ceil(logs(x6)))
    }));
  };
  return scale;
}
function log2() {
  const scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = () => copy(scale, log2()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/symlog.js
function transformSymlog(c6) {
  return function(x6) {
    return Math.sign(x6) * Math.log1p(Math.abs(x6 / c6));
  };
}
function transformSymexp(c6) {
  return function(x6) {
    return Math.sign(x6) * Math.expm1(Math.abs(x6)) * c6;
  };
}
function symlogish(transform2) {
  var c6 = 1, scale = transform2(transformSymlog(c6), transformSymexp(c6));
  scale.constant = function(_3) {
    return arguments.length ? transform2(transformSymlog(c6 = +_3), transformSymexp(c6)) : c6;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer2());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x6) {
    return x6 < 0 ? -Math.pow(-x6, exponent) : Math.pow(x6, exponent);
  };
}
function transformSqrt(x6) {
  return x6 < 0 ? -Math.sqrt(-x6) : Math.sqrt(x6);
}
function transformSquare(x6) {
  return x6 < 0 ? -x6 * x6 : x6 * x6;
}
function powish(transform2) {
  var scale = transform2(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity3, identity3) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_3) {
    return arguments.length ? (exponent = +_3, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow2() {
  var scale = powish(transformer2());
  scale.copy = function() {
    return copy(scale, pow2()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i3 = 0, n2 = Math.max(1, range3.length);
    thresholds = new Array(n2 - 1);
    while (++i3 < n2)
      thresholds[i3 - 1] = quantileSorted(domain, i3 / n2);
    return scale;
  }
  function scale(x6) {
    return x6 == null || isNaN(x6 = +x6) ? unknown : range3[bisect_default(thresholds, x6)];
  }
  scale.invertExtent = function(y4) {
    var i3 = range3.indexOf(y4);
    return i3 < 0 ? [NaN, NaN] : [
      i3 > 0 ? thresholds[i3 - 1] : domain[0],
      i3 < thresholds.length ? thresholds[i3] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_3) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d3 of _3)
      if (d3 != null && !isNaN(d3 = +d3))
        domain.push(d3);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_3) {
    return arguments.length ? (range3 = Array.from(_3), rescale()) : range3.slice();
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n2 = 1;
  function scale(x6) {
    return x6 != null && x6 <= x6 ? range3[bisect_default(domain, x6, 0, n2)] : unknown;
  }
  scale.domain = function(_3) {
    return arguments.length ? (domain = Array.from(_3), n2 = Math.min(domain.length, range3.length - 1), scale) : domain.slice();
  };
  scale.range = function(_3) {
    return arguments.length ? (range3 = Array.from(_3), n2 = Math.min(domain.length, range3.length - 1), scale) : range3.slice();
  };
  scale.invertExtent = function(y4) {
    var i3 = range3.indexOf(y4);
    return [domain[i3 - 1], domain[i3]];
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field2) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range3 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d3) => field2(d3) % step === 0 : (d3) => interval2.count(0, d3) % step === 0);
    };
  }
  return interval2;
}

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k5) => {
  k5 = Math.floor(k5);
  if (!isFinite(k5) || !(k5 > 0))
    return null;
  if (!(k5 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k5) * k5);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k5);
  }, (start2, end) => {
    return (end - start2) / k5;
  });
};
var milliseconds = millisecond.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/week.js
function timeWeekday(i3) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i3) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i3) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i3) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k5) => {
  return !isFinite(k5 = Math.floor(k5)) || !(k5 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k5) * k5);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k5);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k5) => {
  return !isFinite(k5 = Math.floor(k5)) || !(k5 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k5) * k5);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k5);
  });
};
var utcYears = utcYear.range;

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals2 = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i3 = bisector(([, , step2]) => step2).right(tickIntervals2, target);
    if (i3 === tickIntervals2.length)
      return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i3 === 0)
      return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t4, step] = tickIntervals2[target / tickIntervals2[i3 - 1][2] < tickIntervals2[i3][2] / target ? i3 - 1 : i3];
    return t4.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/locale.js
function localDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date2 = new Date(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
    date2.setFullYear(d3.y);
    return date2;
  }
  return new Date(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
}
function utcDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date2 = new Date(Date.UTC(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
    date2.setUTCFullYear(d3.y);
    return date2;
  }
  return new Date(Date.UTC(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
}
function newDate(y4, m3, d3) {
  return { y: y4, m: m3, d: d3, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale7) {
  var locale_dateTime = locale7.dateTime, locale_date = locale7.date, locale_time = locale7.time, locale_periods = locale7.periods, locale_weekdays = locale7.days, locale_shortWeekdays = locale7.shortDays, locale_months = locale7.months, locale_shortMonths = locale7.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i3 = -1, j4 = 0, n2 = specifier.length, c6, pad4, format3;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i3 < n2) {
        if (specifier.charCodeAt(i3) === 37) {
          string2.push(specifier.slice(j4, i3));
          if ((pad4 = pads[c6 = specifier.charAt(++i3)]) != null)
            c6 = specifier.charAt(++i3);
          else
            pad4 = c6 === "e" ? " " : "0";
          if (format3 = formats2[c6])
            c6 = format3(date2, pad4);
          string2.push(c6);
          j4 = i3 + 1;
        }
      }
      string2.push(specifier.slice(j4, i3));
      return string2.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string2) {
      var d3 = newDate(1900, void 0, 1), i3 = parseSpecifier(d3, specifier, string2 += "", 0), week, day;
      if (i3 != string2.length)
        return null;
      if ("Q" in d3)
        return new Date(d3.Q);
      if ("s" in d3)
        return new Date(d3.s * 1e3 + ("L" in d3 ? d3.L : 0));
      if (Z3 && !("Z" in d3))
        d3.Z = 0;
      if ("p" in d3)
        d3.H = d3.H % 12 + d3.p * 12;
      if (d3.m === void 0)
        d3.m = "q" in d3 ? d3.q : 0;
      if ("V" in d3) {
        if (d3.V < 1 || d3.V > 53)
          return null;
        if (!("w" in d3))
          d3.w = 1;
        if ("Z" in d3) {
          week = utcDate(newDate(d3.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getUTCFullYear();
          d3.m = week.getUTCMonth();
          d3.d = week.getUTCDate() + (d3.w + 6) % 7;
        } else {
          week = localDate(newDate(d3.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getFullYear();
          d3.m = week.getMonth();
          d3.d = week.getDate() + (d3.w + 6) % 7;
        }
      } else if ("W" in d3 || "U" in d3) {
        if (!("w" in d3))
          d3.w = "u" in d3 ? d3.u % 7 : "W" in d3 ? 1 : 0;
        day = "Z" in d3 ? utcDate(newDate(d3.y, 0, 1)).getUTCDay() : localDate(newDate(d3.y, 0, 1)).getDay();
        d3.m = 0;
        d3.d = "W" in d3 ? (d3.w + 6) % 7 + d3.W * 7 - (day + 5) % 7 : d3.w + d3.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d3) {
        d3.H += d3.Z / 100 | 0;
        d3.M += d3.Z % 100;
        return utcDate(d3);
      }
      return localDate(d3);
    };
  }
  function parseSpecifier(d3, specifier, string2, j4) {
    var i3 = 0, n2 = specifier.length, m3 = string2.length, c6, parse2;
    while (i3 < n2) {
      if (j4 >= m3)
        return -1;
      c6 = specifier.charCodeAt(i3++);
      if (c6 === 37) {
        c6 = specifier.charAt(i3++);
        parse2 = parses[c6 in pads ? specifier.charAt(i3++) : c6];
        if (!parse2 || (j4 = parse2(d3, string2, j4)) < 0)
          return -1;
      } else if (c6 != string2.charCodeAt(j4++)) {
        return -1;
      }
    }
    return j4;
  }
  function parsePeriod(d3, string2, i3) {
    var n2 = periodRe.exec(string2.slice(i3));
    return n2 ? (d3.p = periodLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseShortWeekday(d3, string2, i3) {
    var n2 = shortWeekdayRe.exec(string2.slice(i3));
    return n2 ? (d3.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseWeekday(d3, string2, i3) {
    var n2 = weekdayRe.exec(string2.slice(i3));
    return n2 ? (d3.w = weekdayLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseShortMonth(d3, string2, i3) {
    var n2 = shortMonthRe.exec(string2.slice(i3));
    return n2 ? (d3.m = shortMonthLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseMonth(d3, string2, i3) {
    var n2 = monthRe.exec(string2.slice(i3));
    return n2 ? (d3.m = monthLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d3, string2, i3) {
    return parseSpecifier(d3, locale_dateTime, string2, i3);
  }
  function parseLocaleDate(d3, string2, i3) {
    return parseSpecifier(d3, locale_date, string2, i3);
  }
  function parseLocaleTime(d3, string2, i3) {
    return parseSpecifier(d3, locale_time, string2, i3);
  }
  function formatShortWeekday(d3) {
    return locale_shortWeekdays[d3.getDay()];
  }
  function formatWeekday(d3) {
    return locale_weekdays[d3.getDay()];
  }
  function formatShortMonth(d3) {
    return locale_shortMonths[d3.getMonth()];
  }
  function formatMonth(d3) {
    return locale_months[d3.getMonth()];
  }
  function formatPeriod(d3) {
    return locale_periods[+(d3.getHours() >= 12)];
  }
  function formatQuarter(d3) {
    return 1 + ~~(d3.getMonth() / 3);
  }
  function formatUTCShortWeekday(d3) {
    return locale_shortWeekdays[d3.getUTCDay()];
  }
  function formatUTCWeekday(d3) {
    return locale_weekdays[d3.getUTCDay()];
  }
  function formatUTCShortMonth(d3) {
    return locale_shortMonths[d3.getUTCMonth()];
  }
  function formatUTCMonth(d3) {
    return locale_months[d3.getUTCMonth()];
  }
  function formatUTCPeriod(d3) {
    return locale_periods[+(d3.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d3) {
    return 1 + ~~(d3.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p4 = newParse(specifier += "", false);
      p4.toString = function() {
        return specifier;
      };
      return p4;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p4 = newParse(specifier += "", true);
      p4.toString = function() {
        return specifier;
      };
      return p4;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill, width) {
  var sign3 = value < 0 ? "-" : "", string2 = (sign3 ? -value : value) + "", length3 = string2.length;
  return sign3 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string2 : string2);
}
function requote(s4) {
  return s4.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i3) => [name.toLowerCase(), i3]));
}
function parseWeekdayNumberSunday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.w = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.u = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberSunday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.U = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberISO(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.V = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberMonday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.W = +n2[0], i3 + n2[0].length) : -1;
}
function parseFullYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 4));
  return n2 ? (d3.y = +n2[0], i3 + n2[0].length) : -1;
}
function parseYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i3 + n2[0].length) : -1;
}
function parseZone(d3, string2, i3) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i3, i3 + 6));
  return n2 ? (d3.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i3 + n2[0].length) : -1;
}
function parseQuarter(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.q = n2[0] * 3 - 3, i3 + n2[0].length) : -1;
}
function parseMonthNumber(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.m = n2[0] - 1, i3 + n2[0].length) : -1;
}
function parseDayOfMonth(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.d = +n2[0], i3 + n2[0].length) : -1;
}
function parseDayOfYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 3));
  return n2 ? (d3.m = 0, d3.d = +n2[0], i3 + n2[0].length) : -1;
}
function parseHour24(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.H = +n2[0], i3 + n2[0].length) : -1;
}
function parseMinutes(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.M = +n2[0], i3 + n2[0].length) : -1;
}
function parseSeconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.S = +n2[0], i3 + n2[0].length) : -1;
}
function parseMilliseconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 3));
  return n2 ? (d3.L = +n2[0], i3 + n2[0].length) : -1;
}
function parseMicroseconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 6));
  return n2 ? (d3.L = Math.floor(n2[0] / 1e3), i3 + n2[0].length) : -1;
}
function parseLiteralPercent(d3, string2, i3) {
  var n2 = percentRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? i3 + n2[0].length : -1;
}
function parseUnixTimestamp(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3));
  return n2 ? (d3.Q = +n2[0], i3 + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3));
  return n2 ? (d3.s = +n2[0], i3 + n2[0].length) : -1;
}
function formatDayOfMonth(d3, p4) {
  return pad2(d3.getDate(), p4, 2);
}
function formatHour24(d3, p4) {
  return pad2(d3.getHours(), p4, 2);
}
function formatHour12(d3, p4) {
  return pad2(d3.getHours() % 12 || 12, p4, 2);
}
function formatDayOfYear(d3, p4) {
  return pad2(1 + timeDay.count(timeYear(d3), d3), p4, 3);
}
function formatMilliseconds(d3, p4) {
  return pad2(d3.getMilliseconds(), p4, 3);
}
function formatMicroseconds(d3, p4) {
  return formatMilliseconds(d3, p4) + "000";
}
function formatMonthNumber(d3, p4) {
  return pad2(d3.getMonth() + 1, p4, 2);
}
function formatMinutes(d3, p4) {
  return pad2(d3.getMinutes(), p4, 2);
}
function formatSeconds(d3, p4) {
  return pad2(d3.getSeconds(), p4, 2);
}
function formatWeekdayNumberMonday(d3) {
  var day = d3.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d3, p4) {
  return pad2(timeSunday.count(timeYear(d3) - 1, d3), p4, 2);
}
function dISO(d3) {
  var day = d3.getDay();
  return day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
}
function formatWeekNumberISO(d3, p4) {
  d3 = dISO(d3);
  return pad2(timeThursday.count(timeYear(d3), d3) + (timeYear(d3).getDay() === 4), p4, 2);
}
function formatWeekdayNumberSunday(d3) {
  return d3.getDay();
}
function formatWeekNumberMonday(d3, p4) {
  return pad2(timeMonday.count(timeYear(d3) - 1, d3), p4, 2);
}
function formatYear2(d3, p4) {
  return pad2(d3.getFullYear() % 100, p4, 2);
}
function formatYearISO(d3, p4) {
  d3 = dISO(d3);
  return pad2(d3.getFullYear() % 100, p4, 2);
}
function formatFullYear(d3, p4) {
  return pad2(d3.getFullYear() % 1e4, p4, 4);
}
function formatFullYearISO(d3, p4) {
  var day = d3.getDay();
  d3 = day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
  return pad2(d3.getFullYear() % 1e4, p4, 4);
}
function formatZone(d3) {
  var z4 = d3.getTimezoneOffset();
  return (z4 > 0 ? "-" : (z4 *= -1, "+")) + pad2(z4 / 60 | 0, "0", 2) + pad2(z4 % 60, "0", 2);
}
function formatUTCDayOfMonth(d3, p4) {
  return pad2(d3.getUTCDate(), p4, 2);
}
function formatUTCHour24(d3, p4) {
  return pad2(d3.getUTCHours(), p4, 2);
}
function formatUTCHour12(d3, p4) {
  return pad2(d3.getUTCHours() % 12 || 12, p4, 2);
}
function formatUTCDayOfYear(d3, p4) {
  return pad2(1 + utcDay.count(utcYear(d3), d3), p4, 3);
}
function formatUTCMilliseconds(d3, p4) {
  return pad2(d3.getUTCMilliseconds(), p4, 3);
}
function formatUTCMicroseconds(d3, p4) {
  return formatUTCMilliseconds(d3, p4) + "000";
}
function formatUTCMonthNumber(d3, p4) {
  return pad2(d3.getUTCMonth() + 1, p4, 2);
}
function formatUTCMinutes(d3, p4) {
  return pad2(d3.getUTCMinutes(), p4, 2);
}
function formatUTCSeconds(d3, p4) {
  return pad2(d3.getUTCSeconds(), p4, 2);
}
function formatUTCWeekdayNumberMonday(d3) {
  var dow = d3.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d3, p4) {
  return pad2(utcSunday.count(utcYear(d3) - 1, d3), p4, 2);
}
function UTCdISO(d3) {
  var day = d3.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
}
function formatUTCWeekNumberISO(d3, p4) {
  d3 = UTCdISO(d3);
  return pad2(utcThursday.count(utcYear(d3), d3) + (utcYear(d3).getUTCDay() === 4), p4, 2);
}
function formatUTCWeekdayNumberSunday(d3) {
  return d3.getUTCDay();
}
function formatUTCWeekNumberMonday(d3, p4) {
  return pad2(utcMonday.count(utcYear(d3) - 1, d3), p4, 2);
}
function formatUTCYear(d3, p4) {
  return pad2(d3.getUTCFullYear() % 100, p4, 2);
}
function formatUTCYearISO(d3, p4) {
  d3 = UTCdISO(d3);
  return pad2(d3.getUTCFullYear() % 100, p4, 2);
}
function formatUTCFullYear(d3, p4) {
  return pad2(d3.getUTCFullYear() % 1e4, p4, 4);
}
function formatUTCFullYearISO(d3, p4) {
  var day = d3.getUTCDay();
  d3 = day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
  return pad2(d3.getUTCFullYear() % 1e4, p4, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d3) {
  return +d3;
}
function formatUnixTimestampSeconds(d3) {
  return Math.floor(+d3 / 1e3);
}

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/defaultLocale.js
var locale6;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale6 = formatLocale(definition);
  timeFormat = locale6.format;
  timeParse = locale6.parse;
  utcFormat = locale6.utcFormat;
  utcParse = locale6.utcParse;
  return locale6;
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/time.js
function date(t4) {
  return new Date(t4);
}
function number4(t4) {
  return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear4 = format3("%Y");
  function tickFormat2(date2) {
    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear4)(date2);
  }
  scale.invert = function(y4) {
    return new Date(invert(y4));
  };
  scale.domain = function(_3) {
    return arguments.length ? domain(Array.from(_3, number4)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d3 = domain();
    return ticks2(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale.nice = function(interval2) {
    var d3 = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d3, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequential.js
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x05 = 0, x12 = 0.5, x22 = 1, s4 = 1, t03, t13, t23, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
  function scale(x6) {
    return isNaN(x6 = +x6) ? unknown : (x6 = 0.5 + ((x6 = +transform2(x6)) - t13) * (s4 * x6 < s4 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x6)) : x6));
  }
  scale.domain = function(_3) {
    return arguments.length ? ([x05, x12, x22] = _3, t03 = transform2(x05 = +x05), t13 = transform2(x12 = +x12), t23 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s4 = t13 < t03 ? -1 : 1, scale) : [x05, x12, x22];
  };
  scale.clamp = function(_3) {
    return arguments.length ? (clamp = !!_3, scale) : clamp;
  };
  scale.interpolator = function(_3) {
    return arguments.length ? (interpolator = _3, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_3) {
      var r0, r1, r22;
      return arguments.length ? ([r0, r1, r22] = _3, interpolator = piecewise(interpolate, [r0, r1, r22]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x05), t13 = t4(x12), t23 = t4(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s4 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity3));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i3 = 0;
  while (i3 < n2)
    colors[i3] = "#" + specifier.slice(i3 * 6, ++i3 * 6);
  return colors;
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t4 * (35.34 - t4 * (2381.73 - t4 * (6402.7 - t4 * (7024.72 - t4 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t4 * (170.73 + t4 * (52.82 - t4 * (131.46 - t4 * (176.58 - t4 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t4 * (442.36 - t4 * (2482.43 - t4 * (6167.24 - t4 * (6614.94 - t4 * 2475.67))))))) + ")";
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t4) {
  if (t4 < 0 || t4 > 1)
    t4 -= Math.floor(t4);
  var ts = Math.abs(t4 - 0.5);
  c3.h = 360 * t4 - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t4) {
  var x6;
  t4 = (0.5 - t4) * Math.PI;
  c4.r = 255 * (x6 = Math.sin(t4)) * x6;
  c4.g = 255 * (x6 = Math.sin(t4 + pi_1_3)) * x6;
  c4.b = 255 * (x6 = Math.sin(t4 + pi_2_3)) * x6;
  return c4 + "";
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t4 * (1172.33 - t4 * (10793.56 - t4 * (33300.12 - t4 * (38394.49 - t4 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t4 * (557.33 + t4 * (1225.33 - t4 * (3574.96 - t4 * (1073.77 + t4 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t4 * (3211.1 - t4 * (15327.97 - t4 * (27814 - t4 * (22569.18 - t4 * 6838.66))))))) + ")";
}

// node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n2 = range3.length;
  return function(t4) {
    return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t4 * n2)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/constant.js
function constant_default4(x6) {
  return function constant2() {
    return x6;
  };
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/math.js
var cos2 = Math.cos;
var min3 = Math.min;
var sin2 = Math.sin;
var sqrt3 = Math.sqrt;
var epsilon4 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var tau3 = 2 * pi3;

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_3) {
    if (!arguments.length)
      return digits;
    if (_3 == null) {
      digits = null;
    } else {
      const d3 = Math.floor(_3);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_3}`);
      digits = d3;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x6) {
  return typeof x6 === "object" && "length" in x6 ? x6 : Array.from(x6);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x6, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/point.js
function x4(p4) {
  return p4[0];
}
function y3(p4) {
  return p4[1];
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/line.js
function line_default2(x6, y4) {
  var defined2 = constant_default4(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);
  x6 = typeof x6 === "function" ? x6 : x6 === void 0 ? x4 : constant_default4(x6);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default4(y4);
  function line2(data) {
    var i3, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i3 = 0; i3 <= n2; ++i3) {
      if (!(i3 < n2 && defined2(d3 = data[i3], i3, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x6(d3, i3, data), +y4(d3, i3, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line2.x = function(_3) {
    return arguments.length ? (x6 = typeof _3 === "function" ? _3 : constant_default4(+_3), line2) : x6;
  };
  line2.y = function(_3) {
    return arguments.length ? (y4 = typeof _3 === "function" ? _3 : constant_default4(+_3), line2) : y4;
  };
  line2.defined = function(_3) {
    return arguments.length ? (defined2 = typeof _3 === "function" ? _3 : constant_default4(!!_3), line2) : defined2;
  };
  line2.curve = function(_3) {
    return arguments.length ? (curve = _3, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_3) {
    return arguments.length ? (_3 == null ? context = output = null : output = curve(context = _3), line2) : context;
  };
  return line2;
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/area.js
function area_default2(x05, y05, y12) {
  var x12 = null, defined2 = constant_default4(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x4 : constant_default4(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default4(0) : constant_default4(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default4(+y12);
  function area2(data) {
    var i3, j4, k5, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null)
      output = curve(buffer = path2());
    for (i3 = 0; i3 <= n2; ++i3) {
      if (!(i3 < n2 && defined2(d3 = data[i3], i3, data)) === defined0) {
        if (defined0 = !defined0) {
          j4 = i3;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k5 = i3 - 1; k5 >= j4; --k5) {
            output.point(x0z[k5], y0z[k5]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i3] = +x05(d3, i3, data), y0z[i3] = +y05(d3, i3, data);
        output.point(x12 ? +x12(d3, i3, data) : x0z[i3], y12 ? +y12(d3, i3, data) : y0z[i3]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined2).curve(curve).context(context);
  }
  area2.x = function(_3) {
    return arguments.length ? (x05 = typeof _3 === "function" ? _3 : constant_default4(+_3), x12 = null, area2) : x05;
  };
  area2.x0 = function(_3) {
    return arguments.length ? (x05 = typeof _3 === "function" ? _3 : constant_default4(+_3), area2) : x05;
  };
  area2.x1 = function(_3) {
    return arguments.length ? (x12 = _3 == null ? null : typeof _3 === "function" ? _3 : constant_default4(+_3), area2) : x12;
  };
  area2.y = function(_3) {
    return arguments.length ? (y05 = typeof _3 === "function" ? _3 : constant_default4(+_3), y12 = null, area2) : y05;
  };
  area2.y0 = function(_3) {
    return arguments.length ? (y05 = typeof _3 === "function" ? _3 : constant_default4(+_3), area2) : y05;
  };
  area2.y1 = function(_3) {
    return arguments.length ? (y12 = _3 == null ? null : typeof _3 === "function" ? _3 : constant_default4(+_3), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_3) {
    return arguments.length ? (defined2 = typeof _3 === "function" ? _3 : constant_default4(!!_3), area2) : defined2;
  };
  area2.curve = function(_3) {
    return arguments.length ? (curve = _3, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_3) {
    return arguments.length ? (_3 == null ? context = output = null : output = curve(context = _3), area2) : context;
  };
  return area2;
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x6) {
    this._context = context;
    this._x = x6;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line)
          this._context.lineTo(x6, y4);
        else
          this._context.moveTo(x6, y4);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x)
          this._context.bezierCurveTo(this._x0 = (this._x0 + x6) / 2, this._y0, this._x0, y4, x6, y4);
        else
          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x6, this._y0, x6, y4);
        break;
      }
    }
    this._x0 = x6, this._y0 = y4;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);
var asterisk_default = {
  draw(context, size) {
    const r3 = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
    const t4 = r3 / 2;
    const u3 = t4 * sqrt32;
    context.moveTo(0, r3);
    context.lineTo(0, -r3);
    context.moveTo(-u3, -t4);
    context.lineTo(u3, t4);
    context.moveTo(-u3, t4);
    context.lineTo(u3, -t4);
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/circle.js
var circle_default2 = {
  draw(context, size) {
    const r3 = sqrt3(size / pi3);
    context.moveTo(r3, 0);
    context.arc(0, 0, r3, 0, tau3);
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r3 = sqrt3(size / 5) / 2;
    context.moveTo(-3 * r3, -r3);
    context.lineTo(-r3, -r3);
    context.lineTo(-r3, -3 * r3);
    context.lineTo(r3, -3 * r3);
    context.lineTo(r3, -r3);
    context.lineTo(3 * r3, -r3);
    context.lineTo(3 * r3, r3);
    context.lineTo(r3, r3);
    context.lineTo(r3, 3 * r3);
    context.lineTo(-r3, 3 * r3);
    context.lineTo(-r3, r3);
    context.lineTo(-3 * r3, r3);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y4 = sqrt3(size / tan30_2);
    const x6 = y4 * tan30;
    context.moveTo(0, -y4);
    context.lineTo(x6, 0);
    context.lineTo(0, y4);
    context.lineTo(-x6, 0);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r3 = sqrt3(size) * 0.62625;
    context.moveTo(0, -r3);
    context.lineTo(r3, 0);
    context.lineTo(0, r3);
    context.lineTo(-r3, 0);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r3 = sqrt3(size - min3(size / 7, 2)) * 0.87559;
    context.moveTo(-r3, 0);
    context.lineTo(r3, 0);
    context.moveTo(0, r3);
    context.lineTo(0, -r3);
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w4 = sqrt3(size);
    const x6 = -w4 / 2;
    context.rect(x6, x6, w4, w4);
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r3 = sqrt3(size) * 0.4431;
    context.moveTo(r3, r3);
    context.lineTo(r3, -r3);
    context.lineTo(-r3, -r3);
    context.lineTo(-r3, r3);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin2(pi3 / 10) / sin2(7 * pi3 / 10);
var kx = sin2(tau3 / 10) * kr;
var ky = -cos2(tau3 / 10) * kr;
var star_default = {
  draw(context, size) {
    const r3 = sqrt3(size * ka);
    const x6 = kx * r3;
    const y4 = ky * r3;
    context.moveTo(0, -r3);
    context.lineTo(x6, y4);
    for (let i3 = 1; i3 < 5; ++i3) {
      const a4 = tau3 * i3 / 5;
      const c6 = cos2(a4);
      const s4 = sin2(a4);
      context.lineTo(s4 * r3, -c6 * r3);
      context.lineTo(c6 * x6 - s4 * y4, s4 * x6 + c6 * y4);
    }
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);
var triangle_default = {
  draw(context, size) {
    const y4 = -sqrt3(size / (sqrt33 * 3));
    context.moveTo(0, y4 * 2);
    context.lineTo(-sqrt33 * y4, -y4);
    context.lineTo(sqrt33 * y4, -y4);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);
var triangle2_default = {
  draw(context, size) {
    const s4 = sqrt3(size) * 0.6824;
    const t4 = s4 / 2;
    const u3 = s4 * sqrt34 / 2;
    context.moveTo(0, -s4);
    context.lineTo(u3, t4);
    context.lineTo(-u3, t4);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/wye.js
var c5 = -0.5;
var s3 = sqrt3(3) / 2;
var k4 = 1 / sqrt3(12);
var a3 = (k4 / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r3 = sqrt3(size / a3);
    const x05 = r3 / 2, y05 = r3 * k4;
    const x12 = x05, y12 = r3 * k4 + r3;
    const x22 = -x12, y22 = y12;
    context.moveTo(x05, y05);
    context.lineTo(x12, y12);
    context.lineTo(x22, y22);
    context.lineTo(c5 * x05 - s3 * y05, s3 * x05 + c5 * y05);
    context.lineTo(c5 * x12 - s3 * y12, s3 * x12 + c5 * y12);
    context.lineTo(c5 * x22 - s3 * y22, s3 * x22 + c5 * y22);
    context.lineTo(c5 * x05 + s3 * y05, c5 * y05 - s3 * x05);
    context.lineTo(c5 * x12 + s3 * y12, c5 * y12 - s3 * x12);
    context.lineTo(c5 * x22 + s3 * y22, c5 * y22 - s3 * x22);
    context.closePath();
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r3 = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r3, -r3);
    context.lineTo(r3, r3);
    context.moveTo(-r3, r3);
    context.lineTo(r3, -r3);
  }
};

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default2,
  cross_default,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
var symbolsStroke = [
  circle_default2,
  plus_default,
  times_default,
  triangle2_default,
  asterisk_default,
  square2_default,
  diamond2_default
];

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basis.js
function point2(that, x6, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x6) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x6, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x6, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x6, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x6) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point2(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x6) / 6, y05 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x6 = this._x, y4 = this._y, j4 = x6.length - 1;
    if (j4 > 0) {
      var x05 = x6[0], y05 = y4[0], dx = x6[j4] - x05, dy = y4[j4] - y05, i3 = -1, t4;
      while (++i3 <= j4) {
        t4 = i3 / j4;
        this._basis.point(
          this._beta * x6[i3] + (1 - this._beta) * (x05 + t4 * dx),
          this._beta * y4[i3] + (1 - this._beta) * (y05 + t4 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x6, y4) {
    this._x.push(+x6);
    this._y.push(+y4);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x6, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x6),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x6, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x6, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x6, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x6, this._y5 = y4;
        break;
      default:
        point3(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x6, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x6, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon4) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y12 = (y12 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon4) {
    var b3 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b3 + that._x1 * that._l23_2a - x6 * that._l12_2a) / m3;
    y22 = (y22 * b3 + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x6, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x6, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x6, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x6, this._y5 = y4;
        break;
      default:
        point4(this, x6, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x6, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x6, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x6;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    if (this._point)
      this._context.lineTo(x6, y4);
    else
      this._point = 1, this._context.moveTo(x6, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/monotone.js
function sign2(x6) {
  return x6 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p4 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p4)) || 0;
}
function slope2(that, t4) {
  var h3 = that._x1 - that._x0;
  return h3 ? (3 * (that._y1 - that._y0) / h3 - t4) / 2 : t4;
}
function point5(that, t03, t13) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    var t13 = NaN;
    x6 = +x6, y4 = +y4;
    if (x6 === this._x1 && y4 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x6, y4)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x6, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x6;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x6, y4) {
  MonotoneX.prototype.point.call(this, y4, x6);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x6, y4) {
    this._context.moveTo(y4, x6);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x6, y4) {
    this._context.lineTo(y4, x6);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x6, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x6);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x6 = this._x, y4 = this._y, n2 = x6.length;
    if (n2) {
      this._line ? this._context.lineTo(x6[0], y4[0]) : this._context.moveTo(x6[0], y4[0]);
      if (n2 === 2) {
        this._context.lineTo(x6[1], y4[1]);
      } else {
        var px = controlPoints(x6), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x6[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x6, y4) {
    this._x.push(+x6);
    this._y.push(+y4);
  }
};
function controlPoints(x6) {
  var i3, n2 = x6.length - 1, m3, a4 = new Array(n2), b3 = new Array(n2), r3 = new Array(n2);
  a4[0] = 0, b3[0] = 2, r3[0] = x6[0] + 2 * x6[1];
  for (i3 = 1; i3 < n2 - 1; ++i3)
    a4[i3] = 1, b3[i3] = 4, r3[i3] = 4 * x6[i3] + 2 * x6[i3 + 1];
  a4[n2 - 1] = 2, b3[n2 - 1] = 7, r3[n2 - 1] = 8 * x6[n2 - 1] + x6[n2];
  for (i3 = 1; i3 < n2; ++i3)
    m3 = a4[i3] / b3[i3 - 1], b3[i3] -= m3, r3[i3] -= m3 * r3[i3 - 1];
  a4[n2 - 1] = r3[n2 - 1] / b3[n2 - 1];
  for (i3 = n2 - 2; i3 >= 0; --i3)
    a4[i3] = (r3[i3] - a4[i3 + 1]) / b3[i3];
  b3[n2 - 1] = (x6[n2] + a4[n2 - 1]) / 2;
  for (i3 = 0; i3 < n2 - 1; ++i3)
    b3[i3] = 2 * x6[i3 + 1] - a4[i3 + 1];
  return [a4, b3];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/step.js
function Step(context, t4) {
  this._context = context;
  this._t = t4;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x6, y4) {
    x6 = +x6, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x6, y4) : this._context.moveTo(x6, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x6, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x6 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x6, this._y = y4;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/transform.js
function Transform(k5, x6, y4) {
  this.k = k5;
  this.x = x6;
  this.y = y4;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k5) {
    return k5 === 1 ? this : new Transform(this.k * k5, this.x, this.y);
  },
  translate: function(x6, y4) {
    return x6 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x6, this.y + this.k * y4);
  },
  apply: function(point6) {
    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
  },
  applyX: function(x6) {
    return x6 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x6) {
    return (x6 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x6) {
    return x6.copy().domain(x6.range().map(this.invertX, this).map(x6.invert, x6));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity5 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity5;
  return node.__zoom;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/defined.js
function defined(x6) {
  return x6 != null && !Number.isNaN(x6);
}
function ascendingDefined2(a4, b3) {
  return +defined(b3) - +defined(a4) || ascending(a4, b3);
}
function descendingDefined(a4, b3) {
  return +defined(b3) - +defined(a4) || descending(a4, b3);
}
function nonempty(x6) {
  return x6 != null && `${x6}` !== "";
}
function finite(x6) {
  return isFinite(x6) ? x6 : NaN;
}
function positive(x6) {
  return x6 > 0 && isFinite(x6) ? x6 : NaN;
}
function negative(x6) {
  return x6 < 0 && isFinite(x6) ? x6 : NaN;
}

// node_modules/.pnpm/isoformat@0.2.1/node_modules/isoformat/src/format.js
function format2(date2, fallback) {
  if (!(date2 instanceof Date))
    date2 = /* @__PURE__ */ new Date(+date2);
  if (isNaN(date2))
    return typeof fallback === "function" ? fallback(date2) : fallback;
  const hours = date2.getUTCHours();
  const minutes = date2.getUTCMinutes();
  const seconds2 = date2.getUTCSeconds();
  const milliseconds2 = date2.getUTCMilliseconds();
  return `${formatYear3(date2.getUTCFullYear(), 4)}-${pad3(date2.getUTCMonth() + 1, 2)}-${pad3(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad3(hours, 2)}:${pad3(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad3(seconds2, 2)}${milliseconds2 ? `.${pad3(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear3(year) {
  return year < 0 ? `-${pad3(-year, 6)}` : year > 9999 ? `+${pad3(year, 6)}` : pad3(year, 4);
}
function pad3(value, width) {
  return `${value}`.padStart(width, "0");
}

// node_modules/.pnpm/isoformat@0.2.1/node_modules/isoformat/src/parse.js
var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re2.test(string2 += ""))
    return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/order.js
function orderof(values2) {
  if (values2 == null)
    return;
  const first2 = values2[0];
  const last = values2[values2.length - 1];
  return descending(first2, last);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var tickIntervals = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", durationSecond2],
  ["5 seconds", 5 * durationSecond2],
  ["15 seconds", 15 * durationSecond2],
  ["30 seconds", 30 * durationSecond2],
  ["minute", durationMinute2],
  ["5 minutes", 5 * durationMinute2],
  ["15 minutes", 15 * durationMinute2],
  ["30 minutes", 30 * durationMinute2],
  ["hour", durationHour2],
  ["3 hours", 3 * durationHour2],
  ["6 hours", 6 * durationHour2],
  ["12 hours", 12 * durationHour2],
  ["day", durationDay2],
  ["2 days", 2 * durationDay2],
  ["week", durationWeek2],
  ["2 weeks", 2 * durationWeek2],
  // https://github.com/d3/d3-time/issues/46
  ["month", durationMonth2],
  ["3 months", 3 * durationMonth2],
  ["6 months", 6 * durationMonth2],
  // https://github.com/d3/d3-time/issues/46
  ["year", durationYear2],
  ["2 years", 2 * durationYear2],
  ["5 years", 5 * durationYear2],
  ["10 years", 10 * durationYear2],
  ["20 years", 20 * durationYear2],
  ["50 years", 50 * durationYear2],
  ["100 years", 100 * durationYear2]
  // TODO generalize to longer time scales
];
var durations = /* @__PURE__ */ new Map([
  ["second", durationSecond2],
  ["minute", durationMinute2],
  ["hour", durationHour2],
  ["day", durationDay2],
  ["monday", durationWeek2],
  ["tuesday", durationWeek2],
  ["wednesday", durationWeek2],
  ["thursday", durationWeek2],
  ["friday", durationWeek2],
  ["saturday", durationWeek2],
  ["sunday", durationWeek2],
  ["week", durationWeek2],
  ["month", durationMonth2],
  ["year", durationYear2]
]);
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // https://github.com/d3/d3-time/issues/62
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday],
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear]
]);
var intervalDuration = Symbol("intervalDuration");
var intervalType = Symbol("intervalType");
for (const [name, interval2] of timeIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "time";
}
for (const [name, interval2] of utcIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "utc";
}
var utcFormatIntervals = [
  ["year", utcYear, "utc"],
  ["month", utcMonth, "utc"],
  ["day", unixDay, "utc", 6 * durationMonth2],
  ["hour", utcHour, "utc", 3 * durationDay2],
  ["minute", utcMinute, "utc", 6 * durationHour2],
  ["second", second, "utc", 30 * durationMinute2]
];
var timeFormatIntervals = [
  ["year", timeYear, "time"],
  ["month", timeMonth, "time"],
  ["day", timeDay, "time", 6 * durationMonth2],
  ["hour", timeHour, "time", 3 * durationDay2],
  ["minute", timeMinute, "time", 6 * durationHour2],
  ["second", second, "time", 30 * durationMinute2]
];
var formatIntervals = [
  utcFormatIntervals[0],
  timeFormatIntervals[0],
  utcFormatIntervals[1],
  timeFormatIntervals[1],
  utcFormatIntervals[2],
  timeFormatIntervals[2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we don’t consider these if the domain only has a single value.
  ...utcFormatIntervals.slice(3)
];
function parseTimeInterval(input) {
  let name = `${input}`.toLowerCase();
  if (name.endsWith("s"))
    name = name.slice(0, -1);
  let period = 1;
  const match5 = /^(?:(\d+)\s+)/.exec(name);
  if (match5) {
    name = name.slice(match5[0].length);
    period = +match5[1];
  }
  switch (name) {
    case "quarter":
      name = "month";
      period *= 3;
      break;
    case "half":
      name = "month";
      period *= 6;
      break;
  }
  let interval2 = utcIntervals.get(name);
  if (!interval2)
    throw new Error(`unknown interval: ${input}`);
  if (period > 1 && !interval2.every)
    throw new Error(`non-periodic interval: ${name}`);
  return [name, period];
}
function maybeTimeInterval(input) {
  return asInterval(parseTimeInterval(input), "time");
}
function maybeUtcInterval(input) {
  return asInterval(parseTimeInterval(input), "utc");
}
function asInterval([name, period], type2) {
  let interval2 = (type2 === "time" ? timeIntervals : utcIntervals).get(name);
  if (period > 1) {
    interval2 = interval2.every(period);
    interval2[intervalDuration] = durations.get(name) * period;
    interval2[intervalType] = type2;
  }
  return interval2;
}
function generalizeTimeInterval(interval2, n2) {
  if (!(n2 > 1))
    return;
  const duration = interval2[intervalDuration];
  if (!tickIntervals.some(([, d3]) => d3 === duration))
    return;
  if (duration % durationDay2 === 0 && durationDay2 < duration && duration < durationMonth2)
    return;
  const [i3] = tickIntervals[bisector(([, step]) => Math.log(step)).center(tickIntervals, Math.log(duration * n2))];
  return (interval2[intervalType] === "time" ? maybeTimeInterval : maybeUtcInterval)(i3);
}
function formatTimeInterval(name, type2, anchor) {
  const format3 = type2 === "time" ? timeFormat : utcFormat;
  if (anchor == null) {
    return format3(
      name === "year" ? "%Y" : name === "month" ? "%Y-%m" : name === "day" ? "%Y-%m-%d" : name === "hour" || name === "minute" ? "%Y-%m-%dT%H:%M" : name === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
    );
  }
  const template2 = getTimeTemplate(anchor);
  switch (name) {
    case "millisecond":
      return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
    case "second":
      return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
    case "minute":
      return formatConditional(format3("%-I:%M"), format3("%p"), template2);
    case "hour":
      return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
    case "day":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "month":
      return formatConditional(format3("%b"), format3("%Y"), template2);
    case "year":
      return format3("%Y");
  }
  throw new Error("unable to format time ticks");
}
function getTimeTemplate(anchor) {
  return anchor === "left" || anchor === "right" ? (f1, f22) => `
${f1}
${f22}` : anchor === "top" ? (f1, f22) => `${f22}
${f1}` : (f1, f22) => `${f1}
${f22}`;
}
function getFormatIntervals(type2) {
  return type2 === "time" ? timeFormatIntervals : type2 === "utc" ? utcFormatIntervals : formatIntervals;
}
function inferTimeFormat(type2, dates, anchor) {
  const step = max(pairs(dates, (a4, b3) => Math.abs(b3 - a4)));
  if (step < 1e3)
    return formatTimeInterval("millisecond", "utc", anchor);
  for (const [name, interval2, intervalType2, maxStep] of getFormatIntervals(type2)) {
    if (step > maxStep)
      break;
    if (name === "hour" && !step)
      break;
    if (dates.every((d3) => interval2.floor(d3) >= d3))
      return formatTimeInterval(name, intervalType2, anchor);
  }
}
function formatConditional(format1, format22, template2) {
  return (x6, i3, X4) => {
    const f1 = format1(x6, i3);
    const f22 = format22(x6, i3);
    const j4 = i3 - orderof(X4);
    return i3 !== j4 && X4[j4] !== void 0 && f22 === format22(X4[j4], j4) ? f1 : template2(f1, f22);
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
var reindex = Symbol("reindex");
function valueof(data, value, type2) {
  const valueType = typeof value;
  return valueType === "string" ? maybeTypedMap(data, field(value), type2) : valueType === "function" ? maybeTypedMap(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map3(data, constant(value), type2) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type2) : maybeTake(maybeTypedArrayify(value, type2), data?.[reindex]);
}
function maybeTake(values2, index2) {
  return index2 ? take(values2, index2) : values2;
}
function maybeTypedMap(data, f3, type2) {
  return map3(data, type2?.prototype instanceof TypedArray ? floater(f3) : f3, type2);
}
function maybeTypedArrayify(data, type2) {
  return type2 === void 0 ? arrayify2(data) : data instanceof type2 ? data : type2.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type2.from(data, coerceNumber) : type2.from(data);
}
function floater(f3) {
  return (d3, i3) => coerceNumber(f3(d3, i3));
}
var singleton = [null];
var field = (name) => (d3) => d3[name];
var indexOf = { transform: range2 };
var identity6 = { transform: (d3) => d3 };
var one2 = () => 1;
var yes = () => true;
var string = (x6) => x6 == null ? x6 : `${x6}`;
var number5 = (x6) => x6 == null ? x6 : +x6;
var first = (x6) => x6 ? x6[0] : void 0;
var second2 = (x6) => x6 ? x6[1] : void 0;
var constant = (x6) => () => x6;
function percentile(reduce2) {
  const p4 = +`${reduce2}`.slice(1) / 100;
  return (I4, f3) => quantile(I4, p4, f3);
}
function coerceNumbers(values2) {
  return values2 instanceof TypedArray ? values2 : map3(values2, coerceNumber, Float64Array);
}
function coerceNumber(x6) {
  return x6 == null ? NaN : Number(x6);
}
function coerceDates(values2) {
  return map3(values2, coerceDate);
}
function coerceDate(x6) {
  return x6 instanceof Date && !isNaN(x6) ? x6 : typeof x6 === "string" ? parse(x6) : x6 == null || isNaN(x6 = +x6) ? void 0 : new Date(x6);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input, name, allowed) {
  if (input != null)
    return keyword(input, name, allowed);
}
function keyword(input, name, allowed) {
  const i3 = `${input}`.toLowerCase();
  if (!allowed.includes(i3))
    throw new Error(`invalid ${name}: ${input}`);
  return i3;
}
function arrayify2(data) {
  return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
}
function map3(values2, f3, type2 = Array) {
  return values2 == null ? values2 : values2 instanceof type2 ? values2.map(f3) : type2.from(values2, f3);
}
function slice2(values2, type2 = Array) {
  return values2 instanceof type2 ? values2.slice() : type2.from(values2);
}
function hasY({ y: y4, y1: y12, y2: y22 }) {
  return y4 !== void 0 || y12 !== void 0 || y22 !== void 0;
}
function isObject(option) {
  return option?.toString === objectToString;
}
function isScaleOptions(option) {
  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject(option) && typeof option.transform !== "function";
}
function isDomainSort(sort2) {
  return isOptions(sort2) && sort2.value === void 0 && sort2.channel === void 0;
}
function maybeZero(x6, x12, x22, x32 = identity6) {
  if (x12 === void 0 && x22 === void 0) {
    x12 = 0, x22 = x6 === void 0 ? x32 : x6;
  } else if (x12 === void 0) {
    x12 = x6 === void 0 ? 0 : x6;
  } else if (x22 === void 0) {
    x22 = x6 === void 0 ? 0 : x6;
  }
  return [x12, x22];
}
function maybeTuple(x6, y4) {
  return x6 === void 0 && y4 === void 0 ? [first, second2] : [x6, y4];
}
function maybeZ({ z: z4, fill, stroke } = {}) {
  if (z4 === void 0)
    [z4] = maybeColorChannel(fill);
  if (z4 === void 0)
    [z4] = maybeColorChannel(stroke);
  return z4;
}
function range2(data) {
  const n2 = data.length;
  const r3 = new Uint32Array(n2);
  for (let i3 = 0; i3 < n2; ++i3)
    r3[i3] = i3;
  return r3;
}
function take(values2, index2) {
  return map3(index2, (i3) => values2[i3], values2.constructor);
}
function subarray(I4, i3, j4) {
  return I4.subarray ? I4.subarray(i3, j4) : I4.slice(i3, j4);
}
function keyof2(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0)
    return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v3) => value = v3
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x12, x22) {
  return {
    transform(data) {
      const X12 = x12.transform(data);
      const X23 = x22.transform(data);
      return isTemporal(X12) || isTemporal(X23) ? map3(X12, (_3, i3) => new Date((+X12[i3] + +X23[i3]) / 2)) : map3(X12, (_3, i3) => (+X12[i3] + +X23[i3]) / 2, Float64Array);
    },
    label: x12.label
  };
}
function maybeApplyInterval(V3, scale) {
  const t4 = maybeIntervalTransform(scale?.interval, scale?.type);
  return t4 ? map3(V3, t4) : V3;
}
function maybeIntervalTransform(interval2, type2) {
  const i3 = maybeInterval(interval2, type2);
  return i3 && ((v3) => defined(v3) ? i3.floor(v3) : v3);
}
function maybeInterval(interval2, type2) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
      interval2 = -1 / interval2;
    const n2 = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d3) => Math.floor(d3 * n2) / n2,
      offset: (d3) => (d3 * n2 + 1) / n2,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n2), hi * n2).map((x6) => x6 / n2)
    } : {
      floor: (d3) => Math.floor(d3 / n2) * n2,
      offset: (d3) => d3 + n2,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n2), hi / n2).map((x6) => x6 * n2)
    };
  }
  if (typeof interval2 === "string")
    return (type2 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
  if (typeof interval2.floor !== "function")
    throw new Error("invalid interval; missing floor method");
  if (typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing offset method");
  return interval2;
}
function maybeRangeInterval(interval2, type2) {
  interval2 = maybeInterval(interval2, type2);
  if (interval2 && typeof interval2.range !== "function")
    throw new Error("invalid interval: missing range method");
  return interval2;
}
function maybeNiceInterval(interval2, type2) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (interval2 && typeof interval2.ceil !== "function")
    throw new Error("invalid interval: missing ceil method");
  return interval2;
}
function isTimeInterval(t4) {
  return isInterval(t4) && typeof t4?.floor === "function" && t4.floor() instanceof Date;
}
function isInterval(t4) {
  return typeof t4?.range === "function";
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isIterable(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    const type2 = typeof value;
    return type2 === "string" || type2 === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    if (typeof value !== "string")
      return false;
    if (!value.trim())
      continue;
    return !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "number";
  }
}
function isEvery(values2, is) {
  let every;
  for (const value of values2) {
    if (value == null)
      continue;
    if (!is(value))
      return false;
    every = true;
  }
  return every;
}
var namedColors = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
function isColor(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa
  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(value) || // <funciri>, CSS variable, color, etc.
  namedColors.has(value);
}
function isOpacity(value) {
  return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeAnchor(value, name) {
  return maybeKeyword(value, name, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function maybeFrameAnchor(value = "middle") {
  return maybeAnchor(value, "frameAnchor");
}
function inherit2(options = {}, ...rest) {
  let o3 = options;
  for (const defaults8 of rest) {
    for (const key in defaults8) {
      if (o3[key] === void 0) {
        const value = defaults8[key];
        if (o3 === options)
          o3 = { ...o3, [key]: value };
        else
          o3[key] = value;
      }
    }
  }
  return o3;
}
function named2(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(things, (thing) => {
      const { name } = thing;
      if (name == null)
        throw new Error("missing name");
      const key = `${name}`;
      if (key === "__proto__")
        throw new Error(`illegal name: ${key}`);
      if (names.has(key))
        throw new Error(`duplicate name: ${key}`);
      names.add(key);
      return [name, thing];
    })
  );
}
function maybeNamed(things) {
  return isIterable(things) ? named2(things) : things;
}
function maybeClip(clip) {
  if (clip === true)
    clip = "frame";
  else if (clip === false)
    clip = null;
  else if (clip != null)
    clip = keyword(clip, "clip", ["frame", "sphere"]);
  return clip;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/index.js
var position = Symbol("position");
var color2 = Symbol("color");
var radius = Symbol("radius");
var length2 = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var projection2 = Symbol("projection");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color2],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length2],
  ["projection", projection2]
]);
function isPosition(kind) {
  return kind === position || kind === projection2;
}
function hasNumericRange(kind) {
  return kind === position || kind === radius || kind === length2 || kind === opacity;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/symbol.js
var sqrt35 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt35;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default2],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/basic.js
function basic({ filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...options } = {}, transform2) {
  if (t13 === void 0) {
    if (f1 != null)
      t13 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      t13 = composeTransform(t13, sortTransform(s1));
    if (r1)
      t13 = composeTransform(t13, reverseTransform);
  }
  if (transform2 != null && i1 != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t13, transform2)
  };
}
function initializer({ filter: f1, sort: s1, reverse: r1, initializer: i1, ...options } = {}, initializer2) {
  if (i1 === void 0) {
    if (f1 != null)
      i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      i1 = composeInitializer(i1, sortTransform(s1));
    if (r1)
      i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t13, t23) {
  if (t13 == null)
    return t23 === null ? void 0 : t23;
  if (t23 == null)
    return t13 === null ? void 0 : t13;
  return function(data, facets, plotOptions) {
    ({ data, facets } = t13.call(this, data, facets, plotOptions));
    return t23.call(this, arrayify2(data), facets, plotOptions);
  };
}
function composeInitializer(i1, i22) {
  if (i1 == null)
    return i22 === null ? void 0 : i22;
  if (i22 == null)
    return i1 === null ? void 0 : i1;
  return function(data, facets, channels, ...args) {
    let c1, d1, f1, c22, d22, f22;
    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));
    ({ data: d22 = d1, facets: f22 = f1, channels: c22 } = i22.call(this, d1, f1, { ...channels, ...c1 }, ...args));
    return { data: d22, facets: f22, channels: { ...c1, ...c22 } };
  };
}
function filterTransform(value) {
  return (data, facets) => {
    const V3 = valueof(data, value);
    return { data, facets: facets.map((I4) => I4.filter((i3) => V3[i3])) };
  };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I4) => I4.slice().reverse()) };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare2) {
  return (data, facets) => {
    const compareData = (i3, j4) => compare2(data[i3], data[j4]);
    return { data, facets: facets.map((I4) => I4.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order;
  ({ channel, value, order } = { ...maybeValue(value) });
  const negate = channel?.startsWith("-");
  if (negate)
    channel = channel.slice(1);
  if (order === void 0)
    order = negate ? descendingDefined : ascendingDefined2;
  if (typeof order !== "function") {
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        order = ascendingDefined2;
        break;
      case "descending":
        order = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order}`);
    }
  }
  return (data, facets, channels) => {
    let V3;
    if (channel === void 0) {
      V3 = valueof(data, value);
    } else {
      if (channels === void 0)
        throw new Error("channel sort requires an initializer");
      V3 = channels[channel];
      if (!V3)
        return {};
      V3 = V3.value;
    }
    const compareValue = (i3, j4) => order(V3[i3], V3[j4]);
    return { data, facets: facets.map((I4) => I4.slice().sort(compareValue)) };
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/group.js
function hasOutput(outputs, ...names) {
  for (const { name } of outputs) {
    if (names.includes(name)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0)
    entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0)
    entries.push(["href", reduceFirst]);
  return entries.filter(([, reduce2]) => reduce2 !== void 0).map(([name, reduce2]) => reduce2 === null ? nullOutput(name) : asOutput(name, reduce2, inputs));
}
function maybeOutput(name, reduce2, inputs, asEvaluator = maybeEvaluator) {
  let scale;
  if (isObject(reduce2) && "reduce" in reduce2)
    scale = reduce2.scale, reduce2 = reduce2.reduce;
  const evaluator = asEvaluator(name, reduce2, inputs);
  const [output, setOutput] = column(evaluator.label);
  let O3;
  return {
    name,
    output: scale === void 0 ? output : { value: output, scale },
    initialize(data) {
      evaluator.initialize(data);
      O3 = setOutput([]);
    },
    scope(scope, I4) {
      evaluator.scope(scope, I4);
    },
    reduce(I4, extent3) {
      O3.push(evaluator.reduce(I4, extent3));
    }
  };
}
function nullOutput(name) {
  return { name, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function maybeEvaluator(name, reduce2, inputs, asReduce = maybeReduce) {
  const input = maybeInput(name, inputs);
  const reducer2 = asReduce(reduce2, input);
  let V3, context;
  return {
    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),
    initialize(data) {
      V3 = input === void 0 ? data : valueof(data, input);
      if (reducer2.scope === "data") {
        context = reducer2.reduceIndex(range2(data), V3);
      }
    },
    scope(scope, I4) {
      if (reducer2.scope === scope) {
        context = reducer2.reduceIndex(I4, V3);
      }
    },
    reduce(I4, extent3) {
      return reducer2.scope == null ? reducer2.reduceIndex(I4, V3, extent3) : reducer2.reduceIndex(I4, V3, context, extent3);
    }
  };
}
function maybeGroup(I4, X4) {
  return X4 ? group(I4, (i3) => X4[i3]) : [[, I4]];
}
function maybeReduce(reduce2, value, fallback = invalidReduce) {
  if (reduce2 == null)
    return fallback(reduce2);
  if (typeof reduce2.reduceIndex === "function")
    return reduce2;
  if (typeof reduce2.reduce === "function" && isObject(reduce2))
    return reduceReduce(reduce2);
  if (typeof reduce2 === "function")
    return reduceFunction(reduce2);
  if (/^p\d{2}$/i.test(reduce2))
    return reduceAccessor(percentile(reduce2));
  switch (`${reduce2}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "identity":
      return reduceIdentity;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceMaybeTemporalAccessor(mean);
    case "median":
      return reduceMaybeTemporalAccessor(median);
    case "variance":
      return reduceAccessor(variance);
    case "mode":
      return reduceAccessor(mode);
  }
  return fallback(reduce2);
}
function invalidReduce(reduce2) {
  throw new Error(`invalid reduce: ${reduce2}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name in inputs) {
    const value = inputs[name];
    if (value !== void 0 && !outputs.some((o3) => o3.name === name)) {
      return value;
    }
  }
}
function maybeSort(facets, sort2, reverse2) {
  if (sort2) {
    const S3 = sort2.output.transform();
    const compare2 = (i3, j4) => ascendingDefined2(S3[i3], S3[j4]);
    facets.forEach((f3) => f3.sort(compare2));
  }
  if (reverse2) {
    facets.forEach((f3) => f3.reverse());
  }
}
function reduceReduce(reduce2) {
  console.warn("deprecated reduce interface; implement reduceIndex instead.");
  return { ...reduce2, reduceIndex: reduce2.reduce.bind(reduce2) };
}
function reduceFunction(f3) {
  return {
    reduceIndex(I4, X4, extent3) {
      return f3(take(X4, I4), extent3);
    }
  };
}
function reduceAccessor(f3) {
  return {
    reduceIndex(I4, X4) {
      return f3(I4, (i3) => X4[i3]);
    }
  };
}
function reduceMaybeTemporalAccessor(f3) {
  return {
    reduceIndex(I4, X4) {
      const x6 = f3(I4, (i3) => X4[i3]);
      return isTemporal(X4) ? new Date(x6) : x6;
    }
  };
}
var reduceIdentity = {
  reduceIndex(I4, X4) {
    return take(X4, I4);
  }
};
var reduceFirst = {
  reduceIndex(I4, X4) {
    return X4[I4[0]];
  }
};
var reduceTitle = {
  reduceIndex(I4, X4) {
    const n2 = 5;
    const groups2 = sort(
      rollup(
        I4,
        (V3) => V3.length,
        (i3) => X4[i3]
      ),
      second2
    );
    const top2 = groups2.slice(-n2).reverse();
    if (top2.length < groups2.length) {
      const bottom2 = groups2.slice(0, 1 - n2);
      top2[n2 - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second2)];
    }
    return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduceIndex(I4, X4) {
    return X4[I4[I4.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduceIndex(I4) {
    return I4.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduceIndex(I4, X4) {
    const s4 = new InternSet();
    for (const i3 of I4)
      s4.add(X4[i3]);
    return s4.size;
  }
};
var reduceSum = reduceAccessor(sum);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduceIndex: (I4, V3, basis2 = 1) => I4.length / basis2 } : { scope, reduceIndex: (I4, V3, basis2 = 1) => sum(I4, (i3) => V3[i3]) / basis2 };
}
var reduceZ = {
  reduceIndex(I4, X4, { z: z4 }) {
    return z4;
  }
};

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/channel.js
function createChannel(data, { scale, type: type2, value, filter: filter2, hint, label = labelof(value) }, name) {
  if (hint === void 0 && typeof value?.transform === "function")
    hint = value.hint;
  return inferChannelScale(name, {
    scale,
    type: type2,
    value: valueof(data, value),
    label,
    filter: filter2,
    hint
  });
}
function createChannels(channels, data) {
  return Object.fromEntries(
    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
  );
}
function valueObject(channels, scales) {
  const values2 = Object.fromEntries(
    Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
      const scale = scaleName == null ? null : scales[scaleName];
      return [name, scale == null ? value : map3(value, scale)];
    })
  );
  values2.channels = channels;
  return values2;
}
function inferChannelScale(name, channel) {
  const { scale, value } = channel;
  if (scale === true || scale === "auto") {
    switch (name) {
      case "fill":
      case "stroke":
      case "color":
        channel.scale = scale !== true && isEvery(value, isColor) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        channel.scale = scale !== true && isEvery(value, isOpacity) ? null : "opacity";
        break;
      case "symbol":
        if (scale !== true && isEvery(value, isSymbol)) {
          channel.scale = null;
          channel.value = map3(value, maybeSymbol);
        } else {
          channel.scale = "symbol";
        }
        break;
      default:
        channel.scale = registry.has(name) ? name : null;
        break;
    }
  } else if (scale === false) {
    channel.scale = null;
  } else if (scale != null && !registry.has(scale)) {
    throw new Error(`unknown scale: ${scale}`);
  }
  return channel;
}
function channelDomain(data, facets, channels, facetChannels, options) {
  const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x6 in options) {
    if (!registry.has(x6))
      continue;
    let { value: y4, order = defaultOrder, reverse: reverse2 = defaultReverse, reduce: reduce2 = defaultReduce, limit = defaultLimit } = maybeValue(options[x6]);
    const negate = y4?.startsWith("-");
    if (negate)
      y4 = y4.slice(1);
    order = order === void 0 ? negate !== (y4 === "width" || y4 === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
    if (reduce2 == null || reduce2 === false)
      continue;
    const X4 = x6 === "fx" || x6 === "fy" ? reindexFacetChannel(facets, facetChannels[x6]) : findScaleChannel(channels, x6);
    if (!X4)
      throw new Error(`missing channel for scale: ${x6}`);
    const XV = X4.value;
    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y4 == null) {
      X4.domain = () => {
        let domain = Array.from(new InternSet(XV));
        if (reverse2)
          domain = domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y4 === "data" ? data : y4 === "height" ? difference(channels, "y1", "y2") : y4 === "width" ? difference(channels, "x1", "x2") : values(channels, y4, y4 === "y" ? "y2" : y4 === "x" ? "x2" : void 0);
      const reducer2 = maybeReduce(reduce2 === true ? "max" : reduce2, YV);
      X4.domain = () => {
        let domain = rollups(
          range2(XV),
          (I4) => reducer2.reduceIndex(I4, YV),
          (i3) => XV[i3]
        );
        if (order)
          domain.sort(order);
        if (reverse2)
          domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain.map(first);
      };
    }
  }
}
function findScaleChannel(channels, scale) {
  for (const name in channels) {
    const channel = channels[name];
    if (channel.scale === scale)
      return channel;
  }
}
function reindexFacetChannel(facets, channel) {
  const originalFacets = facets.original;
  if (originalFacets === facets)
    return channel;
  const V1 = channel.value;
  const V22 = channel.value = [];
  for (let i3 = 0; i3 < originalFacets.length; ++i3) {
    const vi = V1[originalFacets[i3][0]];
    for (const j4 of facets[i3])
      V22[j4] = vi;
  }
  return channel;
}
function difference(channels, k1, k22) {
  const X12 = values(channels, k1);
  const X23 = values(channels, k22);
  return map3(X23, (x22, i3) => Math.abs(x22 - X12[i3]), Float64Array);
}
function values(channels, name, alias) {
  let channel = channels[name];
  if (!channel && alias !== void 0)
    channel = channels[alias];
  if (channel)
    return channel.value;
  throw new Error(`missing channel: ${name}`);
}
function maybeOrder(order) {
  if (order == null || typeof order === "function")
    return order;
  switch (`${order}`.toLowerCase()) {
    case "ascending":
      return ascendingGroup;
    case "descending":
      return descendingGroup;
  }
  throw new Error(`invalid order: ${order}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
}
function getSource(channels, key) {
  let channel = channels[key];
  if (!channel)
    return;
  while (channel.source)
    channel = channel.source;
  return channel.source === null ? null : channel;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/context.js
function createContext(options = {}) {
  const { document: document2 = typeof window !== "undefined" ? window.document : void 0, clip } = options;
  return { document: document2, clip: maybeClip(clip) };
}
function create2(name, { document: document2 }) {
  return select_default2(creator_default(name).call(document2.documentElement));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/warnings.js
var warnings = 0;
var lastMessage;
function consumeWarnings() {
  const w4 = warnings;
  warnings = 0;
  lastMessage = void 0;
  return w4;
}
function warn(message) {
  if (message === lastMessage)
    return;
  lastMessage = message;
  console.warn(message);
  ++warnings;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/projection.js
var pi4 = Math.PI;
var tau4 = 2 * pi4;
var defaultAspectRatio = 0.618;
function createProjection({
  projection: projection3,
  inset: globalInset = 0,
  insetTop = globalInset,
  insetRight = globalInset,
  insetBottom = globalInset,
  insetLeft = globalInset
} = {}, dimensions) {
  if (projection3 == null)
    return;
  if (typeof projection3.stream === "function")
    return projection3;
  let options;
  let domain;
  let clip = "frame";
  if (isObject(projection3)) {
    let inset;
    ({
      type: projection3,
      domain,
      inset,
      insetTop = inset !== void 0 ? inset : insetTop,
      insetRight = inset !== void 0 ? inset : insetRight,
      insetBottom = inset !== void 0 ? inset : insetBottom,
      insetLeft = inset !== void 0 ? inset : insetLeft,
      clip = clip,
      ...options
    } = projection3);
    if (projection3 == null)
      return;
  }
  if (typeof projection3 !== "function")
    ({ type: projection3 } = namedProjection(projection3));
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  const dx = width - marginLeft - marginRight - insetLeft - insetRight;
  const dy = height - marginTop - marginBottom - insetTop - insetBottom;
  projection3 = projection3?.({ width: dx, height: dy, clip, ...options });
  if (projection3 == null)
    return;
  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
  let tx = marginLeft + insetLeft;
  let ty = marginTop + insetTop;
  let transform2;
  if (domain != null) {
    const [[x05, y05], [x12, y12]] = path_default(projection3).bounds(domain);
    const k5 = Math.min(dx / (x12 - x05), dy / (y12 - y05));
    if (k5 > 0) {
      tx -= (k5 * (x05 + x12) - dx) / 2;
      ty -= (k5 * (y05 + y12) - dy) / 2;
      transform2 = transform_default({
        point(x6, y4) {
          this.stream.point(x6 * k5 + tx, y4 * k5 + ty);
        }
      });
    } else {
      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  }
  transform2 ?? (transform2 = tx === 0 && ty === 0 ? identity7() : transform_default({
    point(x6, y4) {
      this.stream.point(x6 + tx, y4 + ty);
    }
  }));
  return { stream: (s4) => projection3.stream(transform2.stream(clip(s4))) };
}
function namedProjection(projection3) {
  switch (`${projection3}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection2(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau4, tau4);
    case "conic-conformal":
      return conicProjection2(conicConformal_default, tau4, tau4);
    case "conic-equal-area":
      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau4, pi4);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity7 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau4, tau4);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau4, tau4);
    default:
      throw new Error(`unknown projection type: ${projection3}`);
  }
}
function maybePostClip(clip, x12, y12, x22, y22) {
  if (clip === false || clip == null || typeof clip === "number")
    return (s4) => s4;
  if (clip === true)
    clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x12, y12, x22, y22);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}
function scaleProjection(createProjection2, kx2, ky2) {
  return {
    type: ({ width, height, rotate, precision = 0.15, clip }) => {
      const projection3 = createProjection2();
      if (precision != null)
        projection3.precision?.(precision);
      if (rotate != null)
        projection3.rotate?.(rotate);
      if (typeof clip === "number")
        projection3.clipAngle?.(clip);
      projection3.scale(Math.min(width / kx2, height / ky2));
      projection3.translate([width / 2, height / 2]);
      return projection3;
    },
    aspectRatio: ky2 / kx2
  };
}
function conicProjection2(createProjection2, kx2, ky2) {
  const { type: type2, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
  return {
    type: (options) => {
      const { parallels, domain, width, height } = options;
      const projection3 = type2(options);
      if (parallels != null) {
        projection3.parallels(parallels);
        if (domain === void 0) {
          projection3.fitSize([width, height], { type: "Sphere" });
        }
      }
      return projection3;
    },
    aspectRatio
  };
}
var identity7 = constant({ stream: (stream) => stream });
var reflectY = constant(
  transform_default({
    point(x6, y4) {
      this.stream.point(x6, -y4);
    }
  })
);
function project(cx, cy, values2, projection3) {
  const x6 = values2[cx];
  const y4 = values2[cy];
  const n2 = x6.length;
  const X4 = values2[cx] = new Float64Array(n2).fill(NaN);
  const Y4 = values2[cy] = new Float64Array(n2).fill(NaN);
  let i3;
  const stream = projection3.stream({
    point(x7, y5) {
      X4[i3] = x7;
      Y4[i3] = y5;
    }
  });
  for (i3 = 0; i3 < n2; ++i3) {
    stream.point(x6[i3], y4[i3]);
  }
}
function hasProjection({ projection: projection3 } = {}) {
  if (projection3 == null)
    return false;
  if (typeof projection3.stream === "function")
    return true;
  if (isObject(projection3))
    projection3 = projection3.type;
  return projection3 != null;
}
function projectionAspectRatio(projection3) {
  if (typeof projection3?.stream === "function")
    return defaultAspectRatio;
  if (isObject(projection3))
    projection3 = projection3.type;
  if (projection3 == null)
    return;
  if (typeof projection3 !== "function") {
    const { aspectRatio } = namedProjection(projection3);
    if (aspectRatio)
      return aspectRatio;
  }
  return defaultAspectRatio;
}
function getGeometryChannels(channel) {
  const X4 = [];
  const Y4 = [];
  const x6 = { scale: "x", value: X4 };
  const y4 = { scale: "y", value: Y4 };
  const sink = {
    point(x7, y5) {
      X4.push(x7);
      Y4.push(y5);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const object of channel.value)
    stream_default(object, sink);
  return [x6, y4];
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/schemes.js
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["observable10", observable10_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = new Map([
  ...categoricalSchemes,
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default2)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 1)
      return [scheme28[3][1]];
    if (n2 === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 9 ? quantize_default(interpolate, n2) : scheme28[n2];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 11 ? quantize_default(interpolate, n2) : scheme28[n2];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 11 ? quantize_default((t4) => interpolate(1 - t4), n2) : scheme28[n2].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n2 }) => quantize_default(interpolate, Math.max(2, Math.floor(n2)));
}
function schemeicyclical(interpolate) {
  return ({ length: n2 }) => quantize_default(interpolate, Math.floor(n2) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s4 = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s4))
    throw new Error(`unknown ordinal scheme: ${s4}`);
  return ordinalSchemes.get(s4);
}
function ordinalRange(scheme28, length3) {
  const s4 = ordinalScheme(scheme28);
  const r3 = typeof s4 === "function" ? s4({ length: length3 }) : s4;
  return r3.length !== length3 ? r3.slice(0, length3) : r3;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f3, t4] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null)
      continue;
    if (value === true)
      range3.add(t4);
    else if (value === false)
      range3.add(f3);
    else
      return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t4) => RdBu_default(1 - t4)],
  ["buylrd", (t4) => RdYlBu_default(1 - t4)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default2],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s4 = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s4))
    throw new Error(`unknown quantitative scheme: ${s4}`);
  return quantitativeSchemes.get(s4);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/quantitative.js
var flip = (i3) => (t4) => i3(1 - t4);
var unit2 = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab2]
]);
function maybeInterpolator(interpolate) {
  const i3 = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i3))
    throw new Error(`unknown interpolator: ${i3}`);
  return interpolators.get(i3);
}
function createScaleQ(key, scale, channels, {
  type: type2,
  nice: nice2,
  clamp,
  zero: zero3,
  domain = inferAutoDomain(key, channels),
  unknown,
  round,
  scheme: scheme28,
  interval: interval2,
  range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length2 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round ? round_default : number_default,
  reverse: reverse2
}) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (type2 === "cyclical" || type2 === "sequential")
    type2 = "linear";
  if (typeof interpolate !== "function")
    interpolate = maybeInterpolator(interpolate);
  reverse2 = !!reverse2;
  if (range3 !== void 0) {
    const n2 = (domain = arrayify2(domain)).length;
    const m3 = (range3 = arrayify2(range3)).length;
    if (n2 !== m3) {
      if (interpolate.length === 1)
        throw new Error("invalid piecewise interpolator");
      interpolate = piecewise(interpolate, range3);
      range3 = void 0;
    }
  }
  if (interpolate.length === 1) {
    if (reverse2) {
      interpolate = flip(interpolate);
      reverse2 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_3, i3) => i3 / (domain.length - 1));
      if (range3.length === 2)
        range3 = unit2;
    }
    scale.interpolate((range3 === unit2 ? constant : interpolatePiecewise)(interpolate));
  } else {
    scale.interpolate(interpolate);
  }
  if (zero3) {
    const [min4, max3] = extent(domain);
    if (min4 > 0 || max3 < 0) {
      domain = slice2(domain);
      if (orderof(domain) !== Math.sign(min4))
        domain[domain.length - 1] = 0;
      else
        domain[0] = 0;
    }
  }
  if (reverse2)
    domain = reverse(domain);
  scale.domain(domain).unknown(unknown);
  if (nice2)
    scale.nice(maybeNice(nice2, type2)), domain = scale.domain();
  if (range3 !== void 0)
    scale.range(range3);
  if (clamp)
    scale.clamp(clamp);
  return { type: type2, domain, range: range3, scale, interpolate, interval: interval2 };
}
function maybeNice(nice2, type2) {
  return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval(nice2, type2);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear2(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow2().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base: base2 = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log2().base(base2), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant2), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  // deprecated; use n instead
  n: n2 = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  if (range3 === void 0) {
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n2) : registry.get(key) === color2 ? ordinalRange(scheme28, n2) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile2(domain, range3 === void 0 ? { length: n2 } : range3).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse2, unknown });
}
function createScaleQuantize(key, channels, {
  range: range3,
  n: n2 = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  const [min4, max3] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min4, max3, n2);
    if (thresholds[0] <= min4)
      thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max3)
      thresholds.pop();
    n2 = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n2) : registry.get(key) === color2 ? ordinalRange(scheme28, n2) : void 0;
  } else {
    thresholds = quantize_default(number_default(min4, max3), n2 + 1).slice(1, -1);
    if (min4 instanceof Date)
      thresholds = thresholds.map((x6) => new Date(x6));
  }
  if (orderof(arrayify2(domain)) < 0)
    thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse2, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse2
}) {
  domain = arrayify2(domain);
  const sign3 = orderof(domain);
  if (!isNaN(sign3) && !isOrdered(domain, sign3))
    throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse2)
    range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(domain, sign3) {
  for (let i3 = 1, n2 = domain.length, d3 = domain[0]; i3 < n2; ++i3) {
    const s4 = descending(d3, d3 = domain[i3]);
    if (s4 !== 0 && s4 !== sign3)
      return false;
  }
  return true;
}
function createScaleIdentity(key) {
  return { type: "identity", scale: hasNumericRange(registry.get(key)) ? identity4() : (d3) => d3 };
}
function inferDomain(channels, f3 = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f3)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f3))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type2 = registry.get(key);
  return (type2 === radius || type2 === opacity || type2 === length2 ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0)
    return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range3 = domain.map((d3) => 3 * Math.sqrt(d3 / h25));
  const k5 = 30 / max(range3);
  return k5 < 1 ? range3.map((r3) => r3 * k5) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range3 = domain.map((d3) => 12 * d3 / h50);
  const k5 = 60 / max(range3);
  return k5 < 1 ? range3.map((r3) => r3 * k5) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v3 of value) {
        if (v3 > 0)
          return inferDomain(channels, positive);
        if (v3 < 0)
          return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0)
      continue;
    for (const v3 of value)
      domain.push(v3);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i3, j4) => (t4) => interpolate(i3 + t4 * (j4 - i3));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/diverging.js
function createScaleD(key, scale, transform2, channels, {
  type: type2,
  nice: nice2,
  clamp,
  domain = inferDomain(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range3,
  symmetric = true,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse2
}) {
  pivot = +pivot;
  domain = arrayify2(domain);
  let [min4, max3] = domain;
  if (domain.length > 2)
    warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
  if (descending(min4, max3) < 0)
    [min4, max3] = [max3, min4], reverse2 = !reverse2;
  min4 = Math.min(min4, pivot);
  max3 = Math.max(max3, pivot);
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse2)
    interpolate = flip(interpolate);
  if (symmetric) {
    const mid2 = transform2.apply(pivot);
    const mindelta = mid2 - transform2.apply(min4);
    const maxdelta = transform2.apply(max3) - mid2;
    if (mindelta < maxdelta)
      min4 = transform2.invert(mid2 - maxdelta);
    else if (mindelta > maxdelta)
      max3 = transform2.invert(mid2 + mindelta);
  }
  scale.domain([min4, pivot, max3]).unknown(unknown).interpolator(interpolate);
  if (clamp)
    scale.clamp(clamp);
  if (nice2)
    scale.nice(nice2);
  return { type: type2, domain: [min4, max3], pivot, interpolate, scale };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow2(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base: base2 = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base2 = +base2), transformLog2, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant2 = +constant2),
    transformSymlog2(constant2),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x6) {
    return x6;
  },
  invert(x6) {
    return x6;
  }
};
var transformLog2 = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt2 = {
  apply(x6) {
    return Math.sign(x6) * Math.sqrt(Math.abs(x6));
  },
  invert(x6) {
    return Math.sign(x6) * (x6 * x6);
  }
};
function transformPow2(exponent) {
  return exponent === 0.5 ? transformSqrt2 : {
    apply(x6) {
      return Math.sign(x6) * Math.pow(Math.abs(x6), exponent);
    },
    invert(x6) {
      return Math.sign(x6) * Math.pow(Math.abs(x6), 1 / exponent);
    }
  };
}
function transformSymlog2(constant2) {
  return {
    apply(x6) {
      return Math.sign(x6) * Math.log1p(Math.abs(x6 / constant2));
    },
    invert(x6) {
      return Math.sign(x6) * Math.expm1(Math.abs(x6)) * constant2;
    }
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/temporal.js
function createScaleT(key, scale, channels, options) {
  return createScaleQ(key, scale, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale, channels, { type: type2, interval: interval2, domain, range: range3, reverse: reverse2, hint }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  if (type2 === "categorical" || type2 === ordinalImplicit)
    type2 = "ordinal";
  if (reverse2)
    domain = reverse(domain);
  domain = scale.domain(domain).domain();
  if (range3 !== void 0) {
    if (typeof range3 === "function")
      range3 = range3(domain);
    scale.range(range3);
  }
  return { type: type2, domain, range: range3, scale, hint, interval: interval2 };
}
function createScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map3(range3, maybeSymbol);
  } else if (registry.get(key) === color2) {
    if (range3 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0)
        scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type2 === "ordinal" ? "turbo" : "observable10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t03 = range3[0], d3 = range3[1] - range3[0];
        range3 = ({ length: n2 }) => quantize_default((t4) => interpolate(t03 + d3 * t4), n2);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range3, hint });
}
function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function createScaleBand(key, channels, {
  align = 0.5,
  padding = 0.1,
  paddingInner = padding,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
  ...options
}) {
  return maybeRound(
    band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale, channels, options, key) {
  let { round } = options;
  if (round !== void 0)
    scale.round(round = !!round);
  scale = createScaleO(key, scale, channels, options);
  scale.round = round;
  return scale;
}
function inferDomain2(channels, interval2, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0)
      return domain();
    if (value === void 0)
      continue;
    for (const v3 of value)
      values2.add(v3);
  }
  if (interval2 !== void 0) {
    const [min4, max3] = extent(values2).map(interval2.floor, interval2);
    return interval2.range(min4, interval2.offset(max3));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined2);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint?.[key];
    if (candidate === void 0)
      continue;
    if (value === void 0)
      value = candidate;
    else if (value !== candidate)
      return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/scales.js
function createScales(channelsByScale, {
  label: globalLabel,
  inset: globalInset = 0,
  insetTop: globalInsetTop = globalInset,
  insetRight: globalInsetRight = globalInset,
  insetBottom: globalInsetBottom = globalInset,
  insetLeft: globalInsetLeft = globalInset,
  round,
  nice: nice2,
  clamp,
  zero: zero3,
  align,
  padding,
  projection: projection3,
  facet: { label: facetLabel = globalLabel } = {},
  ...options
} = {}) {
  const scales = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale = createScale(key, channels, {
      round: registry.get(key) === position ? round : void 0,
      // only for position
      nice: nice2,
      clamp,
      zero: zero3,
      align,
      padding,
      projection: projection3,
      ...scaleOptions
    });
    if (scale) {
      let {
        label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
        percent,
        transform: transform2,
        inset,
        insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
        // not fy
        insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
        // not fx
        insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
        // not fy
        insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
        // not fx
      } = scaleOptions || {};
      if (transform2 == null)
        transform2 = void 0;
      else if (typeof transform2 !== "function")
        throw new Error("invalid scale transform; not a function");
      scale.percent = !!percent;
      scale.label = label === void 0 ? inferScaleLabel(channels, scale) : label;
      scale.transform = transform2;
      if (key === "x" || key === "fx") {
        scale.insetLeft = +insetLeft;
        scale.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale.insetTop = +insetTop;
        scale.insetBottom = +insetBottom;
      }
      scales[key] = scale;
    }
  }
  return scales;
}
function createScaleFunctions(descriptors) {
  const scales = {};
  const scaleFunctions = { scales };
  for (const [key, descriptor] of Object.entries(descriptors)) {
    const { scale, type: type2, interval: interval2, label } = descriptor;
    scales[key] = exposeScale(descriptor);
    scaleFunctions[key] = scale;
    scale.type = type2;
    if (interval2 != null)
      scale.interval = interval2;
    if (label != null)
      scale.label = label;
  }
  return scaleFunctions;
}
function autoScaleRange(scales, dimensions) {
  const { x: x6, y: y4, fx, fy } = scales;
  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
  if (fx)
    autoScaleRangeX(fx, superdimensions);
  if (fy)
    autoScaleRangeY(fy, superdimensions);
  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
  if (x6)
    autoScaleRangeX(x6, subdimensions);
  if (y4)
    autoScaleRangeY(y4, subdimensions);
}
function inferScaleLabel(channels = [], scale) {
  let label;
  for (const { label: l3 } of channels) {
    if (l3 === void 0)
      continue;
    if (label === void 0)
      label = l3;
    else if (label !== l3)
      return;
  }
  if (label === void 0)
    return;
  if (!isOrdinalScale(scale) && scale.percent)
    label = `${label} (%)`;
  return { inferred: true, toString: () => label };
}
function inferScaleOrder(scale) {
  return Math.sign(orderof(scale.domain())) * Math.sign(orderof(scale.range()));
}
function outerDimensions(dimensions) {
  const {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width,
    height,
    facet: {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    }
  } = dimensions;
  return {
    marginTop: Math.max(marginTop, facetMarginTop),
    marginRight: Math.max(marginRight, facetMarginRight),
    marginBottom: Math.max(marginBottom, facetMarginBottom),
    marginLeft: Math.max(marginLeft, facetMarginLeft),
    width,
    height
  };
}
function innerDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,
    facet: { width, height }
  };
}
function autoScaleRangeX(scale, dimensions) {
  if (scale.range === void 0) {
    const { insetLeft, insetRight } = scale;
    const { width, marginLeft = 0, marginRight = 0 } = dimensions;
    const left2 = marginLeft + insetLeft;
    const right2 = width - marginRight - insetRight;
    scale.range = [left2, Math.max(left2, right2)];
    if (!isOrdinalScale(scale))
      scale.range = piecewiseRange(scale);
    scale.scale.range(scale.range);
  }
  autoScaleRound(scale);
}
function autoScaleRangeY(scale, dimensions) {
  if (scale.range === void 0) {
    const { insetTop, insetBottom } = scale;
    const { height, marginTop = 0, marginBottom = 0 } = dimensions;
    const top2 = marginTop + insetTop;
    const bottom2 = height - marginBottom - insetBottom;
    scale.range = [Math.max(top2, bottom2), top2];
    if (!isOrdinalScale(scale))
      scale.range = piecewiseRange(scale);
    else
      scale.range.reverse();
    scale.scale.range(scale.range);
  }
  autoScaleRound(scale);
}
function autoScaleRound(scale) {
  if (scale.round === void 0 && isBandScale(scale) && roundError(scale) <= 30) {
    scale.scale.round(true);
  }
}
function roundError({ scale }) {
  const n2 = scale.domain().length;
  const [start2, stop] = scale.range();
  const paddingInner = scale.paddingInner ? scale.paddingInner() : 1;
  const paddingOuter = scale.paddingOuter ? scale.paddingOuter() : scale.padding();
  const m3 = n2 - paddingInner;
  const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);
  return (step - Math.floor(step)) * m3;
}
function piecewiseRange(scale) {
  const length3 = scale.scale.domain().length + isThresholdScale(scale);
  if (!(length3 > 2))
    return scale.range;
  const [start2, end] = scale.range;
  return Array.from({ length: length3 }, (_3, i3) => start2 + i3 / (length3 - 1) * (end - start2));
}
function createScale(key, channels = [], options = {}) {
  const type2 = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type2 })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
  }
  options.type = type2;
  switch (type2) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type2) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return createScaleIdentity(key);
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type2}`);
  }
}
function formatScaleType(type2) {
  return typeof type2 === "symbol" ? type2.description : type2;
}
function maybeScaleType(type2) {
  return typeof type2 === "string" ? `${type2}`.toLowerCase() : type2;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type: type2, domain, range: range3, scheme: scheme28, pivot, projection: projection3 }) {
  type2 = maybeScaleType(type2);
  if (key === "fx" || key === "fy")
    return "band";
  if ((key === "x" || key === "y") && projection3 != null)
    type2 = typeProjection;
  for (const channel of channels) {
    const t4 = maybeScaleType(channel.type);
    if (t4 === void 0)
      continue;
    else if (type2 === void 0)
      type2 = t4;
    else if (type2 !== t4)
      throw new Error(`scale incompatible with channel: ${type2} !== ${t4}`);
  }
  if (type2 === typeProjection)
    return;
  if (type2 !== void 0)
    return type2;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
    return;
  const kind = registry.get(key);
  if (kind === radius)
    return "sqrt";
  if (kind === opacity || kind === length2)
    return "linear";
  if (kind === symbol)
    return "ordinal";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain))
      return asOrdinalType(kind);
    if (isTemporal(domain))
      return "utc";
  } else {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isOrdinal))
      return asOrdinalType(kind);
    if (values2.some(isTemporal))
      return "utc";
  }
  if (kind === color2) {
    if (pivot != null || isDivergingScheme(scheme28))
      return "diverging";
    if (isCategoricalScheme(scheme28))
      return "categorical";
  }
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color2:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isOrdinalScale({ type: type2 }) {
  return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
}
function isThresholdScale({ type: type2 }) {
  return type2 === "threshold";
}
function isBandScale({ type: type2 }) {
  return type2 === "point" || type2 === "band";
}
function isCollapsed(scale) {
  if (scale === void 0)
    return true;
  const domain = scale.domain();
  const value = scale(domain[0]);
  for (let i3 = 1, n2 = domain.length; i3 < n2; ++i3) {
    if (scale(domain[i3]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c6 of channels) {
    if (c6.value !== void 0) {
      if (domain === void 0)
        domain = c6.value?.domain;
      c6.value = coerceValues(c6.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map3(values2, maybeSymbol);
}
function exposeScales(scales) {
  return (key) => {
    if (!registry.has(key = `${key}`))
      throw new Error(`unknown scale: ${key}`);
    return scales[key];
  };
}
function exposeScale({ scale, type: type2, domain, range: range3, interpolate, interval: interval2, transform: transform2, percent, pivot }) {
  if (type2 === "identity")
    return { type: "identity", apply: (d3) => d3, invert: (d3) => d3 };
  const unknown = scale.unknown ? scale.unknown() : void 0;
  return {
    type: type2,
    domain: slice2(domain),
    // defensive copy
    ...range3 !== void 0 && { range: slice2(range3) },
    // defensive copy
    ...transform2 !== void 0 && { transform: transform2 },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval2 !== void 0 && { interval: interval2 },
    // quantitative
    ...interpolate !== void 0 && { interpolate },
    ...scale.clamp && { clamp: scale.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale.base && { base: scale.base() },
    // pow, diverging-pow
    ...scale.exponent && { exponent: scale.exponent() },
    // symlog, diverging-symlog
    ...scale.constant && { constant: scale.constant() },
    // band, point
    ...scale.align && { align: scale.align(), round: scale.round() },
    ...scale.padding && (scale.paddingInner ? { paddingInner: scale.paddingInner(), paddingOuter: scale.paddingOuter() } : { padding: scale.padding() }),
    ...scale.bandwidth && { bandwidth: scale.bandwidth(), step: scale.step() },
    // utilities
    apply: (t4) => scale(t4),
    ...scale.invert && { invert: (t4) => scale.invert(t4) }
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/memoize.js
function memoize1(compute) {
  let cacheValue, cacheKeys;
  return (...keys) => {
    if (cacheKeys?.length !== keys.length || cacheKeys.some((k5, i3) => k5 !== keys[i3])) {
      cacheKeys = keys;
      cacheValue = compute(...keys);
    }
    return cacheValue;
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/format.js
var numberFormat = memoize1((locale7) => {
  return new Intl.NumberFormat(locale7);
});
var monthFormat = memoize1((locale7, month) => {
  return new Intl.DateTimeFormat(locale7, { timeZone: "UTC", ...month && { month } });
});
var weekdayFormat = memoize1((locale7, weekday) => {
  return new Intl.DateTimeFormat(locale7, { timeZone: "UTC", ...weekday && { weekday } });
});
function formatNumber(locale7 = "en-US") {
  const format3 = numberFormat(locale7);
  return (i3) => i3 != null && !isNaN(i3) ? format3.format(i3) : void 0;
}
function formatIsoDate(date2) {
  return format2(date2, "Invalid Date");
}
function formatAuto(locale7 = "en-US") {
  const number6 = formatNumber(locale7);
  return (v3) => (v3 instanceof Date ? formatIsoDate : typeof v3 === "number" ? number6 : string)(v3);
}
var formatDefault = formatAuto();

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/style.js
var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
var nextClipId = 0;
function getClipId() {
  return `plot-clip-${++nextClipId}`;
}
function styles(mark, {
  title,
  href,
  ariaLabel: variaLabel,
  ariaDescription,
  ariaHidden,
  target,
  fill,
  fillOpacity,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  opacity: opacity2,
  mixBlendMode,
  imageFilter,
  paintOrder,
  pointerEvents,
  shapeRendering,
  channels
}, {
  ariaLabel: cariaLabel,
  fill: defaultFill = "currentColor",
  fillOpacity: defaultFillOpacity,
  stroke: defaultStroke = "none",
  strokeOpacity: defaultStrokeOpacity,
  strokeWidth: defaultStrokeWidth,
  strokeLinecap: defaultStrokeLinecap,
  strokeLinejoin: defaultStrokeLinejoin,
  strokeMiterlimit: defaultStrokeMiterlimit,
  paintOrder: defaultPaintOrder
}) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill))
      defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke))
      defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0)
      strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0)
      strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0)
      strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
      strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0)
      paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark.fill = impliedString(cfill, "currentColor");
    mark.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark.stroke = impliedString(cstroke, "none");
    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark.strokeDasharray = impliedString(strokeDasharray, "none");
    mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark.target = string(target);
  mark.ariaLabel = string(cariaLabel);
  mark.ariaDescription = string(ariaDescription);
  mark.ariaHidden = string(ariaHidden);
  mark.opacity = impliedNumber(copacity, 1);
  mark.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark.imageFilter = impliedString(imageFilter, "none");
  mark.paintOrder = impliedString(paintOrder, "normal");
  mark.pointerEvents = impliedString(pointerEvents, "auto");
  mark.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true, filter: null },
    href: { value: href, optional: true, filter: null },
    ariaLabel: { value: variaLabel, optional: true, filter: null },
    fill: { value: vfill, scale: "auto", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
    stroke: { value: vstroke, scale: "auto", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "auto", optional: true }
  };
}
function applyTitle(selection2, L4) {
  if (L4)
    selection2.filter((i3) => nonempty(L4[i3])).append("title").call(applyText, L4);
}
function applyTitleGroup(selection2, L4) {
  if (L4)
    selection2.filter(([i3]) => nonempty(L4[i3])).append("title").call(applyTextGroup, L4);
}
function applyText(selection2, T4) {
  if (T4)
    selection2.text((i3) => formatDefault(T4[i3]));
}
function applyTextGroup(selection2, T4) {
  if (T4)
    selection2.text(([i3]) => formatDefault(T4[i3]));
}
function applyChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T4,
  fill: F3,
  fillOpacity: FO,
  stroke: S3,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H3
}) {
  if (AL)
    applyAttr(selection2, "aria-label", (i3) => AL[i3]);
  if (F3)
    applyAttr(selection2, "fill", (i3) => F3[i3]);
  if (FO)
    applyAttr(selection2, "fill-opacity", (i3) => FO[i3]);
  if (S3)
    applyAttr(selection2, "stroke", (i3) => S3[i3]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", (i3) => SO[i3]);
  if (SW)
    applyAttr(selection2, "stroke-width", (i3) => SW[i3]);
  if (O3)
    applyAttr(selection2, "opacity", (i3) => O3[i3]);
  if (H3)
    applyHref(selection2, (i3) => H3[i3], target);
  if (!tip2)
    applyTitle(selection2, T4);
}
function applyGroupedChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T4,
  fill: F3,
  fillOpacity: FO,
  stroke: S3,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H3
}) {
  if (AL)
    applyAttr(selection2, "aria-label", ([i3]) => AL[i3]);
  if (F3)
    applyAttr(selection2, "fill", ([i3]) => F3[i3]);
  if (FO)
    applyAttr(selection2, "fill-opacity", ([i3]) => FO[i3]);
  if (S3)
    applyAttr(selection2, "stroke", ([i3]) => S3[i3]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", ([i3]) => SO[i3]);
  if (SW)
    applyAttr(selection2, "stroke-width", ([i3]) => SW[i3]);
  if (O3)
    applyAttr(selection2, "opacity", ([i3]) => O3[i3]);
  if (H3)
    applyHref(selection2, ([i3]) => H3[i3], target);
  if (!tip2)
    applyTitleGroup(selection2, T4);
}
function groupAesthetics({
  ariaLabel: AL,
  title: T4,
  fill: F3,
  fillOpacity: FO,
  stroke: S3,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O3,
  href: H3
}, { tip: tip2 }) {
  return [AL, tip2 ? void 0 : T4, F3, FO, S3, SO, SW, O3, H3].filter((c6) => c6 !== void 0);
}
function groupZ(I4, Z3, z4) {
  const G2 = group(I4, (i3) => Z3[i3]);
  if (z4 === void 0 && G2.size > 1 + I4.length >> 1) {
    warn(
      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
    );
  }
  return G2.values();
}
function* groupIndex(I4, position2, mark, channels) {
  const { z: z4 } = mark;
  const { z: Z3 } = channels;
  const A6 = groupAesthetics(channels, mark);
  const C4 = [...position2, ...A6];
  for (const G2 of Z3 ? groupZ(I4, Z3, z4) : [I4]) {
    let Ag;
    let Gg;
    out:
      for (const i3 of G2) {
        for (const c6 of C4) {
          if (!defined(c6[i3])) {
            if (Gg)
              Gg.push(-1);
            continue out;
          }
        }
        if (Ag === void 0) {
          if (Gg)
            yield Gg;
          Ag = A6.map((c6) => keyof2(c6[i3])), Gg = [i3];
          continue;
        }
        Gg.push(i3);
        for (let j4 = 0; j4 < A6.length; ++j4) {
          const k5 = keyof2(A6[j4][i3]);
          if (k5 !== Ag[j4]) {
            yield Gg;
            Ag = A6.map((c6) => keyof2(c6[i3])), Gg = [i3];
            continue out;
          }
        }
      }
    if (Gg)
      yield Gg;
  }
}
function applyClip(selection2, mark, dimensions, context) {
  let clipUrl;
  const { clip = context.clip } = mark;
  switch (clip) {
    case "frame": {
      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2 = create2("svg:g", context).call(
        (g4) => g4.append("svg:clipPath").attr("id", id2).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
      ).each(function() {
        this.appendChild(selection2.node());
        selection2.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: projection3 } = context;
      if (!projection3)
        throw new Error(`the "sphere" clip option requires a projection`);
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2.append("clipPath").attr("id", id2).append("path").attr("d", path_default(projection3)({ type: "Sphere" }));
      break;
    }
  }
  applyAttr(selection2, "aria-label", mark.ariaLabel);
  applyAttr(selection2, "aria-description", mark.ariaDescription);
  applyAttr(selection2, "aria-hidden", mark.ariaHidden);
  applyAttr(selection2, "clip-path", clipUrl);
}
function applyIndirectStyles(selection2, mark, dimensions, context) {
  applyClip(selection2, mark, dimensions, context);
  applyAttr(selection2, "fill", mark.fill);
  applyAttr(selection2, "fill-opacity", mark.fillOpacity);
  applyAttr(selection2, "stroke", mark.stroke);
  applyAttr(selection2, "stroke-width", mark.strokeWidth);
  applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
  applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
  applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
  applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
  applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
  applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
  applyAttr(selection2, "shape-rendering", mark.shapeRendering);
  applyAttr(selection2, "filter", mark.imageFilter);
  applyAttr(selection2, "paint-order", mark.paintOrder);
  const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark;
  applyAttr(selection2, "pointer-events", pointerEvents);
}
function applyDirectStyles(selection2, mark) {
  applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
  applyAttr(selection2, "opacity", mark.opacity);
}
function applyHref(selection2, href, target) {
  selection2.each(function(i3) {
    const h3 = href(i3);
    if (h3 != null) {
      const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a4.setAttribute("fill", "inherit");
      a4.setAttributeNS(namespaces_default.xlink, "href", h3);
      if (target != null)
        a4.setAttribute("target", target);
      this.parentNode.insertBefore(a4, this).appendChild(this);
    }
  });
}
function applyAttr(selection2, name, value) {
  if (value != null)
    selection2.attr(name, value);
}
function applyStyle(selection2, name, value) {
  if (value != null)
    selection2.style(name, value);
}
function applyTransform(selection2, mark, { x: x6, y: y4 }, tx = offset, ty = offset) {
  tx += mark.dx;
  ty += mark.dy;
  if (x6?.bandwidth)
    tx += x6.bandwidth() / 2;
  if (y4?.bandwidth)
    ty += y4.bandwidth() / 2;
  if (tx || ty)
    selection2.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue)
    return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number5(value)) !== impliedValue)
    return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function maybeClassName(name) {
  if (name === void 0)
    return "plot-d6a7b5";
  name = `${name}`;
  if (!validClassName.test(name))
    throw new Error(`invalid class name: ${name}`);
  return name;
}
function applyInlineStyles(selection2, style) {
  if (typeof style === "string") {
    selection2.property("style", style);
  } else if (style != null) {
    for (const element of selection2) {
      Object.assign(element.style, style);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
  ];
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/dimensions.js
function createDimensions(scales, marks2, options = {}) {
  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {
    if (marginTop2 > marginTopDefault)
      marginTopDefault = marginTop2;
    if (marginRight2 > marginRightDefault)
      marginRightDefault = marginRight2;
    if (marginBottom2 > marginBottomDefault)
      marginBottomDefault = marginBottom2;
    if (marginLeft2 > marginLeftDefault)
      marginLeftDefault = marginLeft2;
  }
  let {
    margin,
    marginTop = margin !== void 0 ? margin : marginTopDefault,
    marginRight = margin !== void 0 ? margin : marginRightDefault,
    marginBottom = margin !== void 0 ? margin : marginBottomDefault,
    marginLeft = margin !== void 0 ? margin : marginLeftDefault
  } = options;
  marginTop = +marginTop;
  marginRight = +marginRight;
  marginBottom = +marginBottom;
  marginLeft = +marginLeft;
  let {
    width = 640,
    height = autoHeight(scales, options, {
      width,
      marginTopDefault,
      marginRightDefault,
      marginBottomDefault,
      marginLeftDefault
    }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
  } = options;
  width = +width;
  height = +height;
  const dimensions = {
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
  if (scales.fx || scales.fy) {
    let {
      margin: facetMargin,
      marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
      marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
      marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
      marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
    } = options.facet ?? {};
    facetMarginTop = +facetMarginTop;
    facetMarginRight = +facetMarginRight;
    facetMarginBottom = +facetMarginBottom;
    facetMarginLeft = +facetMarginLeft;
    dimensions.facet = {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    };
  }
  return dimensions;
}
function autoHeight({ x: x6, y: y4, fy, fx }, { projection: projection3, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
  const nfy = fy ? fy.scale.domain().length : 1;
  const ar = projectionAspectRatio(projection3);
  if (ar) {
    const nfx = fx ? fx.scale.domain().length : 1;
    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
    const lar = Math.max(0.1, Math.min(10, far));
    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
  }
  const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;
  if (aspectRatio != null) {
    aspectRatio = +aspectRatio;
    if (!(isFinite(aspectRatio) && aspectRatio > 0))
      throw new Error(`invalid aspectRatio: ${aspectRatio}`);
    const ratio = aspectRatioLength("y", y4) / (aspectRatioLength("x", x6) * aspectRatio);
    const fxb = fx ? fx.scale.bandwidth() : 1;
    const fyb = fy ? fy.scale.bandwidth() : 1;
    const w4 = fxb * (width - marginLeftDefault - marginRightDefault) - x6.insetLeft - x6.insetRight;
    return (ratio * w4 + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
  }
  return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}
function aspectRatioLength(k5, scale) {
  if (!scale)
    throw new Error(`aspectRatio requires ${k5} scale`);
  const { type: type2, domain } = scale;
  let transform2;
  switch (type2) {
    case "linear":
    case "utc":
    case "time":
      transform2 = Number;
      break;
    case "pow": {
      const exponent = scale.scale.exponent();
      transform2 = (x6) => Math.pow(x6, exponent);
      break;
    }
    case "log":
      transform2 = Math.log;
      break;
    case "point":
    case "band":
      return domain.length;
    default:
      throw new Error(`unsupported ${k5} scale for aspectRatio: ${type2}`);
  }
  const [min4, max3] = extent(domain);
  return Math.abs(transform2(max3) - transform2(min4));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/facet.js
function createFacets(channelsByScale, options) {
  const { fx, fy } = createScales(channelsByScale, options);
  const fxDomain = fx?.scale.domain();
  const fyDomain = fy?.scale.domain();
  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x6, y4], i3) => ({ x: x6, y: y4, i: i3 })) : fxDomain ? fxDomain.map((x6, i3) => ({ x: x6, i: i3 })) : fyDomain ? fyDomain.map((y4, i3) => ({ y: y4, i: i3 })) : void 0;
}
function recreateFacets(facets, { x: X4, y: Y4 }) {
  X4 && (X4 = facetIndex(X4));
  Y4 && (Y4 = facetIndex(Y4));
  return facets.filter(
    X4 && Y4 ? (f3) => X4.has(f3.x) && Y4.has(f3.y) : X4 ? (f3) => X4.has(f3.x) : (f3) => Y4.has(f3.y)
  ).sort(
    X4 && Y4 ? (a4, b3) => X4.get(a4.x) - X4.get(b3.x) || Y4.get(a4.y) - Y4.get(b3.y) : X4 ? (a4, b3) => X4.get(a4.x) - X4.get(b3.x) : (a4, b3) => Y4.get(a4.y) - Y4.get(b3.y)
  );
}
function facetGroups(data, { fx, fy }) {
  const I4 = range2(data);
  const FX = fx?.value;
  const FY = fy?.value;
  return fx && fy ? rollup(
    I4,
    (G2) => (G2.fx = FX[G2[0]], G2.fy = FY[G2[0]], G2),
    (i3) => FX[i3],
    (i3) => FY[i3]
  ) : fx ? rollup(
    I4,
    (G2) => (G2.fx = FX[G2[0]], G2),
    (i3) => FX[i3]
  ) : rollup(
    I4,
    (G2) => (G2.fy = FY[G2[0]], G2),
    (i3) => FY[i3]
  );
}
function facetTranslator(fx, fy, { marginTop, marginLeft }) {
  return fx && fy ? ({ x: x6, y: y4 }) => `translate(${fx(x6) - marginLeft},${fy(y4) - marginTop})` : fx ? ({ x: x6 }) => `translate(${fx(x6) - marginLeft},0)` : ({ y: y4 }) => `translate(0,${fy(y4) - marginTop})`;
}
function facetExclude(index2) {
  const ex = [];
  const e3 = new Uint32Array(sum(index2, (d3) => d3.length));
  for (const i3 of index2) {
    let n2 = 0;
    for (const j4 of index2) {
      if (i3 === j4)
        continue;
      e3.set(j4, n2);
      n2 += j4.length;
    }
    ex.push(e3.slice(0, n2));
  }
  return ex;
}
var facetAnchors = /* @__PURE__ */ new Map([
  ["top", facetAnchorTop],
  ["right", facetAnchorRight],
  ["bottom", facetAnchorBottom],
  ["left", facetAnchorLeft],
  ["top-left", and(facetAnchorTop, facetAnchorLeft)],
  ["top-right", and(facetAnchorTop, facetAnchorRight)],
  ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
  ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
  ["top-empty", facetAnchorTopEmpty],
  ["right-empty", facetAnchorRightEmpty],
  ["bottom-empty", facetAnchorBottomEmpty],
  ["left-empty", facetAnchorLeftEmpty],
  ["empty", facetAnchorEmpty]
]);
function maybeFacetAnchor(facetAnchor) {
  if (facetAnchor == null)
    return null;
  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
  if (anchor)
    return anchor;
  throw new Error(`invalid facet anchor: ${facetAnchor}`);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function facetIndex(V3) {
  let I4 = indexCache.get(V3);
  if (!I4)
    indexCache.set(V3, I4 = new InternMap(map3(V3, (v3, i3) => [v3, i3])));
  return I4;
}
function facetIndexOf(V3, v3) {
  return facetIndex(V3).get(v3);
}
function facetFind(facets, x6, y4) {
  x6 = keyof2(x6);
  y4 = keyof2(y4);
  return facets.find((f3) => Object.is(keyof2(f3.x), x6) && Object.is(keyof2(f3.y), y4));
}
function facetEmpty(facets, x6, y4) {
  return facetFind(facets, x6, y4)?.empty;
}
function facetAnchorTop(facets, { y: Y4 }, { y: y4 }) {
  return Y4 ? facetIndexOf(Y4, y4) === 0 : true;
}
function facetAnchorBottom(facets, { y: Y4 }, { y: y4 }) {
  return Y4 ? facetIndexOf(Y4, y4) === Y4.length - 1 : true;
}
function facetAnchorLeft(facets, { x: X4 }, { x: x6 }) {
  return X4 ? facetIndexOf(X4, x6) === 0 : true;
}
function facetAnchorRight(facets, { x: X4 }, { x: x6 }) {
  return X4 ? facetIndexOf(X4, x6) === X4.length - 1 : true;
}
function facetAnchorTopEmpty(facets, { y: Y4 }, { x: x6, y: y4, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y4)
    return;
  const i3 = facetIndexOf(Y4, y4);
  if (i3 > 0)
    return facetEmpty(facets, x6, Y4[i3 - 1]);
}
function facetAnchorBottomEmpty(facets, { y: Y4 }, { x: x6, y: y4, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y4)
    return;
  const i3 = facetIndexOf(Y4, y4);
  if (i3 < Y4.length - 1)
    return facetEmpty(facets, x6, Y4[i3 + 1]);
}
function facetAnchorLeftEmpty(facets, { x: X4 }, { x: x6, y: y4, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X4)
    return;
  const i3 = facetIndexOf(X4, x6);
  if (i3 > 0)
    return facetEmpty(facets, X4[i3 - 1], y4);
}
function facetAnchorRightEmpty(facets, { x: X4 }, { x: x6, y: y4, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X4)
    return;
  const i3 = facetIndexOf(X4, x6);
  if (i3 < X4.length - 1)
    return facetEmpty(facets, X4[i3 + 1], y4);
}
function facetAnchorEmpty(facets, channels, { empty: empty3 }) {
  return empty3;
}
function and(a4, b3) {
  return function() {
    return a4.apply(null, arguments) && b3.apply(null, arguments);
  };
}
function facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {
  return fx && fy ? facets.map(({ x: x6, y: y4 }) => groups2.get(x6)?.get(y4) ?? []) : fx ? facets.map(({ x: x6 }) => groups2.get(x6) ?? []) : facets.map(({ y: y4 }) => groups2.get(y4) ?? []);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/mark.js
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults8) {
    const {
      facet = "auto",
      facetAnchor,
      fx,
      fy,
      sort: sort2,
      dx = 0,
      dy = 0,
      margin = 0,
      marginTop = margin,
      marginRight = margin,
      marginBottom = margin,
      marginLeft = margin,
      clip = defaults8?.clip,
      channels: extraChannels,
      tip: tip2,
      render
    } = options;
    this.data = data;
    this.sort = isDomainSort(sort2) ? sort2 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    if (facet === null || facet === false) {
      this.facet = null;
    } else {
      this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
      this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
      this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
    }
    this.facetAnchor = maybeFacetAnchor(facetAnchor);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0)
      channels = { ...maybeChannels(extraChannels), ...channels };
    if (defaults8 !== void 0)
      channels = { ...styles(this, options, defaults8), ...channels };
    this.channels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        if (isOptions(channel.value)) {
          const { value, label = channel.label, scale = channel.scale } = channel.value;
          channel = { ...channel, label, scale, value };
        }
        if (data === singleton && typeof channel.value === "string") {
          const { value } = channel;
          channel = { ...channel, value: [value] };
        }
        return [name, channel];
      }).filter(([name, { value, optional }]) => {
        if (value != null)
          return true;
        if (optional)
          return false;
        throw new Error(`missing channel value: ${name}`);
      })
    );
    this.dx = +dx;
    this.dy = +dy;
    this.marginTop = +marginTop;
    this.marginRight = +marginRight;
    this.marginBottom = +marginBottom;
    this.marginLeft = +marginLeft;
    this.clip = maybeClip(clip);
    this.tip = maybeTip(tip2);
    if (this.facet === "super") {
      if (fx || fy)
        throw new Error(`super-faceting cannot use fx or fy`);
      for (const name in this.channels) {
        const { scale } = channels[name];
        if (scale !== "x" && scale !== "y")
          continue;
        throw new Error(`super-faceting cannot use x or y`);
      }
    }
    if (render != null) {
      this.render = composeRender(render, this.render);
    }
  }
  initialize(facets, facetChannels, plotOptions) {
    let data = arrayify2(this.data);
    if (facets === void 0 && data != null)
      facets = [range2(data)];
    const originalFacets = facets;
    if (this.transform != null)
      ({ facets, data } = this.transform(data, facets, plotOptions)), data = arrayify2(data);
    if (facets !== void 0)
      facets.original = originalFacets;
    const channels = createChannels(this.channels, data);
    if (this.sort != null)
      channelDomain(data, facets, channels, facetChannels, this.sort);
    return { data, facets, channels };
  }
  filter(index2, channels, values2) {
    for (const name in channels) {
      const { filter: filter2 = defined } = channels[name];
      if (filter2 !== null) {
        const value = values2[name];
        index2 = index2.filter((i3) => filter2(value[i3]));
      }
    }
    return index2;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves don’t exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(channels, values2, context) {
    for (const cx in channels) {
      if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
        const cy = cx.replace(/^x|x$/, "y");
        if (cy in channels && channels[cy].scale === "y") {
          project(cx, cy, values2, context.projection);
        }
      }
    }
  }
  scale(channels, scales, context) {
    const values2 = valueObject(channels, scales);
    if (context.projection)
      this.project(channels, values2, context);
    return values2;
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function composeRender(r1, r22) {
  if (r1 == null)
    return r22 === null ? void 0 : r22;
  if (r22 == null)
    return r1 === null ? void 0 : r1;
  if (typeof r1 !== "function")
    throw new TypeError(`invalid render transform: ${r1}`);
  if (typeof r22 !== "function")
    throw new TypeError(`invalid render transform: ${r22}`);
  return function(i3, s4, v3, d3, c6, next) {
    return r1.call(this, i3, s4, v3, d3, c6, (i4, s5, v4, d4, c7) => {
      return r22.call(this, i4, s5, v4, d4, c7, next);
    });
  };
}
function maybeChannels(channels) {
  return Object.fromEntries(
    Object.entries(maybeNamed(channels)).map(([name, channel]) => {
      channel = typeof channel === "string" ? { value: channel, label: name } : maybeValue(channel);
      if (channel.filter === void 0 && channel.scale == null)
        channel = { ...channel, filter: null };
      return [name, channel];
    })
  );
}
function maybeTip(tip2) {
  return tip2 === true ? "xy" : tip2 === false || tip2 == null ? null : typeof tip2 === "string" ? keyword(tip2, "tip", ["x", "y", "xy"]) : tip2;
}
function withTip(options, pointer2) {
  return options?.tip === true ? { ...options, tip: pointer2 } : isObject(options?.tip) && options.tip.pointer === void 0 ? { ...options, tip: { ...options.tip, pointer: pointer2 } } : options;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/interactions/pointer.js
var states = /* @__PURE__ */ new WeakMap();
function pointerK(kx2, ky2, { x: x6, y: y4, px, py, maxRadius = 40, channels, render, ...options } = {}) {
  maxRadius = +maxRadius;
  if (px != null)
    x6 ?? (x6 = null), channels = { ...channels, px: { value: px, scale: "x" } };
  if (py != null)
    y4 ?? (y4 = null), channels = { ...channels, py: { value: py, scale: "y" } };
  return {
    x: x6,
    y: y4,
    channels,
    ...options,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: composeRender(function(index2, scales, values2, dimensions, context, next) {
      context = { ...context, pointerSticky: false };
      const svg = context.ownerSVGElement;
      const { data } = context.getMarkState(this);
      let state = states.get(svg);
      if (!state)
        states.set(svg, state = { sticky: false, roots: [], renders: [] });
      let renderIndex = state.renders.push(render2) - 1;
      const { x: x7, y: y5, fx, fy } = scales;
      let tx = fx ? fx(index2.fx) - dimensions.marginLeft : 0;
      let ty = fy ? fy(index2.fy) - dimensions.marginTop : 0;
      if (x7?.bandwidth)
        tx += x7.bandwidth() / 2;
      if (y5?.bandwidth)
        ty += y5.bandwidth() / 2;
      const faceted = index2.fi != null;
      let facetState;
      if (faceted) {
        let facetStates = state.facetStates;
        if (!facetStates)
          state.facetStates = facetStates = /* @__PURE__ */ new Map();
        facetState = facetStates.get(this);
        if (!facetState)
          facetStates.set(this, facetState = /* @__PURE__ */ new Map());
      }
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { px: PX, py: PY } = values2;
      const px2 = PX ? (i4) => PX[i4] : anchorX(values2, cx);
      const py2 = PY ? (i4) => PY[i4] : anchorY(values2, cy);
      let i3;
      let g4;
      let s4;
      let f3;
      function update(ii, ri) {
        if (faceted) {
          if (f3)
            f3 = cancelAnimationFrame(f3);
          if (ii == null)
            facetState.delete(index2.fi);
          else {
            facetState.set(index2.fi, ri);
            f3 = requestAnimationFrame(() => {
              f3 = null;
              for (const [fi, r3] of facetState) {
                if (r3 < ri || r3 === ri && fi < index2.fi) {
                  ii = null;
                  break;
                }
              }
              render2(ii);
            });
            return;
          }
        }
        render2(ii);
      }
      function render2(ii) {
        if (i3 === ii && s4 === state.sticky)
          return;
        i3 = ii;
        s4 = context.pointerSticky = state.sticky;
        const I4 = i3 == null ? [] : [i3];
        if (faceted)
          I4.fx = index2.fx, I4.fy = index2.fy, I4.fi = index2.fi;
        const r3 = next(I4, scales, values2, dimensions, context);
        if (g4) {
          if (faceted) {
            const p4 = g4.parentNode;
            const ft = g4.getAttribute("transform");
            const mt = r3.getAttribute("transform");
            ft ? r3.setAttribute("transform", ft) : r3.removeAttribute("transform");
            mt ? p4.setAttribute("transform", mt) : p4.removeAttribute("transform");
            r3.removeAttribute("aria-label");
            r3.removeAttribute("aria-description");
            r3.removeAttribute("aria-hidden");
          }
          g4.replaceWith(r3);
        }
        state.roots[renderIndex] = g4 = r3;
        if (!(i3 == null && facetState?.size > 1))
          context.dispatchValue(i3 == null ? null : data[i3]);
        return r3;
      }
      function pointermove(event) {
        if (state.sticky || event.pointerType === "mouse" && event.buttons === 1)
          return;
        let [xp, yp] = pointer_default(event);
        xp -= tx, yp -= ty;
        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx2;
        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky2;
        let ii = null;
        let ri = maxRadius * maxRadius;
        for (const j4 of index2) {
          const dx = kpx * (px2(j4) - xp);
          const dy = kpy * (py2(j4) - yp);
          const rj = dx * dx + dy * dy;
          if (rj <= ri)
            ii = j4, ri = rj;
        }
        if (ii != null && (kx2 !== 1 || ky2 !== 1)) {
          const dx = px2(ii) - xp;
          const dy = py2(ii) - yp;
          ri = dx * dx + dy * dy;
        }
        update(ii, ri);
      }
      function pointerdown(event) {
        if (event.pointerType !== "mouse")
          return;
        if (i3 == null)
          return;
        if (state.sticky && state.roots.some((r3) => r3?.contains(event.target)))
          return;
        if (state.sticky)
          state.sticky = false, state.renders.forEach((r3) => r3(null));
        else
          state.sticky = true, render2(i3);
        event.stopImmediatePropagation();
      }
      function pointerleave(event) {
        if (event.pointerType !== "mouse")
          return;
        if (!state.sticky)
          update(null);
      }
      svg.addEventListener("pointerenter", pointermove);
      svg.addEventListener("pointermove", pointermove);
      svg.addEventListener("pointerdown", pointerdown);
      svg.addEventListener("pointerleave", pointerleave);
      return render2(null);
    }, render)
  };
}
function pointer(options) {
  return pointerK(1, 1, options);
}
function pointerX(options) {
  return pointerK(1, 0.01, options);
}
function pointerY(options) {
  return pointerK(0.01, 1, options);
}
function anchorX({ x1: X12, x2: X23, x: X4 = X12 }, cx) {
  return X12 && X23 ? (i3) => (X12[i3] + X23[i3]) / 2 : X4 ? (i3) => X4[i3] : () => cx;
}
function anchorY({ y1: Y12, y2: Y23, y: Y4 = Y12 }, cy) {
  return Y12 && Y23 ? (i3) => (Y12[i3] + Y23[i3]) / 2 : Y4 ? (i3) => Y4[i3] : () => cy;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/axes.js
function inferFontVariant(scale) {
  return isOrdinalScale(scale) && scale.interval === void 0 ? void 0 : "tabular-nums";
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/legends/ramp.js
function legendRamp(color3, options) {
  let {
    label = color3.label,
    tickSize = 6,
    width = 240,
    height = 44 + tickSize,
    marginTop = 18,
    marginRight = 0,
    marginBottom = 16 + tickSize,
    marginLeft = 0,
    style,
    ticks: ticks2 = (width - marginLeft - marginRight) / 64,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(color3),
    round = true,
    opacity: opacity2,
    className
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  opacity2 = maybeNumberChannel(opacity2)[1];
  if (tickFormat2 === null)
    tickFormat2 = () => null;
  const svg = create2("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}-ramp) {
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
:where(.${className}-ramp text) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  let tickAdjust = (g4) => g4.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x6;
  const applyRange = round ? (x7, range4) => x7.rangeRound(range4) : (x7, range4) => x7.range(range4);
  const { type: type2, domain, range: range3, interpolate, scale, pivot } = color3;
  if (interpolate) {
    const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
    x6 = applyRange(
      scale.copy(),
      quantize_default(
        number_default(marginLeft, width - marginRight),
        Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)
      )
    );
    const n2 = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n2;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i3 = 0, j4 = n2 - 1; i3 < n2; ++i3) {
      context2.fillStyle = interpolator(i3 / j4);
      context2.fillRect(i3, 0, 1, 1);
    }
    svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type2 === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat2 === void 0 ? (d3) => d3 : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
    x6 = applyRange(linear2().domain([-1, range3.length - 1]), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range3).enter().append("rect").attr("x", (d3, i3) => x6(i3 - 1)).attr("y", marginTop).attr("width", (d3, i3) => x6(i3) - x6(i3 - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d3) => d3);
    ticks2 = map3(thresholds, (_3, i3) => i3);
    tickFormat2 = (i3) => thresholdFormat(thresholds[i3], i3);
  } else {
    x6 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x6).attr("y", marginTop).attr("width", Math.max(0, x6.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale);
    tickAdjust = () => {
    };
  }
  svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
    axisBottom(x6).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g4) => g4.select(".domain").remove());
  if (label !== void 0) {
    svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
  }
  return svg.node();
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/math.js
var radians3 = Math.PI / 180;

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marker.js
function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark.markerStart = maybeMarker(markerStart);
  mark.markerMid = maybeMarker(markerMid);
  mark.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false)
    return null;
  if (marker === true)
    return markerCircleFill;
  if (typeof marker === "function")
    return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow("auto");
    case "arrow-reverse":
      return markerArrow("auto-start-reverse");
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
    case "tick":
      return markerTick("auto");
    case "tick-x":
      return markerTick(90);
    case "tick-y":
      return markerTick(0);
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(orient) {
  return (color3, context) => create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerTick(orient) {
  return (color3, context) => create2("svg:marker", context).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", orient).attr("stroke", color3).call((marker) => marker.append("path").attr("d", "M0,-3v6")).node();
}
var nextMarkerId = 0;
function applyMarkers(path2, mark, { stroke: S3 }, context) {
  return applyMarkersColor(path2, mark, S3 && ((i3) => S3[i3]), context);
}
function applyGroupedMarkers(path2, mark, { stroke: S3 }, context) {
  return applyMarkersColor(path2, mark, S3 && (([i3]) => S3[i3]), context);
}
function applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, context) {
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  function applyMarker(marker) {
    return function(i3) {
      const color3 = strokeof(i3);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor)
        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color3);
      if (!iri) {
        const node = this.parentNode.insertBefore(marker(color3, context), this);
        const id2 = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id2);
        iriByColor.set(color3, iri = `url(#${id2})`);
      }
      return iri;
    };
  }
  if (markerStart)
    path2.attr("marker-start", applyMarker(markerStart));
  if (markerMid)
    path2.attr("marker-mid", applyMarker(markerMid));
  if (markerEnd)
    path2.attr("marker-end", applyMarker(markerEnd));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/inset.js
function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
  return { inset, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
  return { inset, insetTop, insetBottom, ...options };
}
function maybeInset(inset, inset1, inset2) {
  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/interval.js
function maybeIntervalValue(value, { interval: interval2 }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
  return value;
}
function maybeIntervalK(k5, maybeInsetK, options, trivial) {
  const { [k5]: v3, [`${k5}1`]: v1, [`${k5}2`]: v22 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null && !trivial)
    return options;
  const label = labelof(v3);
  if (interval2 == null) {
    let V3;
    const kv = { transform: (data) => V3 || (V3 = valueof(data, value)), label };
    return {
      ...options,
      [k5]: void 0,
      [`${k5}1`]: v1 === void 0 ? kv : v1,
      [`${k5}2`]: v22 === void 0 && !(v1 === v22 && trivial) ? kv : v22
    };
  }
  let D1, V1;
  function transform2(data) {
    if (V1 !== void 0 && data === D1)
      return V1;
    return V1 = map3(valueof(D1 = data, value), (v4) => interval2.floor(v4));
  }
  return maybeInsetK({
    ...options,
    [k5]: void 0,
    [`${k5}1`]: v1 === void 0 ? { transform: transform2, label } : v1,
    [`${k5}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v4) => interval2.offset(v4)), label } : v22
  });
}
function maybeIntervalMidK(k5, maybeInsetK, options) {
  const { [k5]: v3 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null)
    return options;
  return maybeInsetK({
    ...options,
    [k5]: {
      label: labelof(v3),
      transform: (data) => {
        const V1 = map3(valueof(data, value), (v4) => interval2.floor(v4));
        const V22 = V1.map((v4) => interval2.offset(v4));
        return V1.map(
          isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V22[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V22[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
        );
      }
    }
  });
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/rule.js
var defaults = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x: x6, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y1: { value: y12, scale: "y", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      withTip(options, "x"),
      defaults
    );
    this.insetTop = number5(insetTop);
    this.insetBottom = number5(insetBottom);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y4 } = scales;
    const { x: X4, y1: Y12, y2: Y23 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetTop, insetBottom } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X4 && x6 }, offset, 0).call(
      (g4) => g4.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X4 ? (i3) => X4[i3] : (marginLeft + width - marginRight) / 2).attr("x2", X4 ? (i3) => X4[i3] : (marginLeft + width - marginRight) / 2).attr("y1", Y12 && !isCollapsed(y4) ? (i3) => Y12[i3] + insetTop : marginTop + insetTop).attr(
        "y2",
        Y23 && !isCollapsed(y4) ? y4.bandwidth ? (i3) => Y23[i3] + y4.bandwidth() - insetBottom : (i3) => Y23[i3] - insetBottom : height - marginBottom - insetBottom
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, x2: x22, y: y4, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(
      data,
      {
        y: { value: y4, scale: "y", optional: true },
        x1: { value: x12, scale: "x", optional: true },
        x2: { value: x22, scale: "x", optional: true }
      },
      withTip(options, "y"),
      defaults
    );
    this.insetRight = number5(insetRight);
    this.insetLeft = number5(insetLeft);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y4 } = scales;
    const { y: Y4, x1: X12, x2: X23 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetLeft, insetRight } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y4 && y4 }, 0, offset).call(
      (g4) => g4.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X12 && !isCollapsed(x6) ? (i3) => X12[i3] + insetLeft : marginLeft + insetLeft).attr(
        "x2",
        X23 && !isCollapsed(x6) ? x6.bandwidth ? (i3) => X23[i3] + x6.bandwidth() - insetRight : (i3) => X23[i3] - insetRight : width - marginRight - insetRight
      ).attr("y1", Y4 ? (i3) => Y4[i3] : (marginTop + height - marginBottom) / 2).attr("y2", Y4 ? (i3) => Y4[i3] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function ruleX(data, options) {
  let { x: x6 = identity6, y: y4, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
  [y12, y22] = maybeOptionalZero(y4, y12, y22);
  return new RuleX(data, { ...rest, x: x6, y1: y12, y2: y22 });
}
function ruleY(data, options) {
  let { y: y4 = identity6, x: x6, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
  [x12, x22] = maybeOptionalZero(x6, x12, x22);
  return new RuleY(data, { ...rest, y: y4, x1: x12, x2: x22 });
}
function maybeOptionalZero(x6, x12, x22) {
  if (x6 == null) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [0, x22];
    } else {
      if (x22 === void 0)
        return [0, x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [0, x6] : [x6, x22];
  } else if (x22 === void 0) {
    return [x6, x12];
  }
  return [x12, x22];
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/template.js
function template(strings2, ...parts) {
  let n2 = parts.length;
  for (let j4 = 0, copy3 = true; j4 < n2; ++j4) {
    if (typeof parts[j4] !== "function") {
      if (copy3) {
        strings2 = strings2.slice();
        copy3 = false;
      }
      strings2.splice(j4, 2, strings2[j4] + parts[j4] + strings2[j4 + 1]);
      parts.splice(j4, 1);
      --j4, --n2;
    }
  }
  return (i3) => {
    let s4 = strings2[0];
    for (let j4 = 0; j4 < n2; ++j4) {
      s4 += parts[j4](i3) + strings2[j4 + 1];
    }
    return s4;
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/text.js
var defaults2 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var softHyphen = "\xAD";
var Text = class extends Mark {
  constructor(data, options = {}) {
    const {
      x: x6,
      y: y4,
      text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf,
      frameAnchor,
      textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
      lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
      lineHeight = 1,
      lineWidth = Infinity,
      textOverflow,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      rotate
    } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        fontSize: { value: vfontSize, optional: true },
        rotate: { value: numberChannel(vrotate), optional: true },
        text: { value: text2, filter: nonempty, optional: true }
      },
      options,
      defaults2
    );
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    if (!(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${lineWidth}`);
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y4 } = scales;
    const { x: X4, y: Y4, rotate: R2, text: T4, title: TL, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T4, dimensions).call(applyTransform, this, { x: X4 && x6, y: Y4 && y4 }).call(
      (g4) => g4.selectAll().data(index2).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T4, TL).attr(
        "transform",
        template`translate(${X4 ? (i3) => X4[i3] : cx},${Y4 ? (i3) => Y4[i3] : cy})${R2 ? (i3) => ` rotate(${R2[i3]})` : rotate ? ` rotate(${rotate})` : ``}`
      ).call(applyAttr, "font-size", FS && ((i3) => FS[i3])).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeTextOverflow(textOverflow) {
  return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    // … ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function applyMultilineText(selection2, mark, T4, TL) {
  if (!T4)
    return;
  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;
  selection2.each(function(i3) {
    const lines = splitLines(formatDefault(T4[i3]) ?? "").map(clipLine);
    const n2 = lines.length;
    const y4 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n2 : (164 - n2 * 100) / 200;
    if (n2 > 1) {
      let m3 = 0;
      for (let i4 = 0; i4 < n2; ++i4) {
        ++m3;
        if (!lines[i4])
          continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        if (i4 === m3 - 1)
          tspan.setAttribute("y", `${(y4 + i4) * lineHeight}em`);
        else
          tspan.setAttribute("dy", `${m3 * lineHeight}em`);
        tspan.textContent = lines[i4];
        this.appendChild(tspan);
        m3 = 0;
      }
    } else {
      if (y4)
        this.setAttribute("y", `${y4 * lineHeight}em`);
      this.textContent = lines[0];
    }
    if (textOverflow && !TL && lines[0] !== T4[i3]) {
      const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
      title.textContent = T4[i3];
      this.appendChild(title);
    }
  });
}
function text(data, { x: x6, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x6, y4] = maybeTuple(x6, y4);
  return new Text(data, { ...options, x: x6, y: y4 });
}
function textX(data, { x: x6 = identity6, ...options } = {}) {
  return new Text(data, maybeIntervalMidY({ ...options, x: x6 }));
}
function textY(data, { y: y4 = identity6, ...options } = {}) {
  return new Text(data, maybeIntervalMidX({ ...options, y: y4 }));
}
function applyIndirectTextStyles(selection2, mark, T4) {
  applyAttr(selection2, "text-anchor", mark.textAnchor);
  applyAttr(selection2, "font-family", mark.fontFamily);
  applyAttr(selection2, "font-size", mark.fontSize);
  applyAttr(selection2, "font-style", mark.fontStyle);
  applyAttr(selection2, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T4) : mark.fontVariant);
  applyAttr(selection2, "font-weight", mark.fontWeight);
}
function inferFontVariant2(T4) {
  return T4 && (isNumeric(T4) || isTemporal(T4)) ? "tabular-nums" : void 0;
}
var fontSizes = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number")
    return [void 0, fontSize];
  if (typeof fontSize !== "string")
    return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input, maxWidth, widthof) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {
    if (lineStart === void 0)
      lineStart = wordStart;
    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
      lineStart = wordStart;
    }
    if (required) {
      lines.push(input.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input) {
  let i3 = 0, j4 = 0;
  const n2 = input.length;
  while (j4 < n2) {
    let k5 = 1;
    switch (input[j4]) {
      case softHyphen:
      case "-":
        ++j4;
        yield [i3, j4, false];
        i3 = j4;
        break;
      case " ":
        yield [i3, j4, false];
        while (input[++j4] === " ")
          ;
        i3 = j4;
        break;
      case "\r":
        if (input[j4 + 1] === "\n")
          ++k5;
      case "\n":
        yield [i3, j4, true];
        j4 += k5;
        i3 = j4;
        break;
      default:
        ++j4;
        break;
    }
  }
  yield [i3, j4, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "\u2018": 31,
  "\u2019": 31,
  "\u201C": 47,
  "\u201D": 47,
  "\u2026": 82
};
function defaultWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i3 = start2; i3 < end; i3 = readCharacter(text2, i3)) {
    sum2 += defaultWidthMap[text2[i3]] ?? (isPictographic(text2, i3) ? 120 : defaultWidthMap.e);
  }
  return sum2;
}
function monospaceWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i3 = start2; i3 < end; i3 = readCharacter(text2, i3)) {
    sum2 += isPictographic(text2, i3) ? 126 : 63;
  }
  return sum2;
}
function splitter({ monospace, lineWidth, textOverflow }) {
  if (textOverflow != null || lineWidth == Infinity)
    return (text2) => text2.split(/\r\n?|\n/g);
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  return (text2) => lineWrap(text2, maxWidth, widthof);
}
function clipper({ monospace, lineWidth, textOverflow }) {
  if (textOverflow == null || lineWidth == Infinity)
    return (text2) => text2;
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  switch (textOverflow) {
    case "clip-start":
      return (text2) => clipStart(text2, maxWidth, widthof, "");
    case "clip-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, "");
    case "ellipsis-start":
      return (text2) => clipStart(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-middle":
      return (text2) => clipMiddle(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, ellipsis);
  }
}
var ellipsis = "\u2026";
function cut(text2, width, widthof, inset) {
  const I4 = [];
  let w4 = 0;
  for (let i3 = 0, j4 = 0, n2 = text2.length; i3 < n2; i3 = j4) {
    j4 = readCharacter(text2, i3);
    const l3 = widthof(text2, i3, j4);
    if (w4 + l3 > width) {
      w4 += inset;
      while (w4 > width && i3 > 0)
        j4 = i3, i3 = I4.pop(), w4 -= widthof(text2, i3, j4);
      return [i3, width - w4];
    }
    w4 += l3;
    I4.push(i3);
  }
  return [-1, 0];
}
function clipEnd(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const e3 = widthof(ellipsis2);
  const [i3] = cut(text2, width, widthof, e3);
  return i3 < 0 ? text2 : text2.slice(0, i3).trimEnd() + ellipsis2;
}
function clipMiddle(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w4 = widthof(text2);
  if (w4 <= width)
    return text2;
  const e3 = widthof(ellipsis2) / 2;
  const [i3, ei] = cut(text2, width / 2, widthof, e3);
  const [j4] = cut(text2, w4 - width / 2 - ei + e3, widthof, -e3);
  return j4 < 0 ? ellipsis2 : text2.slice(0, i3).trimEnd() + ellipsis2 + text2.slice(readCharacter(text2, j4)).trimStart();
}
function clipStart(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w4 = widthof(text2);
  if (w4 <= width)
    return text2;
  const e3 = widthof(ellipsis2);
  const [j4] = cut(text2, w4 - width + e3, widthof, -e3);
  return j4 < 0 ? ellipsis2 : ellipsis2 + text2.slice(readCharacter(text2, j4)).trimStart();
}
var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
var rePictographic = /\p{Extended_Pictographic}/uy;
function readCharacter(text2, i3) {
  i3 += isSurrogatePair(text2, i3) ? 2 : 1;
  if (isCombiner(text2, i3))
    i3 = reCombiner.lastIndex;
  if (isZeroWidthJoiner(text2, i3))
    return readCharacter(text2, i3 + 1);
  return i3;
}
function isAscii(text2, i3) {
  return text2.charCodeAt(i3) < 128;
}
function isSurrogatePair(text2, i3) {
  const hi = text2.charCodeAt(i3);
  if (hi >= 55296 && hi < 56320) {
    const lo = text2.charCodeAt(i3 + 1);
    return lo >= 56320 && lo < 57344;
  }
  return false;
}
function isZeroWidthJoiner(text2, i3) {
  return text2.charCodeAt(i3) === 8205;
}
function isCombiner(text2, i3) {
  return isAscii(text2, i3) ? false : (reCombiner.lastIndex = i3, reCombiner.test(text2));
}
function isPictographic(text2, i3) {
  return isAscii(text2, i3) ? false : (rePictographic.lastIndex = i3, rePictographic.test(text2));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/vector.js
var defaults3 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
};
var defaultRadius = 3.5;
var wingRatio = defaultRadius * 5;
var shapeArrow = {
  draw(context, l3, r3) {
    const wing = l3 * r3 / wingRatio;
    context.moveTo(0, 0);
    context.lineTo(0, -l3);
    context.moveTo(-wing, wing - l3);
    context.lineTo(0, -l3);
    context.lineTo(wing, wing - l3);
  }
};
var shapeSpike = {
  draw(context, l3, r3) {
    context.moveTo(-r3, 0);
    context.lineTo(0, -l3);
    context.lineTo(r3, 0);
  }
};
var shapes = /* @__PURE__ */ new Map([
  ["arrow", shapeArrow],
  ["spike", shapeSpike]
]);
function isShapeObject(value) {
  return value && typeof value.draw === "function";
}
function maybeShape(shape) {
  if (isShapeObject(shape))
    return shape;
  const value = shapes.get(`${shape}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid shape: ${shape}`);
}
var Vector = class extends Mark {
  constructor(data, options = {}) {
    const { x: x6, y: y4, r: r3 = defaultRadius, length: length3, rotate, shape = shapeArrow, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length3, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x6, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        length: { value: vl, scale: "length", optional: true },
        rotate: { value: vr, optional: true }
      },
      options,
      defaults3
    );
    this.r = +r3;
    this.length = cl;
    this.rotate = cr;
    this.shape = maybeShape(shape);
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x6, y: y4 } = scales;
    const { x: X4, y: Y4, length: L4, rotate: A6 } = channels;
    const { length: length3, rotate, anchor, shape, r: r3 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X4 && x6, y: Y4 && y4 }).call(
      (g4) => g4.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
        "transform",
        template`translate(${X4 ? (i3) => X4[i3] : cx},${Y4 ? (i3) => Y4[i3] : cy})${A6 ? (i3) => ` rotate(${A6[i3]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L4 ? (i3) => ` translate(0,${L4[i3]})` : ` translate(0,${length3})` : L4 ? (i3) => ` translate(0,${L4[i3] / 2})` : ` translate(0,${length3 / 2})`}`
      ).attr(
        "d",
        L4 ? (i3) => {
          const p4 = pathRound();
          shape.draw(p4, L4[i3], r3);
          return p4;
        } : (() => {
          const p4 = pathRound();
          shape.draw(p4, length3, r3);
          return p4;
        })()
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function vectorX(data, options = {}) {
  const { x: x6 = identity6, ...rest } = options;
  return new Vector(data, { ...rest, x: x6 });
}
function vectorY(data, options = {}) {
  const { y: y4 = identity6, ...rest } = options;
  return new Vector(data, { ...rest, y: y4 });
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/axis.js
function maybeData(data, options) {
  if (arguments.length < 2 && !isIterable(data))
    options = data, data = null;
  if (options === void 0)
    options = {};
  return [data, options];
}
function maybeAnchor2({ anchor } = {}, anchors) {
  return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
}
function anchorY2(options) {
  return maybeAnchor2(options, ["left", "right"]);
}
function anchorFy(options) {
  return maybeAnchor2(options, ["right", "left"]);
}
function anchorX2(options) {
  return maybeAnchor2(options, ["bottom", "top"]);
}
function anchorFx(options) {
  return maybeAnchor2(options, ["top", "bottom"]);
}
function axisY() {
  const [data, options] = maybeData(...arguments);
  return axisKy("y", anchorY2(options), data, options);
}
function axisFy() {
  const [data, options] = maybeData(...arguments);
  return axisKy("fy", anchorFy(options), data, options);
}
function axisX() {
  const [data, options] = maybeData(...arguments);
  return axisKx("x", anchorX2(options), data, options);
}
function axisFx() {
  const [data, options] = maybeData(...arguments);
  return axisKx("fx", anchorFx(options), data, options);
}
function axisKy(k5, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k5 === "y" ? 6 : 0,
  tickPadding,
  tickRotate,
  x: x6,
  margin,
  marginTop = margin === void 0 ? 20 : margin,
  marginRight = margin === void 0 ? anchor === "right" ? 40 : 0 : margin,
  marginBottom = margin === void 0 ? 20 : margin,
  marginLeft = margin === void 0 ? anchor === "left" ? 40 : 0 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKy(k5, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      x: x6,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKy(k5, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      x: x6,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale = scales[k5];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k5 === "y" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale.bandwidth ? "center" : "top");
        const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
        if (cla === "center") {
          this.textAnchor = void 0;
          this.lineAnchor = anchor === "right" ? "bottom" : "top";
          this.frameAnchor = anchor;
          this.rotate = -90;
        } else {
          this.textAnchor = anchor === "right" ? "end" : "start";
          this.lineAnchor = cla;
          this.frameAnchor = `${cla}-${anchor}`;
          this.rotate = 0;
        }
        this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
        this.dx = anchor === "right" ? clo : -clo;
        this.ariaLabel = `${k5}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k5, scale, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisKx(k5, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k5 === "x" ? 6 : 0,
  tickPadding,
  tickRotate,
  y: y4,
  margin,
  marginTop = margin === void 0 ? anchor === "top" ? 30 : 0 : margin,
  marginRight = margin === void 0 ? 20 : margin,
  marginBottom = margin === void 0 ? anchor === "bottom" ? 30 : 0 : margin,
  marginLeft = margin === void 0 ? 20 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKx(k5, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      y: y4,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKx(k5, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      y: y4,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale = scales[k5];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k5 === "x" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale.bandwidth ? "center" : "right");
        const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
        if (cla === "center") {
          this.frameAnchor = anchor;
          this.textAnchor = void 0;
        } else {
          this.frameAnchor = `${anchor}-${cla}`;
          this.textAnchor = cla === "right" ? "end" : "start";
        }
        this.lineAnchor = anchor;
        this.dy = anchor === "top" ? -clo : clo;
        this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
        this.ariaLabel = `${k5}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k5, scale, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisTickKy(k5, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k5 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y4 = k5 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    vectorY,
    k5,
    data,
    {
      ariaLabel: `${k5}-axis tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinecap,
      strokeLinejoin,
      facetAnchor,
      frameAnchor,
      y: y4,
      ...options,
      dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
      anchor: "start",
      length: tickSize,
      shape: anchor === "left" ? shapeTickLeft : shapeTickRight
    }
  );
}
function axisTickKx(k5, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k5 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x6 = k5 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    vectorX,
    k5,
    data,
    {
      ariaLabel: `${k5}-axis tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinejoin,
      strokeLinecap,
      facetAnchor,
      frameAnchor,
      x: x6,
      ...options,
      dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
      anchor: "start",
      length: tickSize,
      shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
    }
  );
}
function axisTextKy(k5, anchor, data, {
  facetAnchor = anchor + (k5 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
  lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
  fontVariant,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y4 = k5 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textY,
    k5,
    data,
    { ariaLabel: `${k5}-axis tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      y: y4,
      ...options,
      dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
    },
    function(scale, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function axisTextKx(k5, anchor, data, {
  facetAnchor = anchor + (k5 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
  lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
  fontVariant,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x6 = k5 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textX,
    k5,
    data,
    { ariaLabel: `${k5}-axis tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text2 === void 0 ? null : text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      x: x6,
      ...options,
      dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
    },
    function(scale, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function gridY() {
  const [data, options] = maybeData(...arguments);
  return gridKy("y", anchorY2(options), data, options);
}
function gridFy() {
  const [data, options] = maybeData(...arguments);
  return gridKy("fy", anchorFy(options), data, options);
}
function gridX() {
  const [data, options] = maybeData(...arguments);
  return gridKx("x", anchorX2(options), data, options);
}
function gridFx() {
  const [data, options] = maybeData(...arguments);
  return gridKx("fx", anchorFx(options), data, options);
}
function gridKy(k5, anchor, data, {
  y: y4 = k5 === "y" ? void 0 : null,
  x: x6 = null,
  x1: x12 = anchor === "left" ? x6 : null,
  x2: x22 = anchor === "right" ? x6 : null,
  ...options
}) {
  return axisMark(ruleY, k5, data, { ariaLabel: `${k5}-grid`, ariaHidden: true }, { y: y4, x1: x12, x2: x22, ...gridDefaults(options) });
}
function gridKx(k5, anchor, data, {
  x: x6 = k5 === "x" ? void 0 : null,
  y: y4 = null,
  y1: y12 = anchor === "top" ? y4 : null,
  y2: y22 = anchor === "bottom" ? y4 : null,
  ...options
}) {
  return axisMark(ruleX, k5, data, { ariaLabel: `${k5}-grid`, ariaHidden: true }, { x: x6, y1: y12, y2: y22, ...gridDefaults(options) });
}
function gridDefaults({
  color: color3 = "currentColor",
  opacity: opacity2 = 0.1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  ...options
}) {
  return { stroke, strokeOpacity, strokeWidth, ...options };
}
function labelOptions({
  fill,
  fillOpacity,
  fontFamily,
  fontSize,
  fontStyle,
  fontVariant,
  fontWeight,
  monospace,
  pointerEvents,
  shapeRendering,
  clip = false
}, initializer2) {
  [, fill] = maybeColorChannel(fill);
  [, fillOpacity] = maybeNumberChannel(fillOpacity);
  return {
    facet: "super",
    x: null,
    y: null,
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontVariant,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    clip,
    initializer: initializer2
  };
}
function axisMark(mark, k5, data, properties, options, initialize) {
  let channels;
  function axisInitializer(data2, facets, _channels, scales, dimensions, context) {
    const initializeFacets = data2 == null && (k5 === "fx" || k5 === "fy");
    const { [k5]: scale } = scales;
    if (!scale)
      throw new Error(`missing scale: ${k5}`);
    const domain = scale.domain();
    let { interval: interval2, ticks: ticks2, tickFormat: tickFormat2, tickSpacing = k5 === "x" ? 80 : 35 } = options;
    if (typeof ticks2 === "string" && hasTemporalDomain(scale))
      interval2 = ticks2, ticks2 = void 0;
    if (ticks2 === void 0)
      ticks2 = maybeRangeInterval(interval2, scale.type) ?? inferTickCount(scale, tickSpacing);
    if (data2 == null) {
      if (isIterable(ticks2)) {
        data2 = arrayify2(ticks2);
      } else if (isInterval(ticks2)) {
        data2 = inclusiveRange(ticks2, ...extent(domain));
      } else if (scale.interval) {
        let interval3 = scale.interval;
        if (scale.ticks) {
          const [min4, max3] = extent(domain);
          const n2 = (max3 - min4) / interval3[intervalDuration];
          interval3 = generalizeTimeInterval(interval3, n2 / ticks2) ?? interval3;
          data2 = inclusiveRange(interval3, min4, max3);
        } else {
          data2 = domain;
          const n2 = data2.length;
          interval3 = generalizeTimeInterval(interval3, n2 / ticks2) ?? interval3;
          if (interval3 !== scale.interval)
            data2 = inclusiveRange(interval3, ...extent(data2));
        }
        if (interval3 === scale.interval) {
          const n2 = Math.round(data2.length / ticks2);
          if (n2 > 1)
            data2 = data2.filter((d3, i3) => i3 % n2 === 0);
        }
      } else if (scale.ticks) {
        data2 = scale.ticks(ticks2);
      } else {
        data2 = domain;
      }
      if (!scale.ticks && data2.length && data2 !== domain) {
        const domainSet = new InternSet(domain);
        data2 = data2.filter((d3) => domainSet.has(d3));
        if (!data2.length)
          warn(`Warning: the ${k5}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
      }
      if (k5 === "y" || k5 === "x") {
        facets = [range2(data2)];
      } else {
        channels[k5] = { scale: k5, value: identity6 };
      }
    }
    initialize?.call(this, scale, data2, ticks2, tickFormat2, channels);
    const initializedChannels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        return [name, { ...channel, value: valueof(data2, channel.value) }];
      })
    );
    if (initializeFacets)
      facets = context.filterFacets(data2, initializedChannels);
    return { data: data2, facets, channels: initializedChannels };
  }
  const basicInitializer = initializer(options).initializer;
  const m3 = mark(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
  if (data == null) {
    channels = m3.channels;
    m3.channels = {};
  } else {
    channels = {};
  }
  if (properties !== void 0)
    Object.assign(m3, properties);
  if (m3.clip === void 0)
    m3.clip = false;
  return m3;
}
function inferTickCount(scale, tickSpacing) {
  const [min4, max3] = extent(scale.range());
  return (max3 - min4) / tickSpacing;
}
function inferTextChannel(scale, data, ticks2, tickFormat2, anchor) {
  return { value: inferTickFormat(scale, data, ticks2, tickFormat2, anchor) };
}
function inferTickFormat(scale, data, ticks2, tickFormat2, anchor) {
  return typeof tickFormat2 === "function" ? tickFormat2 : tickFormat2 === void 0 && data && isTemporal(data) ? inferTimeFormat(scale.type, data, anchor) ?? formatDefault : scale.tickFormat ? scale.tickFormat(typeof ticks2 === "number" ? ticks2 : null, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === "string" ? (isTemporal(scale.domain()) ? utcFormat : format)(tickFormat2) : constant(tickFormat2);
}
function inclusiveRange(interval2, min4, max3) {
  return interval2.range(min4, interval2.offset(interval2.floor(max3)));
}
var shapeTickBottom = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(0, l3);
  }
};
var shapeTickTop = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(0, -l3);
  }
};
var shapeTickLeft = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(-l3, 0);
  }
};
var shapeTickRight = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(l3, 0);
  }
};
function inferFontVariant3(scale) {
  return scale.bandwidth && !scale.interval ? void 0 : "tabular-nums";
}
function formatAxisLabel(k5, scale, { anchor, label = scale.label, labelAnchor, labelArrow } = {}) {
  if (label == null || label.inferred && hasTemporalDomain(scale) && /^(date|time|year)$/i.test(label))
    return;
  label = String(label);
  if (labelArrow === "auto")
    labelArrow = (!scale.bandwidth || scale.interval) && !/[↑↓→←]/.test(label);
  if (!labelArrow)
    return label;
  if (labelArrow === true) {
    const order = inferScaleOrder(scale);
    if (order)
      labelArrow = /x$/.test(k5) || labelAnchor === "center" ? /x$/.test(k5) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
  }
  switch (labelArrow) {
    case "left":
      return `\u2190 ${label}`;
    case "right":
      return `${label} \u2192`;
    case "up":
      return anchor === "right" ? `${label} \u2191` : `\u2191 ${label}`;
    case "down":
      return anchor === "right" ? `${label} \u2193` : `\u2193 ${label}`;
  }
  return label;
}
function maybeLabelArrow(labelArrow = "auto") {
  return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function hasTemporalDomain(scale) {
  return isTemporal(scale.domain());
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/legends/swatches.js
function maybeScale(scale, key) {
  if (key == null)
    return key;
  const s4 = scale(key);
  if (!s4)
    throw new Error(`scale not found: ${key}`);
  return s4;
}
function legendSwatches(color3, { opacity: opacity2, ...options } = {}) {
  if (!isOrdinalScale(color3) && !isThresholdScale(color3))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
  return legendItems(
    color3,
    options,
    (selection2, scale, width, height) => selection2.append("svg").attr("width", width).attr("height", height).attr("fill", scale.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function legendSymbols(symbol2, {
  fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none",
  fillOpacity = 1,
  stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
  strokeOpacity = 1,
  strokeWidth = 1.5,
  r: r3 = 4.5,
  ...options
} = {}, scale) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale, vf);
  const ss = maybeScale(scale, vs);
  const size = r3 * r3 * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(
    symbol2,
    options,
    (selection2, scale2, width, height) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d3) => sf.scale(d3) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d3) => ss.scale(d3) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d3) => {
      const p4 = pathRound();
      symbol2.scale(d3).draw(p4, size);
      return p4;
    })
  );
}
function legendItems(scale, options = {}, swatch) {
  let {
    columns,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(scale),
    // TODO label,
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft = 0,
    className,
    style,
    width
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  tickFormat2 = inferTickFormat(scale.scale, scale.domain, void 0, tickFormat2);
  const swatches = create2("div", context).attr(
    "class",
    `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
  );
  let extraStyle;
  if (columns != null) {
    extraStyle = `:where(.${className}-swatches-columns .${className}-swatch) {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
:where(.${className}-swatches-columns .${className}-swatch::before) {
  flex-shrink: 0;
}
:where(.${className}-swatches-columns .${className}-swatch-label) {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
    swatches.style("columns", columns).selectAll().data(scale.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale, swatchWidth, swatchHeight).call(
      (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
    );
  } else {
    extraStyle = `:where(.${className}-swatches-wrap) {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
:where(.${className}-swatches-wrap .${className}-swatch) {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
    swatches.selectAll().data(scale.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale, swatchWidth, swatchHeight).append(function() {
      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
    });
  }
  return swatches.call(
    (div) => div.insert("style", "*").text(
      `:where(.${className}-swatches) {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
:where(.${className}-swatch > svg) {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
    )
  ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function exposeLegends(scales, context, defaults8 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key))
      throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales))
      return;
    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults8[key], options), (key2) => scales[key2]);
  };
}
function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
  return inherit2(options, { className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 });
}
function legendColor(color3, { legend = true, ...options }) {
  if (legend === true)
    legend = color3.type === "ordinal" ? "swatches" : "ramp";
  if (color3.domain === void 0)
    return;
  switch (`${legend}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color3, options);
    case "ramp":
      return legendRamp(color3, options);
    default:
      throw new Error(`unknown legend type: ${legend}`);
  }
}
function legendOpacity({ type: type2, interpolate, ...scale }, { legend = true, color: color3 = rgb(0, 0, 0), ...options }) {
  if (!interpolate)
    throw new Error(`${type2} opacity scales are not supported`);
  if (legend === true)
    legend = "ramp";
  if (`${legend}`.toLowerCase() !== "ramp")
    throw new Error(`${legend} opacity legends are not supported`);
  return legendColor({ type: type2, ...scale, interpolate: interpolateOpacity(color3) }, { legend, ...options });
}
function interpolateOpacity(color3) {
  const { r: r3, g: g4, b: b3 } = rgb(color3) || rgb(0, 0, 0);
  return (t4) => `rgba(${r3},${g4},${b3},${t4})`;
}
function createLegends(scales, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o3 = options[key];
    if (o3?.legend && key in scales) {
      const legend = value(scales[key], legendOptions(context, scales[key], o3), (key2) => scales[key2]);
      if (legend != null)
        legends.push(legend);
    }
  }
  return legends;
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/frame.js
var defaults4 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: false
};
var lineDefaults = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: false
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const {
      anchor = null,
      inset = 0,
      insetTop = inset,
      insetRight = inset,
      insetBottom = inset,
      insetLeft = inset,
      rx,
      ry
    } = options;
    super(singleton, void 0, options, anchor == null ? defaults4 : lineDefaults);
    this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = number5(rx);
    this.ry = number5(ry);
  }
  render(index2, scales, channels, dimensions, context) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    const x12 = marginLeft + insetLeft;
    const x22 = width - marginRight - insetRight;
    const y12 = marginTop + insetTop;
    const y22 = height - marginBottom - insetBottom;
    return create2(anchor ? "svg:line" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
      anchor === "left" ? (line2) => line2.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line2) => line2.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect) => rect.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
    ).node();
  }
};
function frame2(options) {
  return new Frame(options);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/tip.js
var defaults5 = {
  ariaLabel: "tip",
  fill: "var(--plot-background)",
  stroke: "currentColor"
};
var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
var Tip = class extends Mark {
  constructor(data, options = {}) {
    if (options.tip)
      options = { ...options, tip: false };
    if (options.title === void 0 && isIterable(data) && isTextual(data))
      options = { ...options, title: identity6 };
    const {
      x: x6,
      y: y4,
      x1: x12,
      x2: x22,
      y1: y12,
      y2: y22,
      anchor,
      preferredAnchor = "bottom",
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      lineHeight = 1,
      lineWidth = 20,
      frameAnchor,
      format: format3,
      textAnchor = "start",
      textOverflow,
      textPadding = 8,
      title,
      pointerSize = 12,
      pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = options;
    super(
      data,
      {
        x: { value: x12 != null && x22 != null ? null : x6, scale: "x", optional: true },
        // ignore midpoint
        y: { value: y12 != null && y22 != null ? null : y4, scale: "y", optional: true },
        // ignore midpoint
        x1: { value: x12, scale: "x", optional: x22 == null },
        y1: { value: y12, scale: "y", optional: y22 == null },
        x2: { value: x22, scale: "x", optional: x12 == null },
        y2: { value: y22, scale: "y", optional: y12 == null },
        title: { value: title, optional: true }
        // filter: defined
      },
      options,
      defaults5
    );
    this.anchor = maybeAnchor(anchor, "anchor");
    this.preferredAnchor = maybeAnchor(preferredAnchor, "preferredAnchor");
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.textAnchor = impliedString(textAnchor, "middle");
    this.textPadding = +textPadding;
    this.pointerSize = +pointerSize;
    this.pathFilter = string(pathFilter);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = number5(fontSize);
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    for (const key in defaults5)
      if (key in this.channels)
        this[key] = defaults5[key];
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
    this.format = { ...format3 };
  }
  render(index2, scales, values2, dimensions, context) {
    const mark = this;
    const { x: x6, y: y4, fx, fy } = scales;
    const { ownerSVGElement: svg, document: document2 } = context;
    const { anchor, monospace, lineHeight, lineWidth } = this;
    const { textPadding: r3, pointerSize: m3, pathFilter } = this;
    const { marginTop, marginLeft } = dimensions;
    const { x1: X12, y1: Y12, x2: X23, y2: Y23, x: X4 = X12 ?? X23, y: Y4 = Y12 ?? Y23 } = values2;
    const ox = fx ? fx(index2.fx) - marginLeft : 0;
    const oy = fy ? fy(index2.fy) - marginTop : 0;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const px = anchorX(values2, cx);
    const py = anchorY(values2, cy);
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const ee = widthof(ellipsis);
    let sources, format3;
    if ("title" in values2) {
      sources = values2.channels;
      format3 = formatTitle;
    } else {
      sources = getSourceChannels.call(this, values2, scales);
      format3 = formatChannels;
    }
    const g4 = create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X4 && x6, y: Y4 && y4 }).call(
      (g5) => g5.selectAll().data(index2).enter().append("g").attr("transform", (i3) => `translate(${Math.round(px(i3))},${Math.round(py(i3))})`).call(applyDirectStyles, this).call((g6) => g6.append("path").attr("filter", pathFilter)).call(
        (g6) => g6.append("text").each(function(i3) {
          const that = select_default2(this);
          this.setAttribute("fill", "currentColor");
          this.setAttribute("fill-opacity", 1);
          this.setAttribute("stroke", "none");
          const lines = format3.call(mark, i3, index2, sources, scales, values2);
          if (typeof lines === "string") {
            for (const line2 of mark.splitLines(lines)) {
              renderLine(that, { value: mark.clipLine(line2) });
            }
          } else {
            const labels = /* @__PURE__ */ new Set();
            for (const line2 of lines) {
              const { label = "" } = line2;
              if (label && labels.has(label))
                continue;
              else
                labels.add(label);
              renderLine(that, line2);
            }
          }
        })
      )
    );
    function renderLine(selection2, { label, value, color: color3, opacity: opacity2 }) {
      label ?? (label = ""), value ?? (value = "");
      const swatch = color3 != null || opacity2 != null;
      let title;
      let w4 = lineWidth * 100;
      const [j4] = cut(label, w4, widthof, ee);
      if (j4 >= 0) {
        label = label.slice(0, j4).trimEnd() + ellipsis;
        title = value.trim();
        value = "";
      } else {
        if (label || !value && !swatch)
          value = " " + value;
        const [k5] = cut(value, w4 - widthof(label), widthof, ee);
        if (k5 >= 0) {
          title = value.trim();
          value = value.slice(0, k5).trimEnd() + ellipsis;
        }
      }
      const line2 = selection2.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("\u200B");
      if (label)
        line2.append("tspan").attr("font-weight", "bold").text(label);
      if (value)
        line2.append(() => document2.createTextNode(value));
      if (swatch)
        line2.append("tspan").text(" \u25A0").attr("fill", color3).attr("fill-opacity", opacity2).style("user-select", "none");
      if (title)
        line2.append("title").text(title);
    }
    function postrender() {
      const { width, height } = dimensions.facet ?? dimensions;
      g4.selectChildren().each(function(i3) {
        let { x: tx, width: w4, height: h3 } = this.getBBox();
        w4 = Math.round(w4), h3 = Math.round(h3);
        let a4 = anchor;
        if (a4 === void 0) {
          const x7 = px(i3) + ox;
          const y5 = py(i3) + oy;
          const fitLeft = x7 + w4 + m3 + r3 * 2 < width;
          const fitRight = x7 - w4 - m3 - r3 * 2 > 0;
          const fitTop = y5 + h3 + m3 + r3 * 2 < height;
          const fitBottom = y5 - h3 - m3 - r3 * 2 > 0;
          a4 = fitLeft && fitRight ? fitTop && fitBottom ? mark.preferredAnchor : fitBottom ? "bottom" : "top" : fitTop && fitBottom ? fitLeft ? "left" : "right" : (fitLeft || fitRight) && (fitTop || fitBottom) ? `${fitBottom ? "bottom" : "top"}-${fitLeft ? "left" : "right"}` : mark.preferredAnchor;
        }
        const path2 = this.firstChild;
        const text2 = this.lastChild;
        path2.setAttribute("d", getPath(a4, m3, r3, w4, h3));
        if (tx)
          for (const t4 of text2.childNodes)
            t4.setAttribute("x", -tx);
        text2.setAttribute("y", `${+getLineOffset(a4, text2.childNodes.length, lineHeight).toFixed(6)}em`);
        text2.setAttribute("transform", `translate(${getTextTranslate(a4, m3, r3, w4, h3)})`);
      });
      g4.attr("visibility", null);
    }
    if (index2.length) {
      g4.attr("visibility", "hidden");
      if (svg.isConnected)
        Promise.resolve().then(postrender);
      else if (typeof requestAnimationFrame !== "undefined")
        requestAnimationFrame(postrender);
    }
    return g4.node();
  }
};
function tip(data, { x: x6, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x6, y4] = maybeTuple(x6, y4);
  return new Tip(data, { ...options, x: x6, y: y4 });
}
function getLineOffset(anchor, length3, lineHeight) {
  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length3 * lineHeight : length3 / 2 * lineHeight;
}
function getTextTranslate(anchor, m3, r3, width, height) {
  switch (anchor) {
    case "middle":
      return [-width / 2, height / 2];
    case "top-left":
      return [r3, m3 + r3];
    case "top":
      return [-width / 2, m3 / 2 + r3];
    case "top-right":
      return [-width - r3, m3 + r3];
    case "right":
      return [-m3 / 2 - width - r3, height / 2];
    case "bottom-left":
      return [r3, -m3 - r3];
    case "bottom":
      return [-width / 2, -m3 / 2 - r3];
    case "bottom-right":
      return [-width - r3, -m3 - r3];
    case "left":
      return [r3 + m3 / 2, height / 2];
  }
}
function getPath(anchor, m3, r3, width, height) {
  const w4 = width + r3 * 2;
  const h3 = height + r3 * 2;
  switch (anchor) {
    case "middle":
      return `M${-w4 / 2},${-h3 / 2}h${w4}v${h3}h${-w4}z`;
    case "top-left":
      return `M0,0l${m3},${m3}h${w4 - m3}v${h3}h${-w4}z`;
    case "top":
      return `M0,0l${m3 / 2},${m3 / 2}h${(w4 - m3) / 2}v${h3}h${-w4}v${-h3}h${(w4 - m3) / 2}z`;
    case "top-right":
      return `M0,0l${-m3},${m3}h${m3 - w4}v${h3}h${w4}z`;
    case "right":
      return `M0,0l${-m3 / 2},${-m3 / 2}v${m3 / 2 - h3 / 2}h${-w4}v${h3}h${w4}v${m3 / 2 - h3 / 2}z`;
    case "bottom-left":
      return `M0,0l${m3},${-m3}h${w4 - m3}v${-h3}h${-w4}z`;
    case "bottom":
      return `M0,0l${m3 / 2},${-m3 / 2}h${(w4 - m3) / 2}v${-h3}h${-w4}v${h3}h${(w4 - m3) / 2}z`;
    case "bottom-right":
      return `M0,0l${-m3},${-m3}h${m3 - w4}v${-h3}h${w4}z`;
    case "left":
      return `M0,0l${m3 / 2},${-m3 / 2}v${m3 / 2 - h3 / 2}h${w4}v${h3}h${-w4}v${m3 / 2 - h3 / 2}z`;
  }
}
function getSourceChannels({ channels }, scales) {
  const sources = {};
  let format3 = this.format;
  format3 = maybeExpandPairedFormat(format3, channels, "x");
  format3 = maybeExpandPairedFormat(format3, channels, "y");
  this.format = format3;
  for (const key in format3) {
    const value = format3[key];
    if (value === null || value === false) {
      continue;
    } else if (key === "fx" || key === "fy") {
      sources[key] = true;
    } else {
      const source = getSource(channels, key);
      if (source)
        sources[key] = source;
    }
  }
  for (const key in channels) {
    if (key in sources || key in format3 || ignoreChannels.has(key))
      continue;
    const source = getSource(channels, key);
    if (source)
      sources[key] = source;
  }
  if (this.facet) {
    if (scales.fx && !("fx" in format3))
      sources.fx = true;
    if (scales.fy && !("fy" in format3))
      sources.fy = true;
  }
  for (const key in sources) {
    const format4 = this.format[key];
    if (typeof format4 === "string") {
      const value = sources[key]?.value ?? scales[key]?.domain() ?? [];
      this.format[key] = (isTemporal(value) ? utcFormat : format)(format4);
    } else if (format4 === void 0 || format4 === true) {
      const scale = scales[key];
      this.format[key] = scale?.bandwidth ? inferTickFormat(scale, scale.domain()) : formatDefault;
    }
  }
  return sources;
}
function maybeExpandPairedFormat(format3, channels, key) {
  if (!(key in format3))
    return format3;
  const key1 = `${key}1`;
  const key2 = `${key}2`;
  if ((key1 in format3 || !(key1 in channels)) && (key2 in format3 || !(key2 in channels)))
    return format3;
  const entries = Object.entries(format3);
  const value = format3[key];
  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);
  return Object.fromEntries(entries);
}
function formatTitle(i3, index2, { title }) {
  return formatDefault(title.value[i3], i3);
}
function* formatChannels(i3, index2, channels, scales, values2) {
  for (const key in channels) {
    if (key === "fx" || key === "fy") {
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](index2[key], i3)
      };
      continue;
    }
    if (key === "x1" && "x2" in channels)
      continue;
    if (key === "y1" && "y2" in channels)
      continue;
    const channel = channels[key];
    if (key === "x2" && "x1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "x"),
        value: formatPair(this.format.x2, channels.x1, channel, i3)
      };
    } else if (key === "y2" && "y1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "y"),
        value: formatPair(this.format.y2, channels.y1, channel, i3)
      };
    } else {
      const value = channel.value[i3];
      const scale = channel.scale;
      if (!defined(value) && scale == null)
        continue;
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](value, i3),
        color: scale === "color" ? values2[key][i3] : null,
        opacity: scale === "opacity" ? values2[key][i3] : null
      };
    }
  }
}
function formatPair(formatValue, c1, c22, i3) {
  return c22.hint?.length ? `${formatValue(c22.value[i3] - c1.value[i3], i3)}` : `${formatValue(c1.value[i3], i3)}\u2013${formatValue(c22.value[i3], i3)}`;
}
function formatPairLabel(scales, channels, key) {
  const l1 = formatLabel(scales, channels, `${key}1`, key);
  const l22 = formatLabel(scales, channels, `${key}2`, key);
  return l1 === l22 ? l1 : `${l1}\u2013${l22}`;
}
function formatLabel(scales, channels, key, defaultLabel = key) {
  const channel = channels[key];
  const scale = scales[channel?.scale ?? key];
  return String(scale?.label ?? channel?.label ?? defaultLabel);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/plot.js
function plot(options = {}) {
  const { facet, style, title, subtitle, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
  marks2.push(...inferTips(marks2));
  const topFacetState = maybeTopFacet(facet, options);
  const facetStateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  const channelsByScale = /* @__PURE__ */ new Map();
  if (topFacetState)
    addScaleChannels(channelsByScale, [topFacetState], options);
  addScaleChannels(channelsByScale, facetStateByMark, options);
  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
  for (const mark of axes) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  marks2.unshift(...axes);
  let facets = createFacets(channelsByScale, options);
  if (facets !== void 0) {
    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
    for (const mark of marks2) {
      if (mark.facet === null || mark.facet === "super")
        continue;
      const facetState = facetStateByMark.get(mark);
      if (facetState === void 0)
        continue;
      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
    }
    const nonEmpty = /* @__PURE__ */ new Set();
    for (const { facetsIndex } of facetStateByMark.values()) {
      facetsIndex?.forEach((index2, i3) => {
        if (index2?.length > 0) {
          nonEmpty.add(i3);
        }
      });
    }
    facets.forEach(
      0 < nonEmpty.size && nonEmpty.size < facets.length ? (f3, i3) => f3.empty = !nonEmpty.has(i3) : (f3) => f3.empty = false
    );
    for (const mark of marks2) {
      if (mark.facet === "exclude") {
        const facetState = facetStateByMark.get(mark);
        if (facetState !== void 0)
          facetState.facetsIndex = facetExclude(facetState.facetsIndex);
      }
    }
  }
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  const stateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    if (stateByMark.has(mark))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};
    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels, options);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark, { data, facets: facets2, channels });
  }
  const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
  const dimensions = createDimensions(scaleDescriptors, marks2, options);
  autoScaleRange(scaleDescriptors, dimensions);
  const scales = createScaleFunctions(scaleDescriptors);
  const { fx, fy } = scales;
  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
  const context = createContext(options);
  const document2 = context.document;
  const svg = creator_default("svg").call(document2.documentElement);
  let figure = svg;
  context.ownerSVGElement = svg;
  context.className = className;
  context.projection = createProjection(options, subdimensions);
  context.filterFacets = (data, channels) => {
    return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
  };
  context.getMarkState = (mark) => {
    const state = stateByMark.get(mark);
    const facetState = facetStateByMark.get(mark);
    return { ...state, channels: { ...state.channels, ...facetState?.channels } };
  };
  context.dispatchValue = (value) => {
    if (figure.value === value)
      return;
    figure.value = value;
    figure.dispatchEvent(new Event("input", { bubbles: true }));
  };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark, state] of stateByMark) {
    if (mark.initializer != null) {
      const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
      if (update.data !== void 0) {
        state.data = update.data;
      }
      if (update.facets !== void 0) {
        state.facets = update.facets;
      }
      if (update.channels !== void 0) {
        const { fx: fx2, fy: fy2, ...channels } = update.channels;
        inferChannelScales(channels);
        Object.assign(state.channels, channels);
        for (const channel of Object.values(channels)) {
          const { scale } = channel;
          if (scale != null && !isPosition(registry.get(scale))) {
            applyScaleTransform(channel, options);
            newByScale.add(scale);
          }
        }
        if (fx2 != null || fy2 != null)
          facetStateByMark.set(mark, true);
      }
    }
  }
  if (newByScale.size) {
    const newChannelsByScale = /* @__PURE__ */ new Map();
    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
    const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
    const { scales: newExposedScales, ...newScales } = createScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales, newScales);
    Object.assign(scales.scales, newExposedScales);
  }
  let facetDomains, facetTranslate;
  if (facets !== void 0) {
    facetDomains = { x: fx?.domain(), y: fy?.domain() };
    facets = recreateFacets(facets, facetDomains);
    facetTranslate = facetTranslator(fx, fy, dimensions);
  }
  for (const [mark, state] of stateByMark) {
    state.values = mark.scale(state.channels, scales, context);
  }
  const { width, height } = dimensions;
  select_default2(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}) {
  --plot-background: white;
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
:where(.${className} text),
:where(.${className} tspan) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  for (const mark of marks2) {
    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);
    if (facets === void 0 || mark.facet === "super") {
      let index2 = null;
      if (indexes2) {
        index2 = indexes2[0];
        index2 = mark.filter(index2, channels, values2);
        if (index2.length === 0)
          continue;
      }
      const node = mark.render(index2, scales, values2, superdimensions, context);
      if (node == null)
        continue;
      svg.appendChild(node);
    } else {
      let g4;
      for (const f3 of facets) {
        if (!(mark.facetAnchor?.(facets, facetDomains, f3) ?? !f3.empty))
          continue;
        let index2 = null;
        if (indexes2) {
          const faceted = facetStateByMark.has(mark);
          index2 = indexes2[faceted ? f3.i : 0];
          index2 = mark.filter(index2, channels, values2);
          if (index2.length === 0)
            continue;
          if (!faceted && index2 === indexes2[0])
            index2 = subarray(index2);
          index2.fx = f3.x, index2.fy = f3.y, index2.fi = f3.i;
        }
        const node = mark.render(index2, scales, values2, subdimensions, context);
        if (node == null)
          continue;
        (g4 ?? (g4 = select_default2(svg).append("g"))).append(() => node).datum(f3);
        for (const name of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
          if (node.hasAttribute(name)) {
            g4.attr(name, node.getAttribute(name));
            node.removeAttribute(name);
          }
        }
      }
      g4?.selectChildren().attr("transform", facetTranslate);
    }
  }
  const legends = createLegends(scaleDescriptors, context, options);
  const { figure: figured = title != null || subtitle != null || caption != null || legends.length > 0 } = options;
  if (figured) {
    figure = document2.createElement("figure");
    figure.className = `${className}-figure`;
    figure.style.maxWidth = "initial";
    if (title != null)
      figure.append(createTitleElement(document2, title, "h2"));
    if (subtitle != null)
      figure.append(createTitleElement(document2, subtitle, "h3"));
    figure.append(...legends, svg);
    if (caption != null)
      figure.append(createFigcaption(document2, caption));
  }
  figure.scale = exposeScales(scales.scales);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w4 = consumeWarnings();
  if (w4 > 0) {
    select_default2(svg).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w4.toLocaleString("en-US")} warning${w4 === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
function createTitleElement(document2, contents, tag) {
  if (contents.ownerDocument)
    return contents;
  const e3 = document2.createElement(tag);
  e3.append(contents);
  return e3;
}
function createFigcaption(document2, caption) {
  const e3 = document2.createElement("figcaption");
  e3.append(caption);
  return e3;
}
function plotThis({ marks: marks2 = [], ...options } = {}) {
  return plot({ ...options, marks: [...marks2, this] });
}
Mark.prototype.plot = plotThis;
function flatMarks(marks2) {
  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
}
function markify(mark) {
  return typeof mark.render === "function" ? mark : new Render(mark);
}
var Render = class extends Mark {
  constructor(render) {
    if (typeof render !== "function")
      throw new TypeError("invalid mark; missing render function");
    super();
    this.render = render;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name in channels)
    applyScaleTransform(channels[name], options);
  return channels;
}
function applyScaleTransform(channel, options) {
  const { scale, transform: t4 = true } = channel;
  if (scale == null || !t4)
    return;
  const {
    type: type2,
    percent,
    interval: interval2,
    transform: transform2 = percent ? (x6) => x6 * 100 : maybeIntervalTransform(interval2, type2)
  } = options[scale] ?? {};
  if (transform2 == null)
    return;
  channel.value = map3(channel.value, transform2);
  channel.transform = false;
}
function inferChannelScales(channels) {
  for (const name in channels) {
    inferChannelScale(name, channels[name]);
  }
}
function addScaleChannels(channelsByScale, stateByMark, options, filter2 = yes) {
  for (const { channels } of stateByMark.values()) {
    for (const name in channels) {
      const channel = channels[name];
      const { scale } = channel;
      if (scale != null && filter2(scale)) {
        if (scale === "projection") {
          if (!hasProjection(options)) {
            const gx = options.x?.domain === void 0;
            const gy = options.y?.domain === void 0;
            if (gx || gy) {
              const [x6, y4] = getGeometryChannels(channel);
              if (gx)
                addScaleChannel(channelsByScale, "x", x6);
              if (gy)
                addScaleChannel(channelsByScale, "y", y4);
            }
          }
        } else {
          addScaleChannel(channelsByScale, scale, channel);
        }
      }
    }
  }
  return channelsByScale;
}
function addScaleChannel(channelsByScale, scale, channel) {
  const scaleChannels = channelsByScale.get(scale);
  if (scaleChannels !== void 0)
    scaleChannels.push(channel);
  else
    channelsByScale.set(scale, [channel]);
}
function maybeTopFacet(facet, options) {
  if (facet == null)
    return;
  const { x: x6, y: y4 } = facet;
  if (x6 == null && y4 == null)
    return;
  const data = arrayify2(facet.data);
  if (data == null)
    throw new Error("missing facet data");
  const channels = {};
  if (x6 != null)
    channels.fx = createChannel(data, { value: x6, scale: "fx" });
  if (y4 != null)
    channels.fy = createChannel(data, { value: y4, scale: "fy" });
  applyScaleTransforms(channels, options);
  const groups2 = facetGroups(data, channels);
  return { channels, groups: groups2, data: facet.data };
}
function maybeMarkFacet(mark, topFacetState, options) {
  if (mark.facet === null || mark.facet === "super")
    return;
  const { fx, fy } = mark;
  if (fx != null || fy != null) {
    const data2 = arrayify2(mark.data ?? fx ?? fy);
    if (data2 === void 0)
      throw new Error(`missing facet data in ${mark.ariaLabel}`);
    if (data2 === null)
      return;
    const channels2 = {};
    if (fx != null)
      channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
    if (fy != null)
      channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
    applyScaleTransforms(channels2, options);
    return { channels: channels2, groups: facetGroups(data2, channels2) };
  }
  if (topFacetState === void 0)
    return;
  const { channels, groups: groups2, data } = topFacetState;
  if (mark.facet !== "auto" || mark.data === data)
    return { channels, groups: groups2 };
  if (data.length > 0 && (groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {
    warn(
      `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
    );
  }
}
function derive(mark, options = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, context) => {
    return context.getMarkState(mark);
  });
}
function inferTips(marks2) {
  const tips = [];
  for (const mark of marks2) {
    let tipOptions = mark.tip;
    if (tipOptions) {
      if (tipOptions === true)
        tipOptions = {};
      else if (typeof tipOptions === "string")
        tipOptions = { pointer: tipOptions };
      let { pointer: p4, preferredAnchor: a4 } = tipOptions;
      p4 = /^x$/i.test(p4) ? pointerX : /^y$/i.test(p4) ? pointerY : pointer;
      tipOptions = p4(derive(mark, tipOptions));
      tipOptions.title = null;
      if (a4 === void 0)
        tipOptions.preferredAnchor = p4 === pointerY ? "left" : "bottom";
      const t4 = tip(mark.data, tipOptions);
      t4.facet = mark.facet;
      t4.facetAnchor = mark.facetAnchor;
      tips.push(t4);
    }
  }
  return tips;
}
function inferAxes(marks2, channelsByScale, options) {
  let {
    projection: projection3,
    x: x6 = {},
    y: y4 = {},
    fx = {},
    fy = {},
    axis: axis2,
    grid,
    facet = {},
    facet: { axis: facetAxis = axis2, grid: facetGrid } = facet,
    x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x6,
    y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y4,
    fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx,
    fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy
  } = options;
  if (projection3 || !isScaleOptions(x6) && !hasPositionChannel("x", marks2))
    xAxis = xGrid = null;
  if (projection3 || !isScaleOptions(y4) && !hasPositionChannel("y", marks2))
    yAxis = yGrid = null;
  if (!channelsByScale.has("fx"))
    fxAxis = fxGrid = null;
  if (!channelsByScale.has("fy"))
    fyAxis = fyGrid = null;
  if (xAxis === void 0)
    xAxis = !hasAxis(marks2, "x");
  if (yAxis === void 0)
    yAxis = !hasAxis(marks2, "y");
  if (fxAxis === void 0)
    fxAxis = !hasAxis(marks2, "fx");
  if (fyAxis === void 0)
    fyAxis = !hasAxis(marks2, "fy");
  if (xAxis === true)
    xAxis = "bottom";
  if (yAxis === true)
    yAxis = "left";
  if (fxAxis === true)
    fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
  if (fyAxis === true)
    fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
  const axes = [];
  maybeGrid(axes, fyGrid, gridFy, fy);
  maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
  maybeGrid(axes, fxGrid, gridFx, fx);
  maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
  maybeGrid(axes, yGrid, gridY, y4);
  maybeAxis(axes, yAxis, axisY, "left", "right", options, y4);
  maybeGrid(axes, xGrid, gridX, x6);
  maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x6);
  return axes;
}
function maybeAxis(axes, axis2, axisType, primary, secondary, defaults8, options) {
  if (!axis2)
    return;
  const both = isBoth(axis2);
  options = axisOptions(both ? primary : axis2, defaults8, options);
  const { line: line2 } = options;
  if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2))
    axes.push(frame2(lineOptions(options)));
  axes.push(axisType(options));
  if (both)
    axes.push(axisType({ ...options, anchor: secondary, label: null }));
}
function maybeGrid(axes, grid, gridType, options) {
  if (!grid || isNone(grid))
    return;
  axes.push(gridType(gridOptions(grid, options)));
}
function isBoth(value) {
  return /^\s*both\s*$/i.test(value);
}
function axisOptions(anchor, defaults8, {
  line: line2 = defaults8.line,
  ticks: ticks2,
  tickSize,
  tickSpacing,
  tickPadding,
  tickFormat: tickFormat2,
  tickRotate,
  fontVariant,
  ariaLabel,
  ariaDescription,
  label = defaults8.label,
  labelAnchor,
  labelArrow = defaults8.labelArrow,
  labelOffset
}) {
  return {
    anchor,
    line: line2,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat: tickFormat2,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label,
    labelAnchor,
    labelArrow,
    labelOffset
  };
}
function lineOptions(options) {
  const { anchor, line: line2 } = options;
  return { anchor, facetAnchor: anchor + "-empty", stroke: line2 === true ? void 0 : line2 };
}
function gridOptions(grid, {
  stroke = isColor(grid) ? grid : void 0,
  ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
  tickSpacing,
  ariaLabel,
  ariaDescription
}) {
  return {
    stroke,
    ticks: ticks2,
    tickSpacing,
    ariaLabel,
    ariaDescription
  };
}
function isGridTicks(grid) {
  switch (typeof grid) {
    case "number":
      return true;
    case "string":
      return !isColor(grid);
  }
  return isIterable(grid) || typeof grid?.range === "function";
}
function hasAxis(marks2, k5) {
  const prefix = `${k5}-axis `;
  return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));
}
function hasPositionChannel(k5, marks2) {
  for (const mark of marks2) {
    for (const key in mark.channels) {
      const { scale } = mark.channels[key];
      if (scale === k5 || scale === "projection") {
        return true;
      }
    }
  }
  return false;
}
function inheritScaleLabels(newScales, scales) {
  for (const key in newScales) {
    const newScale = newScales[key];
    const scale = scales[key];
    if (newScale.label === void 0 && scale) {
      newScale.label = scale.label;
    }
  }
  return newScales;
}
function actualDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  const fxr = fx && outerRange(fx);
  const fyr = fy && outerRange(fy);
  return {
    marginTop: fy ? fyr[0] : marginTop,
    marginRight: fx ? width - fxr[1] : marginRight,
    marginBottom: fy ? height - fyr[1] : marginBottom,
    marginLeft: fx ? fxr[0] : marginLeft,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: dimensions.marginTop,
      marginRight: dimensions.marginRight,
      marginBottom: dimensions.marginBottom,
      marginLeft: dimensions.marginLeft
    },
    width,
    height
  };
}
function outerRange(scale) {
  const domain = scale.domain();
  let x12 = scale(domain[0]);
  let x22 = scale(domain[domain.length - 1]);
  if (x22 < x12)
    [x12, x22] = [x22, x12];
  return [x12, x22 + scale.bandwidth()];
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/curve.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default2],
  ["basis-closed", basisClosed_default2],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function maybeCurve(curve = linear_default, tension) {
  if (typeof curve === "function")
    return curve;
  const c6 = curves.get(`${curve}`.toLowerCase());
  if (!c6)
    throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c6) {
      return c6.beta(tension);
    } else if ("tension" in c6) {
      return c6.tension(tension);
    } else if ("alpha" in c6) {
      return c6.alpha(tension);
    }
  }
  return c6;
}
function maybeCurveAuto(curve = curveAuto, tension) {
  return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
}
function curveAuto(context) {
  return linear_default(context);
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x6, y: y4 } = options;
  return binn(maybeBinValue(x6, options, identity6), null, null, y4, outputs, maybeInsetX(options));
}
function maybeDenseInterval(bin, k5, options = {}) {
  if (options?.interval == null)
    return options;
  const { reduce: reduce2 = reduceFirst } = options;
  const outputs = { filter: null };
  if (options[k5] != null)
    outputs[k5] = reduce2;
  if (options[`${k5}1`] != null)
    outputs[`${k5}1`] = reduce2;
  if (options[`${k5}2`] != null)
    outputs[`${k5}2`] = reduce2;
  return bin(outputs, options);
}
function maybeDenseIntervalX(options = {}) {
  return maybeDenseInterval(binX, "y", withTip(options, "x"));
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  // TODO avoid materializing when unused?
  filter: filter2 = reduceCount,
  // return only non-empty bins by default
  sort: sort2,
  reverse: reverse2,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeBinOutputs(outputs, inputs);
  reduceData = maybeBinReduce(reduceData, identity6);
  sort2 = sort2 == null ? void 0 : maybeBinOutput("sort", sort2, inputs);
  filter2 = filter2 == null ? void 0 : maybeBinEvaluator("filter", filter2, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
    gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
    gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k5, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k5);
  const {
    x: x6,
    y: y4,
    z: z4,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    // consumed if x is an output
    y1: y12,
    y2: y22,
    // consumed if y is an output
    domain,
    cumulative,
    thresholds,
    interval: interval2,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z4);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z4 },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const K5 = maybeApplyInterval(valueof(data, k5), plotOptions?.[gk]);
      const Z3 = valueof(data, z4);
      const F3 = valueof(data, vfill);
      const S3 = valueof(data, vstroke);
      const G2 = maybeSubgroup(outputs, { z: Z3, fill: F3, stroke: S3 });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K5 && setGK([]);
      const GZ2 = Z3 && setGZ([]);
      const GF2 = F3 && setGF([]);
      const GS2 = S3 && setGS([]);
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      const bin = bing(bx, by, data);
      let i3 = 0;
      for (const o3 of outputs)
        o3.initialize(data);
      if (sort2)
        sort2.initialize(data);
      if (filter2)
        filter2.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o3 of outputs)
          o3.scope("facet", facet);
        if (sort2)
          sort2.scope("facet", facet);
        if (filter2)
          filter2.scope("facet", facet);
        for (const [f3, I4] of maybeGroup(facet, G2)) {
          for (const [k6, g4] of maybeGroup(I4, K5)) {
            for (const [b3, extent3] of bin(g4)) {
              if (G2)
                extent3.z = f3;
              if (filter2 && !filter2.reduce(b3, extent3))
                continue;
              groupFacet.push(i3++);
              groupData.push(reduceData.reduceIndex(b3, data, extent3));
              if (K5)
                GK2.push(k6);
              if (Z3)
                GZ2.push(G2 === Z3 ? f3 : Z3[(b3.length > 0 ? b3 : g4)[0]]);
              if (F3)
                GF2.push(G2 === F3 ? f3 : F3[(b3.length > 0 ? b3 : g4)[0]]);
              if (S3)
                GS2.push(G2 === S3 ? f3 : S3[(b3.length > 0 ? b3 : g4)[0]]);
              if (BX12)
                BX12.push(extent3.x1), BX22.push(extent3.x2);
              if (BY12)
                BY12.push(extent3.y1), BY22.push(extent3.y2);
              for (const o3 of outputs)
                o3.reduce(b3, extent3);
              if (sort2)
                sort2.reduce(b3, extent3);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort2, reverse2);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x6, x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y4, y1: y12, y2: y22 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0)
    value.domain = domain;
  if (value.cumulative === void 0)
    value.cumulative = cumulative;
  if (value.thresholds === void 0)
    value.thresholds = thresholds;
  if (value.interval === void 0)
    value.interval = interval2;
  if (value.value === void 0)
    value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBin(options) {
  if (options == null)
    return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin = (data) => {
    let V3 = valueof(data, value);
    let T4;
    if (isTemporal(V3) || isTimeThresholds(thresholds)) {
      V3 = map3(V3, coerceDate, Float64Array);
      let [min4, max3] = typeof domain === "function" ? domain(V3) : domain;
      let t4 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V3, min4, max3) : thresholds;
      if (typeof t4 === "number")
        t4 = utcTickInterval(min4, max3, t4);
      if (isInterval(t4)) {
        if (domain === extent) {
          min4 = t4.floor(min4);
          max3 = t4.offset(t4.floor(max3));
        }
        t4 = t4.range(min4, t4.offset(max3));
      }
      T4 = t4;
    } else {
      V3 = coerceNumbers(V3);
      let [min4, max3] = typeof domain === "function" ? domain(V3) : domain;
      let t4 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V3, min4, max3) : thresholds;
      if (typeof t4 === "number") {
        if (domain === extent) {
          let step = tickIncrement(min4, max3, t4);
          if (isFinite(step)) {
            if (step > 0) {
              let r0 = Math.round(min4 / step);
              let r1 = Math.round(max3 / step);
              if (!(r0 * step <= min4))
                --r0;
              if (!(r1 * step > max3))
                ++r1;
              let n2 = r1 - r0 + 1;
              t4 = new Float64Array(n2);
              for (let i3 = 0; i3 < n2; ++i3)
                t4[i3] = (r0 + i3) * step;
            } else if (step < 0) {
              step = -step;
              let r0 = Math.round(min4 * step);
              let r1 = Math.round(max3 * step);
              if (!(r0 / step <= min4))
                --r0;
              if (!(r1 / step > max3))
                ++r1;
              let n2 = r1 - r0 + 1;
              t4 = new Float64Array(n2);
              for (let i3 = 0; i3 < n2; ++i3)
                t4[i3] = (r0 + i3) / step;
            } else {
              t4 = [min4];
            }
          } else {
            t4 = [min4];
          }
        } else {
          t4 = ticks(min4, max3, t4);
        }
      } else if (isInterval(t4)) {
        if (domain === extent) {
          min4 = t4.floor(min4);
          max3 = t4.offset(t4.floor(max3));
        }
        t4 = t4.range(min4, t4.offset(max3));
      }
      T4 = t4;
    }
    const E3 = [];
    if (T4.length === 1)
      E3.push([T4[0], T4[0]]);
    else
      for (let i3 = 1; i3 < T4.length; ++i3)
        E3.push([T4[i3 - 1], T4[i3]]);
    E3.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E3, T4, V3);
    return E3;
  };
  bin.label = labelof(value);
  return bin;
}
function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
  if (thresholds === void 0) {
    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    return maybeUtcInterval(thresholds);
  }
  return thresholds;
}
function maybeBinOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeBinOutput);
}
function maybeBinOutput(name, reduce2, inputs) {
  return maybeOutput(name, reduce2, inputs, maybeBinEvaluator);
}
function maybeBinEvaluator(name, reduce2, inputs) {
  return maybeEvaluator(name, reduce2, inputs, maybeBinReduce);
}
function maybeBinReduce(reduce2, value) {
  return maybeReduce(reduce2, value, maybeBinReduceFallback);
}
function maybeBinReduceFallback(reduce2) {
  switch (`${reduce2}`.toLowerCase()) {
    case "x":
      return reduceX;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX2;
    case "y":
      return reduceY;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY2;
    case "z":
      return reduceZ;
  }
  throw new Error(`invalid bin reduce: ${reduce2}`);
}
function thresholdAuto(values2, min4, max3) {
  return Math.min(200, thresholdScott(values2, min4, max3));
}
function isTimeThresholds(t4) {
  return isTimeInterval(t4) || isIterable(t4) && isTemporal(t4);
}
function bing(bx, by, data) {
  const EX = bx?.(data);
  const EY = by?.(data);
  return EX && EY ? function* (I4) {
    const X4 = EX.bin(I4);
    for (const [ix, [x12, x22]] of EX.entries()) {
      const Y4 = EY.bin(X4[ix]);
      for (const [iy, [y12, y22]] of EY.entries()) {
        yield [Y4[iy], { data, x1: x12, y1: y12, x2: x22, y2: y22 }];
      }
    }
  } : EX ? function* (I4) {
    const X4 = EX.bin(I4);
    for (const [i3, [x12, x22]] of EX.entries()) {
      yield [X4[i3], { data, x1: x12, x2: x22 }];
    }
  } : function* (I4) {
    const Y4 = EY.bin(I4);
    for (const [i3, [y12, y22]] of EY.entries()) {
      yield [Y4[i3], { data, y1: y12, y2: y22 }];
    }
  };
}
function bin1(E3, T4, V3) {
  T4 = coerceNumbers(T4);
  return (I4) => {
    const B5 = E3.map(() => []);
    for (const i3 of I4)
      B5[bisect_default(T4, V3[i3]) - 1]?.push(i3);
    return B5;
  };
}
function bin1cp(E3, T4, V3) {
  const bin = bin1(E3, T4, V3);
  return (I4) => {
    const B5 = bin(I4);
    for (let i3 = 1, n2 = B5.length; i3 < n2; ++i3) {
      const C4 = B5[i3 - 1];
      const b3 = B5[i3];
      for (const j4 of C4)
        b3.push(j4);
    }
    return B5;
  };
}
function bin1cn(E3, T4, V3) {
  const bin = bin1(E3, T4, V3);
  return (I4) => {
    const B5 = bin(I4);
    for (let i3 = B5.length - 2; i3 >= 0; --i3) {
      const C4 = B5[i3 + 1];
      const b3 = B5[i3];
      for (const j4 of C4)
        b3.push(j4);
    }
    return B5;
  };
}
function mid1(x12, x22) {
  const m3 = (+x12 + +x22) / 2;
  return x12 instanceof Date ? new Date(m3) : m3;
}
var reduceX = {
  reduceIndex(I4, X4, { x1: x12, x2: x22 }) {
    return mid1(x12, x22);
  }
};
var reduceY = {
  reduceIndex(I4, X4, { y1: y12, y2: y22 }) {
    return mid1(y12, y22);
  }
};
var reduceX1 = {
  reduceIndex(I4, X4, { x1: x12 }) {
    return x12;
  }
};
var reduceX2 = {
  reduceIndex(I4, X4, { x2: x22 }) {
    return x22;
  }
};
var reduceY1 = {
  reduceIndex(I4, X4, { y1: y12 }) {
    return y12;
  }
};
var reduceY2 = {
  reduceIndex(I4, X4, { y2: y22 }) {
    return y22;
  }
};

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/identity.js
function maybeIdentityY(options = {}) {
  return hasY(options) ? options : { ...options, y: identity6 };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js
function exclusiveFacets(data, facets) {
  if (facets.length === 1)
    return { data, facets };
  const n2 = data.length;
  const O3 = new Uint8Array(n2);
  let overlaps = 0;
  for (const facet of facets) {
    for (const i3 of facet) {
      if (O3[i3])
        ++overlaps;
      O3[i3] = 1;
    }
  }
  if (overlaps === 0)
    return { data, facets };
  data = slice2(data);
  const R2 = data[reindex] = new Uint32Array(n2 + overlaps);
  facets = facets.map((facet) => slice2(facet, Uint32Array));
  let j4 = n2;
  O3.fill(0);
  for (const facet of facets) {
    for (let k5 = 0, m3 = facet.length; k5 < m3; ++k5) {
      const i3 = facet[k5];
      if (O3[i3])
        facet[k5] = j4, data[j4] = data[i3], R2[j4] = i3, ++j4;
      else
        R2[i3] = i3;
      O3[i3] = 1;
    }
  }
  return { data, facets };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/transforms/stack.js
function stackY(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { x1: x12, x: x6 = x12, y: y4, ...rest } = options;
  const [transform2, X4, y12, y22] = stack(x6, y4, "x", "y", stackOptions, rest);
  return { ...transform2, x1: x12, x: X4, y1: y12, y2: y22, y: mid(y12, y22) };
}
function maybeStackY({ y: y4, y1: y12, y2: y22, ...options } = {}) {
  options = withTip(options, "x");
  if (y12 === void 0 && y22 === void 0)
    return stackY({ y: y4, ...options });
  [y12, y22] = maybeZero(y4, y12, y22);
  return { ...options, y1: y12, y2: y22 };
}
function mergeOptions2(options) {
  const { offset: offset2, order, reverse: reverse2, ...rest } = options;
  return [{ offset: offset2, order, reverse: reverse2 }, rest];
}
var lengthy = { length: true };
function stack(x6, y4 = one2, kx2, ky2, { offset: offset2, order, reverse: reverse2 }, options) {
  if (y4 === null)
    throw new Error(`stack requires ${ky2}`);
  const z4 = maybeZ(options);
  const [X4, setX] = maybeColumn(x6);
  const [Y12, setY1] = column(y4);
  const [Y23, setY2] = column(y4);
  Y12.hint = Y23.hint = lengthy;
  offset2 = maybeOffset(offset2);
  order = maybeOrder2(order, offset2, ky2);
  return [
    basic(options, (data, facets, plotOptions) => {
      ({ data, facets } = exclusiveFacets(data, facets));
      const X5 = x6 == null ? void 0 : setX(maybeApplyInterval(valueof(data, x6), plotOptions?.[kx2]));
      const Y4 = valueof(data, y4, Float64Array);
      const Z3 = valueof(data, z4);
      const compare2 = order && order(data, X5, Y4, Z3);
      const n2 = data.length;
      const Y13 = setY1(new Float64Array(n2));
      const Y24 = setY2(new Float64Array(n2));
      const facetstacks = [];
      for (const facet of facets) {
        const stacks = X5 ? Array.from(group(facet, (i3) => X5[i3]).values()) : [facet];
        if (compare2)
          for (const stack2 of stacks)
            stack2.sort(compare2);
        for (const stack2 of stacks) {
          let yn2 = 0;
          let yp = 0;
          if (reverse2)
            stack2.reverse();
          for (const i3 of stack2) {
            const y5 = Y4[i3];
            if (y5 < 0)
              yn2 = Y24[i3] = (Y13[i3] = yn2) + y5;
            else if (y5 > 0)
              yp = Y24[i3] = (Y13[i3] = yp) + y5;
            else
              Y24[i3] = Y13[i3] = yp;
          }
        }
        facetstacks.push(stacks);
      }
      if (offset2)
        offset2(facetstacks, Y13, Y24, Z3);
      return { data, facets };
    }),
    X4,
    Y12,
    Y23
  ];
}
function maybeOffset(offset2) {
  if (offset2 == null)
    return;
  if (typeof offset2 === "function")
    return offset2;
  switch (`${offset2}`.toLowerCase()) {
    case "expand":
    case "normalize":
      return offsetExpand;
    case "center":
    case "silhouette":
      return offsetCenter;
    case "wiggle":
      return offsetWiggle;
  }
  throw new Error(`unknown offset: ${offset2}`);
}
function extent2(stack2, Y23) {
  let min4 = 0, max3 = 0;
  for (const i3 of stack2) {
    const y4 = Y23[i3];
    if (y4 < min4)
      min4 = y4;
    if (y4 > max3)
      max3 = y4;
  }
  return [min4, max3];
}
function offsetExpand(facetstacks, Y12, Y23) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn2, yp] = extent2(stack2, Y23);
      for (const i3 of stack2) {
        const m3 = 1 / (yp - yn2 || 1);
        Y12[i3] = m3 * (Y12[i3] - yn2);
        Y23[i3] = m3 * (Y23[i3] - yn2);
      }
    }
  }
}
function offsetCenter(facetstacks, Y12, Y23) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn2, yp] = extent2(stack2, Y23);
      for (const i3 of stack2) {
        const m3 = (yp + yn2) / 2;
        Y12[i3] -= m3;
        Y23[i3] -= m3;
      }
    }
    offsetZero(stacks, Y12, Y23);
  }
  offsetCenterFacets(facetstacks, Y12, Y23);
}
function offsetWiggle(facetstacks, Y12, Y23, Z3) {
  for (const stacks of facetstacks) {
    const prev = new InternMap();
    let y4 = 0;
    for (const stack2 of stacks) {
      let j4 = -1;
      const Fi = stack2.map((i3) => Math.abs(Y23[i3] - Y12[i3]));
      const Df = stack2.map((i3) => {
        j4 = Z3 ? Z3[i3] : ++j4;
        const value = Y23[i3] - Y12[i3];
        const diff = prev.has(j4) ? value - prev.get(j4) : 0;
        prev.set(j4, value);
        return diff;
      });
      const Cf1 = [0, ...cumsum(Df)];
      for (const i3 of stack2) {
        Y12[i3] += y4;
        Y23[i3] += y4;
      }
      const s1 = sum(Fi);
      if (s1)
        y4 -= sum(Fi, (d3, i3) => (Df[i3] / 2 + Cf1[i3]) * d3) / s1;
    }
    offsetZero(stacks, Y12, Y23);
  }
  offsetCenterFacets(facetstacks, Y12, Y23);
}
function offsetZero(stacks, Y12, Y23) {
  const m3 = min(stacks, (stack2) => min(stack2, (i3) => Y12[i3]));
  for (const stack2 of stacks) {
    for (const i3 of stack2) {
      Y12[i3] -= m3;
      Y23[i3] -= m3;
    }
  }
}
function offsetCenterFacets(facetstacks, Y12, Y23) {
  const n2 = facetstacks.length;
  if (n2 === 1)
    return;
  const facets = facetstacks.map((stacks) => stacks.flat());
  const m3 = facets.map((I4) => (min(I4, (i3) => Y12[i3]) + max(I4, (i3) => Y23[i3])) / 2);
  const m0 = min(m3);
  for (let j4 = 0; j4 < n2; j4++) {
    const p4 = m0 - m3[j4];
    for (const i3 of facets[j4]) {
      Y12[i3] += p4;
      Y23[i3] += p4;
    }
  }
}
function maybeOrder2(order, offset2, ky2) {
  if (order === void 0 && offset2 === offsetWiggle)
    return orderInsideOut(ascendingDefined2);
  if (order == null)
    return;
  if (typeof order === "string") {
    const negate = order.startsWith("-");
    const compare2 = negate ? descendingDefined : ascendingDefined2;
    switch ((negate ? order.slice(1) : order).toLowerCase()) {
      case "value":
      case ky2:
        return orderY(compare2);
      case "z":
        return orderZ(compare2);
      case "sum":
        return orderSum(compare2);
      case "appearance":
        return orderAppearance(compare2);
      case "inside-out":
        return orderInsideOut(compare2);
    }
    return orderAccessor(field(order));
  }
  if (typeof order === "function")
    return (order.length === 1 ? orderAccessor : orderComparator)(order);
  if (Array.isArray(order))
    return orderGiven(order);
  throw new Error(`invalid order: ${order}`);
}
function orderY(compare2) {
  return (data, X4, Y4) => (i3, j4) => compare2(Y4[i3], Y4[j4]);
}
function orderZ(compare2) {
  return (data, X4, Y4, Z3) => (i3, j4) => compare2(Z3[i3], Z3[j4]);
}
function orderSum(compare2) {
  return orderZDomain(
    compare2,
    (data, X4, Y4, Z3) => groupSort(
      range2(data),
      (I4) => sum(I4, (i3) => Y4[i3]),
      (i3) => Z3[i3]
    )
  );
}
function orderAppearance(compare2) {
  return orderZDomain(
    compare2,
    (data, X4, Y4, Z3) => groupSort(
      range2(data),
      (I4) => X4[greatest(I4, (i3) => Y4[i3])],
      (i3) => Z3[i3]
    )
  );
}
function orderInsideOut(compare2) {
  return orderZDomain(compare2, (data, X4, Y4, Z3) => {
    const I4 = range2(data);
    const K5 = groupSort(
      I4,
      (I5) => X4[greatest(I5, (i3) => Y4[i3])],
      (i3) => Z3[i3]
    );
    const sums = rollup(
      I4,
      (I5) => sum(I5, (i3) => Y4[i3]),
      (i3) => Z3[i3]
    );
    const Kp = [], Kn = [];
    let s4 = 0;
    for (const k5 of K5) {
      if (s4 < 0) {
        s4 += sums.get(k5);
        Kp.push(k5);
      } else {
        s4 -= sums.get(k5);
        Kn.push(k5);
      }
    }
    return Kn.reverse().concat(Kp);
  });
}
function orderAccessor(f3) {
  return (data) => {
    const O3 = valueof(data, f3);
    return (i3, j4) => ascendingDefined2(O3[i3], O3[j4]);
  };
}
function orderComparator(f3) {
  return (data) => (i3, j4) => f3(data[i3], data[j4]);
}
function orderGiven(domain) {
  return orderZDomain(ascendingDefined2, () => domain);
}
function orderZDomain(compare2, domain) {
  return (data, X4, Y4, Z3) => {
    if (!Z3)
      throw new Error("missing channel: z");
    const map4 = new InternMap(domain(data, X4, Y4, Z3).map((d3, i3) => [d3, i3]));
    return (i3, j4) => compare2(map4.get(Z3[i3]), map4.get(Z3[j4]));
  };
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/area.js
var defaults6 = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Area = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2: x22, y2: y22, z: z4, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        y1: { value: y12, scale: "y" },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults6
    );
    this.z = z4;
    this.curve = maybeCurve(curve, tension);
  }
  filter(index2) {
    return index2;
  }
  render(index2, scales, channels, dimensions, context) {
    const { x1: X12, y1: Y12, x2: X23 = X12, y2: Y23 = Y12 } = channels;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
      (g4) => g4.selectAll().data(groupIndex(index2, [X12, Y12, X23, Y23], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
        "d",
        area_default2().curve(this.curve).defined((i3) => i3 >= 0).x0((i3) => X12[i3]).y0((i3) => Y12[i3]).x1((i3) => X23[i3]).y1((i3) => Y23[i3])
      )
    ).node();
  }
};
function areaY(data, options) {
  const { x: x6 = indexOf, ...rest } = maybeDenseIntervalX(options);
  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x6, x2: void 0 })));
}

// node_modules/.pnpm/@observablehq+plot@0.6.14/node_modules/@observablehq/plot/src/marks/line.js
var defaults7 = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Line = class extends Mark {
  constructor(data, options = {}) {
    const { x: x6, y: y4, z: z4, curve, tension } = options;
    super(
      data,
      {
        x: { value: x6, scale: "x" },
        y: { value: y4, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults7
    );
    this.z = z4;
    this.curve = maybeCurveAuto(curve, tension);
    markers(this, options);
  }
  filter(index2) {
    return index2;
  }
  project(channels, values2, context) {
    if (this.curve !== curveAuto) {
      super.project(channels, values2, context);
    }
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: X4, y: Y4 } = channels;
    const { curve } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g4) => g4.selectAll().data(groupIndex(index2, [X4, Y4], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
        "d",
        curve === curveAuto && context.projection ? sphereLine(context.projection, X4, Y4) : line_default2().curve(curve).defined((i3) => i3 >= 0).x((i3) => X4[i3]).y((i3) => Y4[i3])
      )
    ).node();
  }
};
function sphereLine(projection3, X4, Y4) {
  const path2 = path_default(projection3);
  X4 = coerceNumbers(X4);
  Y4 = coerceNumbers(Y4);
  return (I4) => {
    let line2 = [];
    const lines = [line2];
    for (const i3 of I4) {
      if (i3 === -1) {
        line2 = [];
        lines.push(line2);
      } else {
        line2.push([X4[i3], Y4[i3]]);
      }
    }
    return path2({ type: "MultiLineString", coordinates: lines });
  };
}
function lineY(data, { x: x6 = indexOf, y: y4 = identity6, ...options } = {}) {
  return new Line(data, maybeDenseIntervalX({ ...options, x: x6, y: y4 }));
}

// src/Histogram.tsx
init_preact_module();
init_hooks_module();
var before = new Date(2023, 11, 11, 0, 0, 0);
function Histogram({}) {
  const containerRef = _2(null);
  const [goog, setGoog] = p3();
  const [aapl, setAapl] = p3();
  h2(() => {
    csv2("assets/data/goog.csv", autoType).then((d3) => {
      setGoog(d3);
    });
    csv2("assets/data/aapl.csv", autoType).then((d3) => {
      setAapl(d3);
    });
  }, []);
  h2(() => {
    if (goog === void 0)
      return;
    if (aapl === void 0)
      return;
    if (containerRef.current === null)
      return;
    const plot2 = plot({
      style: "width: 100%;",
      grid: true,
      height: 300,
      x: { label: "Fecha " },
      y: { label: "Precio (ARS)" },
      marks: [
        lineY(goog, { x: "Date", y: "Close", stroke: "red" }),
        lineY(aapl, { x: "Date", y: "Close", stroke: "blue" })
      ]
    });
    containerRef.current.append(plot2);
    return () => plot2.remove();
  }, [goog, aapl]);
  return /* @__PURE__ */ h("div", { ref: containerRef });
}
function Normalized({}) {
  const containerRef = _2(null);
  const [riaa, setRiaa] = p3();
  h2(() => {
    csv2("assets/data/riaa-us-revenue.csv", autoType).then((d3) => {
      setRiaa(d3);
    });
  }, []);
  h2(() => {
    if (riaa === void 0)
      return;
    if (containerRef.current === null)
      return;
    console.log(riaa);
    const plot2 = plot({
      y: {
        label: "\u2191 Annual revenue (%)",
        percent: true
      },
      marks: [
        areaY(riaa, stackY({ offset: "normalize", order: "group", reverse: true }, { x: "year", y: "revenue", z: "format", fill: "group" })),
        ruleY([0, 1])
      ]
    });
    containerRef.current.append(plot2);
    return () => plot2.remove();
  }, [riaa]);
  return /* @__PURE__ */ h("div", { ref: containerRef });
}

// src/Home.tsx
function Home() {
  return /* @__PURE__ */ h("div", null, /* @__PURE__ */ h("header", { class: "py-10 bg-gray-800 " }, /* @__PURE__ */ h(EnConstruccion, null), /* @__PURE__ */ h(Deuda, null)), /* @__PURE__ */ h("div", { class: "mx-auto max-w-2xl px-4 pb-12 sm:px-6 lg:px-8" }, /* @__PURE__ */ h("div", { class: "rounded-lg bg-white px-5 py-6 shadow sm:px-6" }, /* @__PURE__ */ h("div", { class: "px-4 py-6 sm:px-6" }, /* @__PURE__ */ h("h3", { class: "text-base font-semibold leading-7 text-gray-900" }, "Crecimiento de la deuda"), /* @__PURE__ */ h("p", { class: "mt-1 max-w-2xl text-sm leading-6 text-gray-500" }, "Descripcion del grafico")), /* @__PURE__ */ h(Histogram, null))), /* @__PURE__ */ h("div", { class: "mx-auto max-w-2xl px-4 pb-12 sm:px-6 lg:px-8" }, /* @__PURE__ */ h("div", { class: "rounded-lg bg-white px-5 py-6 shadow sm:px-6" }, /* @__PURE__ */ h("div", { class: "px-4 py-6 sm:px-6" }, /* @__PURE__ */ h("h3", { class: "text-base font-semibold leading-7 text-gray-900" }, "Asignacion presupuestaria"), /* @__PURE__ */ h("p", { class: "mt-1 max-w-2xl text-sm leading-6 text-gray-500" }, "Descripcion del grafico")), /* @__PURE__ */ h(Normalized, null))));
}
function EnConstruccion() {
  return /* @__PURE__ */ h("div", { class: "rounded-md bg-yellow-50 p-4 mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 mb-4" }, /* @__PURE__ */ h("div", { class: "flex" }, /* @__PURE__ */ h("div", { class: "flex-shrink-0" }, /* @__PURE__ */ h(
    "svg",
    {
      class: "h-5 w-5 text-yellow-400",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true"
    },
    /* @__PURE__ */ h(
      "path",
      {
        "fill-rule": "evenodd",
        d: "M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z",
        "clip-rule": "evenodd"
      }
    )
  )), /* @__PURE__ */ h("div", { class: "ml-3" }, /* @__PURE__ */ h("h3", { class: "text-sm font-medium text-yellow-800" }, "Sitio en construcci\xF3n"), /* @__PURE__ */ h("div", { class: "mt-2 text-sm text-yellow-700" }, /* @__PURE__ */ h("p", null, "Los datos no son reales.")))));
}
function Deuda() {
  return /* @__PURE__ */ h("div", { class: "mx-auto max-w-7xl px-4 sm:px-6 lg:px-8" }, /* @__PURE__ */ h("div", { class: "flex justify-between" }, /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "Deuda Nacional"), /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "US $ 370.673.000.000,00")), /* @__PURE__ */ h("div", { class: "flex justify-between" }, /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "Deuda por persona"), /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "US $ 8.620,30")), /* @__PURE__ */ h("div", { class: "flex justify-between" }, /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "Producto bruto interno"), /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "US $ 640.591.000.000,00")), /* @__PURE__ */ h("div", { class: "flex justify-between" }, /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "Produccion por persona"), /* @__PURE__ */ h("div", { class: "text-3xl font-bold tracking-tight text-white" }, "US $ 14.897,46")));
}

// src/utils.ts
init_hooks_module();

// src/codec.ts
var DecodingError2 = class _DecodingError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _DecodingError.prototype);
    this.name = "DecodingError";
  }
};
function renderContext2(c6) {
  const p4 = c6?.path;
  if (p4) {
    return p4.join(".");
  } else {
    return "(unknown)";
  }
}
function joinContext2(c6, part) {
  const path2 = c6?.path ?? [];
  return {
    path: path2.concat([part])
  };
}
var ObjectCodecBuilder2 = class {
  constructor() {
    this.propList = [];
  }
  /**
   * Define a property for the object.
   */
  property(x6, codec) {
    if (!codec) {
      throw Error("inner codec must be defined");
    }
    this.propList.push({ name: x6, codec });
    return this;
  }
  /**
   * Return the built codec.
   *
   * @param objectDisplayName name of the object that this codec operates on,
   *   used in error messages.
   */
  build(objectDisplayName) {
    const propList = this.propList;
    return {
      decode(x6, c6) {
        if (!c6) {
          c6 = {
            path: [`(${objectDisplayName})`]
          };
        }
        if (typeof x6 !== "object") {
          throw new DecodingError2(
            `expected object for ${objectDisplayName} at ${renderContext2(
              c6
            )} but got ${typeof x6}`
          );
        }
        const obj = {};
        for (const prop of propList) {
          const propRawVal = x6[prop.name];
          const propVal = prop.codec.decode(
            propRawVal,
            joinContext2(c6, prop.name)
          );
          obj[prop.name] = propVal;
        }
        return obj;
      }
    };
  }
};
function buildCodecForObject2() {
  return new ObjectCodecBuilder2();
}
function codecForMap2(innerCodec) {
  if (!innerCodec) {
    throw Error("inner codec must be defined");
  }
  return {
    decode(x6, c6) {
      const map4 = {};
      if (typeof x6 !== "object") {
        throw new DecodingError2(`expected object at ${renderContext2(c6)}`);
      }
      for (const i3 in x6) {
        map4[i3] = innerCodec.decode(x6[i3], joinContext2(c6, `[${i3}]`));
      }
      return map4;
    }
  };
}
function codecForNumber2() {
  return {
    decode(x6, c6) {
      if (typeof x6 === "number") {
        return x6;
      }
      throw new DecodingError2(
        `expected number at ${renderContext2(c6)} but got ${typeof x6}`
      );
    }
  };
}
function codecForBoolean2() {
  return {
    decode(x6, c6) {
      if (typeof x6 === "boolean") {
        return x6;
      }
      throw new DecodingError2(
        `expected boolean at ${renderContext2(c6)} but got ${typeof x6}`
      );
    }
  };
}
function codecForString2() {
  return {
    decode(x6, c6) {
      if (typeof x6 === "string") {
        return x6;
      }
      throw new DecodingError2(
        `expected string at ${renderContext2(c6)} but got ${typeof x6}`
      );
    }
  };
}
function codecOptional2(innerCodec) {
  return {
    decode(x6, c6) {
      if (x6 === void 0 || x6 === null) {
        return void 0;
      }
      return innerCodec.decode(x6, c6);
    }
  };
}
function codecForEither2(...alts) {
  return {
    decode(x6, c6) {
      for (const alt of alts) {
        try {
          return alt.decode(x6, c6);
        } catch (e3) {
          continue;
        }
      }
      throw new DecodingError2(
        `No alternative matched at at ${renderContext2(c6)}`
      );
    }
  };
}
var x5 = codecForEither2(codecForString2(), codecForNumber2());

// src/time.ts
var opaque_AbsoluteTime2 = Symbol("opaque_AbsoluteTime");
var TalerPreciseTimestamp2;
((TalerPreciseTimestamp3) => {
  function now2() {
    const absNow = AbsoluteTime2.now();
    return AbsoluteTime2.toPreciseTimestamp(absNow);
  }
  TalerPreciseTimestamp3.now = now2;
  function round(t4) {
    return {
      t_s: t4.t_s
    };
  }
  TalerPreciseTimestamp3.round = round;
  function fromSeconds(s4) {
    return {
      t_s: Math.floor(s4),
      off_us: Math.floor((s4 - Math.floor(s4)) / 1e3 / 1e3)
    };
  }
  TalerPreciseTimestamp3.fromSeconds = fromSeconds;
  function fromMilliseconds(ms) {
    return {
      t_s: Math.floor(ms / 1e3),
      off_us: Math.floor((ms - Math.floor(ms / 1e3) * 1e3) * 1e3)
    };
  }
  TalerPreciseTimestamp3.fromMilliseconds = fromMilliseconds;
})(TalerPreciseTimestamp2 || (TalerPreciseTimestamp2 = {}));
var TalerProtocolTimestamp2;
((TalerProtocolTimestamp3) => {
  function now2() {
    return AbsoluteTime2.toProtocolTimestamp(AbsoluteTime2.now());
  }
  TalerProtocolTimestamp3.now = now2;
  function zero3() {
    return {
      t_s: 0
    };
  }
  TalerProtocolTimestamp3.zero = zero3;
  function never() {
    return {
      t_s: "never"
    };
  }
  TalerProtocolTimestamp3.never = never;
  function isNever(t4) {
    return t4.t_s === "never";
  }
  TalerProtocolTimestamp3.isNever = isNever;
  function fromSeconds(s4) {
    return {
      t_s: s4
    };
  }
  TalerProtocolTimestamp3.fromSeconds = fromSeconds;
  function min4(t13, t23) {
    if (t13.t_s === "never") {
      return { t_s: t23.t_s };
    }
    if (t23.t_s === "never") {
      return { t_s: t13.t_s };
    }
    return { t_s: Math.min(t13.t_s, t23.t_s) };
  }
  TalerProtocolTimestamp3.min = min4;
  function max3(t13, t23) {
    if (t13.t_s === "never" || t23.t_s === "never") {
      return { t_s: "never" };
    }
    return { t_s: Math.max(t13.t_s, t23.t_s) };
  }
  TalerProtocolTimestamp3.max = max3;
})(TalerProtocolTimestamp2 || (TalerProtocolTimestamp2 = {}));
var timeshift2 = 0;
var Duration2;
((Duration3) => {
  function toMilliseconds(d3) {
    if (d3.d_ms === "forever") {
      return Number.MAX_VALUE;
    }
    return d3.d_ms;
  }
  Duration3.toMilliseconds = toMilliseconds;
  function getRemaining(deadline, now2 = AbsoluteTime2.now()) {
    if (deadline.t_ms === "never") {
      return { d_ms: "forever" };
    }
    if (now2.t_ms === "never") {
      throw Error("invalid argument for 'now'");
    }
    if (deadline.t_ms < now2.t_ms) {
      return { d_ms: 0 };
    }
    return { d_ms: deadline.t_ms - now2.t_ms };
  }
  Duration3.getRemaining = getRemaining;
  function fromPrettyString(s4) {
    let dMs = 0;
    let currentNum = "";
    let parsingNum = true;
    for (let i3 = 0; i3 < s4.length; i3++) {
      const cc = s4.charCodeAt(i3);
      if (cc >= "0".charCodeAt(0) && cc <= "9".charCodeAt(0)) {
        if (!parsingNum) {
          throw Error("invalid duration, unexpected number");
        }
        currentNum += s4[i3];
        continue;
      }
      if (s4[i3] == " ") {
        if (currentNum != "") {
          parsingNum = false;
        }
        continue;
      }
      if (currentNum == "") {
        throw Error("invalid duration, missing number");
      }
      if (s4[i3] === "s") {
        dMs += 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "m") {
        dMs += 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "h") {
        dMs += 60 * 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else if (s4[i3] === "d") {
        dMs += 24 * 60 * 60 * 1e3 * Number.parseInt(currentNum, 10);
      } else {
        throw Error("invalid duration, unsupported unit");
      }
      currentNum = "";
      parsingNum = true;
    }
    return {
      d_ms: dMs
    };
  }
  Duration3.fromPrettyString = fromPrettyString;
  function cmp(d1, d22) {
    if (d1.d_ms === "forever") {
      if (d22.d_ms === "forever") {
        return 0;
      }
      return 1;
    }
    if (d22.d_ms === "forever") {
      return -1;
    }
    if (d1.d_ms == d22.d_ms) {
      return 0;
    }
    if (d1.d_ms > d22.d_ms) {
      return 1;
    }
    return -1;
  }
  Duration3.cmp = cmp;
  function max3(d1, d22) {
    return durationMax2(d1, d22);
  }
  Duration3.max = max3;
  function min4(d1, d22) {
    return durationMin2(d1, d22);
  }
  Duration3.min = min4;
  function multiply(d1, n2) {
    return durationMul2(d1, n2);
  }
  Duration3.multiply = multiply;
  function toIntegerYears(d3) {
    if (typeof d3.d_ms !== "number") {
      throw Error("infinite duration");
    }
    return Math.ceil(d3.d_ms / 1e3 / 60 / 60 / 24 / 365);
  }
  Duration3.toIntegerYears = toIntegerYears;
  function fromSpec(spec) {
    let d_ms = 0;
    d_ms += (spec.seconds ?? 0) * SECONDS2;
    d_ms += (spec.minutes ?? 0) * MINUTES2;
    d_ms += (spec.hours ?? 0) * HOURS2;
    d_ms += (spec.days ?? 0) * DAYS2;
    d_ms += (spec.months ?? 0) * MONTHS2;
    d_ms += (spec.years ?? 0) * YEARS2;
    return { d_ms };
  }
  Duration3.fromSpec = fromSpec;
  function getForever() {
    return { d_ms: "forever" };
  }
  Duration3.getForever = getForever;
  function getZero() {
    return { d_ms: 0 };
  }
  Duration3.getZero = getZero;
  function fromTalerProtocolDuration(d3) {
    if (d3.d_us === "forever") {
      return {
        d_ms: "forever"
      };
    }
    return {
      d_ms: Math.floor(d3.d_us / 1e3)
    };
  }
  Duration3.fromTalerProtocolDuration = fromTalerProtocolDuration;
  function toTalerProtocolDuration(d3) {
    if (d3.d_ms === "forever") {
      return {
        d_us: "forever"
      };
    }
    return {
      d_us: d3.d_ms * 1e3
    };
  }
  Duration3.toTalerProtocolDuration = toTalerProtocolDuration;
  function fromMilliseconds(ms) {
    return {
      d_ms: ms
    };
  }
  Duration3.fromMilliseconds = fromMilliseconds;
  function clamp(args) {
    return durationMax2(durationMin2(args.value, args.upper), args.lower);
  }
  Duration3.clamp = clamp;
})(Duration2 || (Duration2 = {}));
var AbsoluteTime2;
((AbsoluteTime3) => {
  function getStampMsNow() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  AbsoluteTime3.getStampMsNow = getStampMsNow;
  function getStampMsNever() {
    return Number.MAX_SAFE_INTEGER;
  }
  AbsoluteTime3.getStampMsNever = getStampMsNever;
  function now2() {
    return {
      t_ms: (/* @__PURE__ */ new Date()).getTime() + timeshift2,
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.now = now2;
  function never() {
    return {
      t_ms: "never",
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.never = never;
  function fromMilliseconds(ms) {
    return {
      t_ms: ms,
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.fromMilliseconds = fromMilliseconds;
  function cmp(t13, t23) {
    if (t13.t_ms === "never") {
      if (t23.t_ms === "never") {
        return 0;
      }
      return 1;
    }
    if (t23.t_ms === "never") {
      return -1;
    }
    if (t13.t_ms == t23.t_ms) {
      return 0;
    }
    if (t13.t_ms > t23.t_ms) {
      return 1;
    }
    return -1;
  }
  AbsoluteTime3.cmp = cmp;
  function min4(t13, t23) {
    if (t13.t_ms === "never") {
      return { t_ms: t23.t_ms, [opaque_AbsoluteTime2]: true };
    }
    if (t23.t_ms === "never") {
      return { t_ms: t23.t_ms, [opaque_AbsoluteTime2]: true };
    }
    return { t_ms: Math.min(t13.t_ms, t23.t_ms), [opaque_AbsoluteTime2]: true };
  }
  AbsoluteTime3.min = min4;
  function max3(t13, t23) {
    if (t13.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    if (t23.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    return { t_ms: Math.max(t13.t_ms, t23.t_ms), [opaque_AbsoluteTime2]: true };
  }
  AbsoluteTime3.max = max3;
  function difference2(t13, t23) {
    if (t13.t_ms === "never") {
      return { d_ms: "forever" };
    }
    if (t23.t_ms === "never") {
      return { d_ms: "forever" };
    }
    return { d_ms: Math.abs(t13.t_ms - t23.t_ms) };
  }
  AbsoluteTime3.difference = difference2;
  function isExpired(t4) {
    return cmp(t4, now2()) <= 0;
  }
  AbsoluteTime3.isExpired = isExpired;
  function isNever(t4) {
    return t4.t_ms === "never";
  }
  AbsoluteTime3.isNever = isNever;
  function fromProtocolTimestamp(t4) {
    if (t4.t_s === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    return {
      t_ms: t4.t_s * 1e3,
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.fromProtocolTimestamp = fromProtocolTimestamp;
  function fromStampMs(stampMs) {
    return {
      t_ms: stampMs,
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.fromStampMs = fromStampMs;
  function fromPreciseTimestamp(t4) {
    if (t4.t_s === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    const offsetUs = t4.off_us ?? 0;
    return {
      t_ms: t4.t_s * 1e3 + Math.floor(offsetUs / 1e3),
      [opaque_AbsoluteTime2]: true
    };
  }
  AbsoluteTime3.fromPreciseTimestamp = fromPreciseTimestamp;
  function toStampMs(at2) {
    if (at2.t_ms === "never") {
      return Number.MAX_SAFE_INTEGER;
    }
    return at2.t_ms;
  }
  AbsoluteTime3.toStampMs = toStampMs;
  function toPreciseTimestamp(at2) {
    if (at2.t_ms == "never") {
      return {
        t_s: "never"
      };
    }
    const t_s = Math.floor(at2.t_ms / 1e3);
    const off_us = Math.floor(1e3 * (at2.t_ms - t_s * 1e3));
    return {
      t_s,
      off_us
    };
  }
  AbsoluteTime3.toPreciseTimestamp = toPreciseTimestamp;
  function toProtocolTimestamp(at2) {
    if (at2.t_ms === "never") {
      return { t_s: "never" };
    }
    return {
      t_s: Math.floor(at2.t_ms / 1e3)
    };
  }
  AbsoluteTime3.toProtocolTimestamp = toProtocolTimestamp;
  function isBetween(t4, start2, end) {
    if (cmp(t4, start2) < 0) {
      return false;
    }
    if (cmp(t4, end) > 0) {
      return false;
    }
    return true;
  }
  AbsoluteTime3.isBetween = isBetween;
  function toIsoString(t4) {
    if (t4.t_ms === "never") {
      return "<never>";
    } else {
      return new Date(t4.t_ms).toISOString();
    }
  }
  AbsoluteTime3.toIsoString = toIsoString;
  function addDuration(t13, d3) {
    if (t13.t_ms === "never" || d3.d_ms === "forever") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    return { t_ms: t13.t_ms + d3.d_ms, [opaque_AbsoluteTime2]: true };
  }
  AbsoluteTime3.addDuration = addDuration;
  function remaining(t13) {
    if (t13.t_ms === "never") {
      return Duration2.getForever();
    }
    const stampNow = now2();
    if (stampNow.t_ms === "never") {
      throw Error("invariant violated");
    }
    return Duration2.fromMilliseconds(Math.max(0, t13.t_ms - stampNow.t_ms));
  }
  AbsoluteTime3.remaining = remaining;
  function subtractDuraction(t13, d3) {
    if (t13.t_ms === "never") {
      return { t_ms: "never", [opaque_AbsoluteTime2]: true };
    }
    if (d3.d_ms === "forever") {
      return { t_ms: 0, [opaque_AbsoluteTime2]: true };
    }
    return { t_ms: Math.max(0, t13.t_ms - d3.d_ms), [opaque_AbsoluteTime2]: true };
  }
  AbsoluteTime3.subtractDuraction = subtractDuraction;
  function stringify(t4) {
    if (t4.t_ms === "never") {
      return "never";
    }
    return new Date(t4.t_ms).toISOString();
  }
  AbsoluteTime3.stringify = stringify;
})(AbsoluteTime2 || (AbsoluteTime2 = {}));
var SECONDS2 = 1e3;
var MINUTES2 = SECONDS2 * 60;
var HOURS2 = MINUTES2 * 60;
var DAYS2 = HOURS2 * 24;
var MONTHS2 = DAYS2 * 30;
var YEARS2 = DAYS2 * 365;
function durationMin2(d1, d22) {
  if (d1.d_ms === "forever") {
    return { d_ms: d22.d_ms };
  }
  if (d22.d_ms === "forever") {
    return { d_ms: d1.d_ms };
  }
  return { d_ms: Math.min(d1.d_ms, d22.d_ms) };
}
function durationMax2(d1, d22) {
  if (d1.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  if (d22.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  return { d_ms: Math.max(d1.d_ms, d22.d_ms) };
}
function durationMul2(d3, n2) {
  if (d3.d_ms === "forever") {
    return { d_ms: "forever" };
  }
  return { d_ms: Math.round(d3.d_ms * n2) };
}

// src/utils.ts
function assertUnreachable2(x6) {
  throw new Error("Didn't expect to get here");
}
function canonicalizeBaseUrl2(url) {
  if (!url.startsWith("http") && !url.startsWith("https")) {
    url = "https://" + url;
  }
  const x6 = new URL(url);
  if (!x6.pathname.endsWith("/")) {
    x6.pathname = x6.pathname + "/";
  }
  x6.search = "";
  x6.hash = "";
  return x6.href;
}
var PAGINATED_LIST_SIZE = 5;
var PAGINATED_LIST_REQUEST = PAGINATED_LIST_SIZE + 1;

// src/Routing.tsx
function AppFrame({ children: children2 }) {
  return /* @__PURE__ */ h("div", { class: "min-h-full" }, /* @__PURE__ */ h("div", { class: "bg-gray-800" }, /* @__PURE__ */ h("nav", { class: "bg-gray-800" }, /* @__PURE__ */ h("div", { class: "mx-auto max-w-7xl sm:px-6 lg:px-8" }, /* @__PURE__ */ h("div", { class: "border-b border-gray-700" }, /* @__PURE__ */ h("div", { class: "flex h-16 items-center justify-between px-4 sm:px-0" }, /* @__PURE__ */ h("div", { class: "flex items-center" }, /* @__PURE__ */ h("div", { class: "flex-shrink-0" }, /* @__PURE__ */ h(
    "img",
    {
      class: "h-8 w-8",
      src: "assets/icons/isotipo.png",
      alt: "Your Company"
    }
  )), /* @__PURE__ */ h("div", { class: "md:block" }, /* @__PURE__ */ h("div", { class: "ml-10 flex items-baseline space-x-4" }, /* @__PURE__ */ h(
    "a",
    {
      href: "#",
      class: "bg-gray-900 text-white rounded-md px-3 py-2 text-sm font-medium",
      "aria-current": "page"
    },
    "Deuda publica"
  ), /* @__PURE__ */ h(
    "a",
    {
      href: "#",
      class: "text-gray-300 hover:bg-gray-700 hover:text-white rounded-md px-3 py-2 text-sm font-medium"
    },
    "Equipo"
  )))), /* @__PURE__ */ h("div", { class: "md:block" }, /* @__PURE__ */ h("div", { class: "ml-4 flex items-center md:ml-6" }, /* @__PURE__ */ h(
    "button",
    {
      type: "button",
      class: "relative rounded-full bg-gray-800 p-1 text-gray-400 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800"
    },
    /* @__PURE__ */ h("span", { class: "absolute -inset-1.5" }),
    /* @__PURE__ */ h("span", { class: "sr-only" }, "View notifications"),
    /* @__PURE__ */ h(
      "svg",
      {
        class: "h-6 w-6",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
      },
      /* @__PURE__ */ h(
        "path",
        {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M14.857 17.082a23.848 23.848 0 005.454-1.31A8.967 8.967 0 0118 9.75v-.7V9A6 6 0 006 9v.75a8.967 8.967 0 01-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 01-5.714 0m5.714 0a3 3 0 11-5.714 0"
        }
      )
    )
  ), /* @__PURE__ */ h("div", { class: "relative ml-3" }))), /* @__PURE__ */ h("div", { class: "-mr-2 flex md:hidden" }, /* @__PURE__ */ h(
    "button",
    {
      type: "button",
      class: "relative inline-flex items-center justify-center rounded-md bg-gray-800 p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800",
      "aria-controls": "mobile-menu",
      "aria-expanded": "false"
    },
    /* @__PURE__ */ h("span", { class: "absolute -inset-0.5" }),
    /* @__PURE__ */ h("span", { class: "sr-only" }, "Open main menu"),
    /* @__PURE__ */ h(
      "svg",
      {
        class: "block h-6 w-6",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
      },
      /* @__PURE__ */ h(
        "path",
        {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
        }
      )
    ),
    /* @__PURE__ */ h(
      "svg",
      {
        class: "hidden h-6 w-6",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
      },
      /* @__PURE__ */ h(
        "path",
        {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M6 18L18 6M6 6l12 12"
        }
      )
    )
  ))))), /* @__PURE__ */ h("div", { class: "border-b border-gray-700 md:hidden", id: "mobile-menu" }, /* @__PURE__ */ h("div", { class: "space-y-1 px-2 py-3 sm:px-3" }), /* @__PURE__ */ h("div", { class: "border-t border-gray-700 pb-3 pt-4" }, /* @__PURE__ */ h("div", { class: "flex items-center px-5" }, /* @__PURE__ */ h("div", { class: "ml-3" }), /* @__PURE__ */ h(
    "button",
    {
      type: "button",
      class: "relative ml-auto flex-shrink-0 rounded-full bg-gray-800 p-1 text-gray-400 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800"
    },
    /* @__PURE__ */ h("span", { class: "absolute -inset-1.5" }),
    /* @__PURE__ */ h("span", { class: "sr-only" }, "View notifications"),
    /* @__PURE__ */ h(
      "svg",
      {
        class: "h-6 w-6",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
      },
      /* @__PURE__ */ h(
        "path",
        {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M14.857 17.082a23.848 23.848 0 005.454-1.31A8.967 8.967 0 0118 9.75v-.7V9A6 6 0 006 9v.75a8.967 8.967 0 01-2.312 6.022c1.733.64 3.56 1.085 5.455 1.31m5.714 0a24.255 24.255 0 01-5.714 0m5.714 0a3 3 0 11-5.714 0"
        }
      )
    )
  )), /* @__PURE__ */ h("div", { class: "mt-3 space-y-1 px-2" }))))), /* @__PURE__ */ h("main", null, children2));
}
function Routing() {
  return /* @__PURE__ */ h(AppFrame, null, /* @__PURE__ */ h(PublicRounting, { onLoggedUser: (username, token) => {
  } }));
}
var publicPages = {
  home: urlPattern(/\/home/, () => "#/home")
};
function PublicRounting({
  onLoggedUser
}) {
  const { i18n: i18n2 } = useTranslationContext();
  const location2 = useCurrentLocation(publicPages);
  const { navigateTo } = useNavigationContext();
  h2(() => {
    if (location2 === void 0) {
      navigateTo(publicPages.home.url({}));
    }
  }, [location2]);
  if (location2 === void 0) {
    return /* @__PURE__ */ h(p2, null);
  }
  switch (location2.name) {
    case void 0:
    case "home": {
      return /* @__PURE__ */ h(Home, null);
    }
    default:
      assertUnreachable2(location2);
  }
}

// src/context/settings.ts
init_preact_module();
init_hooks_module();
var initial2 = {};
var Context6 = B(initial2);
var SettingsProvider = ({
  children: children2,
  value
}) => {
  return h(Context6.Provider, {
    value,
    children: children2
  });
};

// src/i18n/strings.ts
var strings = {};
strings["it"] = {
  locale_data: {
    messages: {
      "": {
        domain: "messages",
        plural_forms: "nplurals=2; plural=n != 1;",
        lang: "it"
      },
      "Operation failed, please report": ["Registrazione"],
      "Request timeout": [""],
      "Request throttled": [""],
      "Malformed response": [""],
      "Network error": [""],
      "Unexpected request error": [""],
      "Unexpected error": [""],
      "IBAN numbers usually have more that 4 digits": [""],
      "IBAN numbers usually have less that 34 digits": [""],
      "IBAN country code not found": [""],
      "IBAN number is not valid, checksum is wrong": [""],
      "Max withdrawal amount": ["Questo ritiro \xE8 stato annullato!"],
      "Show withdrawal confirmation": ["Questo ritiro \xE8 stato annullato!"],
      "Show demo description": [""],
      "Show install wallet first": [""],
      "Use fast withdrawal form": ["Ritira contante"],
      "Show debug info": [""],
      "The reserve operation has been confirmed previously and can't be aborted": [""],
      "The operation id is invalid.": [""],
      "The operation was not found.": ["Lista conti pubblici non trovata."],
      "If you have a Taler wallet installed in this device": [""],
      "You will see the details of the operation in your wallet including the fees (if applies). If you still don't have one you can install it following instructions in": [""],
      "this page": [""],
      Withdraw: ["Prelevare"],
      "Or if you have the wallet in another device": [""],
      "Scan the QR below to start the withdrawal.": ["Chiudi il ritiro Taler"],
      required: [""],
      "IBAN should have just uppercased letters and numbers": [""],
      "not valid": [""],
      "should be greater than 0": [""],
      "balance is not enough": [""],
      "does not follow the pattern": [""],
      'only "IBAN" target are supported': [""],
      'use the "amount" parameter to specify the amount to be transferred': [
        ""
      ],
      "the amount is not valid": [""],
      'use the "message" parameter to specify a reference text for the transfer': [""],
      "The request was invalid or the payto://-URI used unacceptable features.": [""],
      "Not enough permission to complete the operation.": [
        "La banca sta creando l'operazione..."
      ],
      'The destination account "%1$s" was not found.': [
        "Lista conti pubblici non trovata."
      ],
      "The origin and the destination of the transfer can't be the same.": [""],
      "Your balance is not enough.": [""],
      'The origin account "%1$s" was not found.': [
        "Lista conti pubblici non trovata."
      ],
      "Using a form": [""],
      "Import payto:// URI": [""],
      Recipient: [""],
      "IBAN of the recipient's account": [""],
      "Transfer subject": [
        "Trasferisci fondi a un altro conto di questa banca:"
      ],
      subject: ["Soggetto"],
      "some text to identify the transfer": [""],
      Amount: ["Importo"],
      "amount to transfer": ["Somma da ritirare"],
      "payto URI:": [""],
      "uniform resource identifier of the target account": [""],
      "payto://iban/[receiver-iban]?message=[subject]&amount=[%1$s:X.Y]": [""],
      Cancel: [""],
      Send: [""],
      "Missing username": [""],
      "Missing password": [""],
      'Wrong credentials for "%1$s"': ["Credenziali invalide."],
      "Account not found": [""],
      Username: [""],
      "username of the account": [
        "Trasferisci fondi a un altro conto di questa banca:"
      ],
      Password: [""],
      "password of the account": ["Storico dei conti pubblici"],
      Check: [""],
      "Log in": [""],
      Register: ["Registrati"],
      "Wire transfer completed!": ["Bonifico"],
      "The withdrawal has been aborted previously and can't be confirmed": [""],
      "The withdrawal operation can't be confirmed before a wallet accepted the transaction.": [""],
      "Your balance is not enough for the operation.": [""],
      "Confirm the withdrawal operation": ["Conferma il ritiro"],
      "Wire transfer details": ["Bonifico"],
      "Taler Exchange operator's account": [""],
      "Taler Exchange operator's name": [""],
      Transfer: [""],
      "Authentication required": [""],
      "This operation was created with other username": [""],
      "Operation aborted": [""],
      "The wire transfer to the Taler Exchange operator's account was aborted, your balance was not affected.": [""],
      "You can close this page now or continue to the account page.": [""],
      Continue: [""],
      "Withdrawal confirmed": ["Questo ritiro \xE8 stato annullato!"],
      "The wire transfer to the Taler operator has been initiated. You will soon receive the requested amount in your Taler wallet.": [""],
      Done: [""],
      "Operation canceled": [""],
      "The operation is marked as 'selected' but some step in the withdrawal failed": [""],
      "The account is selected but no withdrawal identification found.": [""],
      "There is a withdrawal identification but no account has been selected or the selected account is invalid.": [""],
      "No withdrawal ID found and no account has been selected or the selected account is invalid.": [""],
      "Operation not found": [""],
      "This operation is not known by the server. The operation id is wrong or the server deleted the operation information before reaching here.": [""],
      "Cotinue to dashboard": [""],
      "The Withdrawal URI is not valid": ["Questo ritiro \xE8 stato annullato!"],
      'the bank backend is not supported. supported version "%1$s", server version "%2$s"': [""],
      "Internal error, please report.": ["Registrazione"],
      Preferences: [""],
      "Welcome, %1$s": [""],
      "Latest transactions": ["Ultime transazioni:"],
      Date: ["Data"],
      Counterpart: ["Controparte"],
      Subject: ["Soggetto"],
      sent: [""],
      received: [""],
      "invalid value": [""],
      to: [""],
      from: [""],
      "First page": [""],
      Next: [""],
      "History of public accounts": ["Storico dei conti pubblici"],
      "Currently, the bank is not accepting new registrations!": [""],
      "Missing name": ["indirizzo Payto"],
      "Use letters and numbers only, and start with a lowercase letter": [""],
      "Passwords don't match": [""],
      "Server replied with invalid phone or email.": [""],
      "Registration is disabled because the bank ran out of bonus credit.": [
        ""
      ],
      "No enough permission to create that account.": [""],
      "That account id is already taken.": [""],
      "That username is already taken.": [""],
      "That username can't be used because is reserved.": [""],
      "Only admin is allow to set debt limit.": [""],
      "No information for the selected authentication channel.": [""],
      "Authentication channel is not supported.": [""],
      "Only admin can create accounts with second factor authentication.": [""],
      "Account registration": [""],
      "Repeat password": [""],
      Name: [""],
      "Create a random temporary user": [""],
      "Make a wire transfer": ["Chiudi il bonifico"],
      "Wire transfer created!": ["Bonifico"],
      Accounts: ["Importo"],
      "A list of all business account in the bank.": [""],
      "Create account": [""],
      Balance: [""],
      Actions: [""],
      unknown: [""],
      "change password": [""],
      remove: [""],
      "Select a section": [""],
      "Last hour": [""],
      "Last day": [""],
      "Last month": [""],
      "Last year": [""],
      "Last Year": [""],
      "Trading volume on %1$s compared to %2$s": [""],
      Cashin: [""],
      Cashout: [""],
      Payin: [""],
      Payout: [""],
      "download stats as CSV": [""],
      "Descreased by": [""],
      "Increased by": [""],
      "Unable to create a cashout": [""],
      "The bank configuration does not support cashout operations.": [""],
      invalid: [""],
      "need to be higher due to fees": [""],
      "the total transfer at destination will be zero": [""],
      "Cashout created": [""],
      "Duplicated request detected, check if the operation succeded or try again.": [""],
      "The conversion rate was incorrectly applied": [""],
      "The account does not have sufficient funds": [""],
      "Cashouts are not supported": [""],
      "Missing cashout URI in the profile": [""],
      "Sending the confirmation message failed, retry later or contact the administrator.": [""],
      "Convertion rate": [""],
      Fee: [""],
      "To account": [""],
      "No cashout account": [""],
      "Before doing a cashout you need to complete your profile": [""],
      "Amount to send": ["Somma da ritirare"],
      "Amount to receive": ["Somma da ritirare"],
      "Total cost": [""],
      "Balance left": [""],
      "Before fee": [""],
      "Total cashout transfer": [""],
      "No cashout channel available": [""],
      "Before doing a cashout the server need to provide an second channel to confirm the operation": [""],
      "Second factor authentication": [""],
      Email: [""],
      "add a email in your profile to enable this option": [""],
      SMS: [""],
      "add a phone number in your profile to enable this option": [""],
      Details: [""],
      Delete: [""],
      Credentials: ["Credenziali invalide."],
      Cashouts: [""],
      "it doesnt have the pattern of an IBAN number": [""],
      "it doesnt have the pattern of an email": [""],
      "should start with +": [""],
      "phone number can't have other than numbers": [""],
      "account identification in the bank": [""],
      "name of the person owner the account": [""],
      "Internal IBAN": [""],
      "if empty a random account number will be assigned": [""],
      "account identification for bank transfer": [""],
      Phone: [""],
      "Cashout IBAN": [""],
      "account number where the money is going to be sent when doing cashouts": [""],
      "Max debt": [""],
      "how much is user able to transfer after zero balance": [""],
      "Is this a Taler Exchange?": [""],
      "This server doesn't support second factor authentication.": [""],
      "Enable second factor authentication": [""],
      "Using email": [""],
      "Using SMS": [""],
      "Is this account public?": [""],
      "public accounts have their balance publicly accesible": [""],
      "Account updated": [""],
      "The rights to change the account are not sufficient": [""],
      "The username was not found": [""],
      "You can't change the legal name, please contact the your account administrator.": [""],
      "You can't change the debt limit, please contact the your account administrator.": [""],
      "You can't change the cashout address, please contact the your account administrator.": [""],
      "You can't change the contact data, please contact the your account administrator.": [""],
      'Account "%1$s"': [""],
      "Change details": [""],
      Update: [""],
      "password doesn't match": [""],
      "Password changed": [""],
      "Not authorized to change the password, maybe the session is invalid.": [
        ""
      ],
      "You need to provide the old password. If you don't have it contact your account administrator.": [""],
      "Your current password doesn't match, can't change to a new password.": [
        ""
      ],
      "Update password": [""],
      "New password": [""],
      "Type it again": [""],
      "repeat the same password": [""],
      "Current password": [""],
      "your current password, for security": [""],
      Change: [""],
      "Can't delete the account": [""],
      "The account can't be delete while still holding some balance. First make sure that the owner make a complete cashout.": [""],
      "Account removed": [""],
      "No enough permission to delete the account.": [""],
      "The username was not found.": [""],
      "Can't delete a reserved username.": [""],
      "Can't delete an account with balance different than zero.": [""],
      "name doesn't match": [""],
      "You are going to remove the account": [""],
      "This step can't be undone.": [""],
      'Deleting account "%1$s"': [""],
      Verification: [""],
      "enter the account name that is going to be deleted": [""],
      'Account created with password "%1$s". The user must change the password on the next login.': [""],
      "Server replied that phone or email is invalid": [""],
      "The rights to perform the operation are not sufficient": [""],
      "Account username is already taken": [""],
      "Account id is already taken": [""],
      "Bank ran out of bonus credit.": [""],
      "Account username can't be used because is reserved": [""],
      "Can't create accounts": [""],
      "Only system admin can create accounts.": [""],
      "New business account": [""],
      Create: [""],
      "Cashout not supported.": [""],
      "Account not found.": ["Lista conti pubblici non trovata."],
      "Latest cashouts": ["Ultime transazioni:"],
      Created: [""],
      Confirmed: ["Conferma"],
      "Total debit": [""],
      "Total credit": [""],
      Status: [""],
      never: [""],
      "Cashout for account %1$s": [""],
      "This cashout not found. Maybe already aborted.": [""],
      "Cashout not found. It may be also mean that it was already aborted.": [
        ""
      ],
      "Cashout was already confimed.": [""],
      "Cashout operation is not supported.": [""],
      "The cashout operation is already aborted.": [""],
      "Missing destination account.": [""],
      "Too many failed attempts.": [""],
      "The code for this cashout is invalid.": [""],
      "Cashout detail": [""],
      Debited: [""],
      Credited: [""],
      "Enter the confirmation code": [""],
      Abort: ["Annulla"],
      Confirm: ["Conferma"],
      "Unauthorized to make the operation, maybe the session has expired or the password changed.": [""],
      "The operation was rejected due to insufficient funds.": [""],
      "Do not show this again": [""],
      Close: [""],
      "On this device": [""],
      'If you are using a web browser on desktop you should access your wallet with the GNU Taler WebExtension now or click the link if your WebExtension have the "Inject Taler support" option enabled.': [""],
      Start: [""],
      "On a mobile phone": [""],
      "Scan the QR code with your mobile device.": [
        "Usa questo codice QR per ritirare contante nel tuo wallet:"
      ],
      "There is an operation already": [""],
      "Complete or cancel the operation in": ["Conferma il ritiro"],
      "Server responded with an invalid  withdraw URI": [""],
      "Withdraw URI: %1$s": ["Prelevare"],
      "The operation was rejected due to insufficient funds": [""],
      "Prepare your wallet": [""],
      "After using your wallet you will need to confirm or cancel the operation on this site.": [""],
      "You need a GNU Taler Wallet": ["Ritira contante nel portafoglio Taler"],
      "If you don't have one yet you can follow the instruction in": [""],
      "Send money": [""],
      "to a %1$s wallet": [""],
      "Withdraw digital money into your mobile wallet or browser extension": [
        ""
      ],
      "operation ready": [""],
      "to another bank account": [
        "Trasferisci fondi a un altro conto di questa banca:"
      ],
      "Make a wire transfer to an account with known bank account number.": [
        ""
      ],
      "Transfer details": ["Effettua un bonifico"],
      "This is a demo bank": [""],
      "This part of the demo shows how a bank that supports Taler directly would work. In addition to using your own bank account, you can also see the transaction history of some %1$s.": [""],
      "This part of the demo shows how a bank that supports Taler directly would work.": [""],
      "Pending account delete operation": [""],
      "Pending account update operation": [""],
      "Pending password update operation": [""],
      "Pending transaction operation": [""],
      "Pending withdrawal operation": [""],
      "Pending cashout operation": [""],
      "You can complete or cancel the operation in": [""],
      "Download bank stats": [""],
      "Include hour metric": [""],
      "Include day metric": [""],
      "Include month metric": [""],
      "Include year metric": [""],
      "Include table header": [""],
      "Add previous metric for compare": [""],
      "Fail on first error": [""],
      Download: [""],
      "downloading... %1$s": [""],
      "Download completed": [""],
      "click here to save the file in your computer": [""],
      "Challenge not found.": [""],
      "This user is not authorized to complete this challenge.": [""],
      "Too many attemps, try another code.": [""],
      "The confirmation code is wrong, try again.": [""],
      "The operation expired.": [""],
      "The operation failed.": ["Questo ritiro \xE8 stato annullato!"],
      "The operation needs another confirmation to complete.": [""],
      "Account delete": [""],
      "Account update": [""],
      "Password update": [""],
      "Wire transfer": ["Bonifico"],
      Withdrawal: ["Prelevare"],
      "Confirm the operation": ["Conferma il ritiro"],
      "Send again": [""],
      "Send code": [""],
      "Operation details": [""],
      "Challenge details": [""],
      "Sent at": [""],
      "To phone": [""],
      "To email": [""],
      "Welcome to %1$s!": [""]
    }
  },
  domain: "messages",
  plural_forms: "nplurals=2; plural=n != 1;",
  lang: "it",
  completeness: 14
};
strings["fr"] = {
  locale_data: {
    messages: {
      "": {
        domain: "messages",
        plural_forms: "nplurals=2; plural=n > 1;",
        lang: "fr"
      },
      "Operation failed, please report": [""],
      "Request timeout": [""],
      "Request throttled": [""],
      "Malformed response": [""],
      "Network error": [""],
      "Unexpected request error": [""],
      "Unexpected error": [""],
      "IBAN numbers usually have more that 4 digits": [""],
      "IBAN numbers usually have less that 34 digits": [""],
      "IBAN country code not found": [""],
      "IBAN number is not valid, checksum is wrong": [""],
      "Max withdrawal amount": [""],
      "Show withdrawal confirmation": [""],
      "Show demo description": [""],
      "Show install wallet first": [""],
      "Use fast withdrawal form": [""],
      "Show debug info": [""],
      "The reserve operation has been confirmed previously and can't be aborted": [""],
      "The operation id is invalid.": [""],
      "The operation was not found.": [""],
      "If you have a Taler wallet installed in this device": [""],
      "You will see the details of the operation in your wallet including the fees (if applies). If you still don't have one you can install it following instructions in": [""],
      "this page": [""],
      Withdraw: [""],
      "Or if you have the wallet in another device": [""],
      "Scan the QR below to start the withdrawal.": [""],
      required: [""],
      "IBAN should have just uppercased letters and numbers": [""],
      "not valid": [""],
      "should be greater than 0": [""],
      "balance is not enough": [""],
      "does not follow the pattern": [""],
      'only "IBAN" target are supported': [""],
      'use the "amount" parameter to specify the amount to be transferred': [
        ""
      ],
      "the amount is not valid": [""],
      'use the "message" parameter to specify a reference text for the transfer': [""],
      "The request was invalid or the payto://-URI used unacceptable features.": [""],
      "Not enough permission to complete the operation.": [""],
      'The destination account "%1$s" was not found.': [""],
      "The origin and the destination of the transfer can't be the same.": [""],
      "Your balance is not enough.": [""],
      'The origin account "%1$s" was not found.': [""],
      "Using a form": [""],
      "Import payto:// URI": [""],
      Recipient: [""],
      "IBAN of the recipient's account": [""],
      "Transfer subject": [""],
      subject: [""],
      "some text to identify the transfer": [""],
      Amount: [""],
      "amount to transfer": [""],
      "payto URI:": [""],
      "uniform resource identifier of the target account": [""],
      "payto://iban/[receiver-iban]?message=[subject]&amount=[%1$s:X.Y]": [""],
      Cancel: [""],
      Send: [""],
      "Missing username": [""],
      "Missing password": [""],
      'Wrong credentials for "%1$s"': [""],
      "Account not found": [""],
      Username: [""],
      "username of the account": [""],
      Password: [""],
      "password of the account": [""],
      Check: [""],
      "Log in": [""],
      Register: [""],
      "Wire transfer completed!": [""],
      "The withdrawal has been aborted previously and can't be confirmed": [""],
      "The withdrawal operation can't be confirmed before a wallet accepted the transaction.": [""],
      "Your balance is not enough for the operation.": [""],
      "Confirm the withdrawal operation": [""],
      "Wire transfer details": [""],
      "Taler Exchange operator's account": [""],
      "Taler Exchange operator's name": [""],
      Transfer: [""],
      "Authentication required": [""],
      "This operation was created with other username": [""],
      "Operation aborted": [""],
      "The wire transfer to the Taler Exchange operator's account was aborted, your balance was not affected.": [""],
      "You can close this page now or continue to the account page.": [""],
      Continue: [""],
      "Withdrawal confirmed": [""],
      "The wire transfer to the Taler operator has been initiated. You will soon receive the requested amount in your Taler wallet.": [""],
      Done: [""],
      "Operation canceled": [""],
      "The operation is marked as 'selected' but some step in the withdrawal failed": [""],
      "The account is selected but no withdrawal identification found.": [""],
      "There is a withdrawal identification but no account has been selected or the selected account is invalid.": [""],
      "No withdrawal ID found and no account has been selected or the selected account is invalid.": [""],
      "Operation not found": [""],
      "This operation is not known by the server. The operation id is wrong or the server deleted the operation information before reaching here.": [""],
      "Cotinue to dashboard": [""],
      "The Withdrawal URI is not valid": [""],
      'the bank backend is not supported. supported version "%1$s", server version "%2$s"': [""],
      "Internal error, please report.": [""],
      Preferences: [""],
      "Welcome, %1$s": [""],
      "Latest transactions": [""],
      Date: [""],
      Counterpart: [""],
      Subject: [""],
      sent: [""],
      received: [""],
      "invalid value": [""],
      to: [""],
      from: [""],
      "First page": [""],
      Next: [""],
      "History of public accounts": [""],
      "Currently, the bank is not accepting new registrations!": [""],
      "Missing name": [""],
      "Use letters and numbers only, and start with a lowercase letter": [""],
      "Passwords don't match": [""],
      "Server replied with invalid phone or email.": [""],
      "Registration is disabled because the bank ran out of bonus credit.": [
        ""
      ],
      "No enough permission to create that account.": [""],
      "That account id is already taken.": [""],
      "That username is already taken.": [""],
      "That username can't be used because is reserved.": [""],
      "Only admin is allow to set debt limit.": [""],
      "No information for the selected authentication channel.": [""],
      "Authentication channel is not supported.": [""],
      "Only admin can create accounts with second factor authentication.": [""],
      "Account registration": [""],
      "Repeat password": [""],
      Name: [""],
      "Create a random temporary user": [""],
      "Make a wire transfer": [""],
      "Wire transfer created!": [""],
      Accounts: [""],
      "A list of all business account in the bank.": [""],
      "Create account": [""],
      Balance: [""],
      Actions: [""],
      unknown: [""],
      "change password": [""],
      remove: [""],
      "Select a section": [""],
      "Last hour": [""],
      "Last day": [""],
      "Last month": [""],
      "Last year": [""],
      "Last Year": [""],
      "Trading volume on %1$s compared to %2$s": [""],
      Cashin: [""],
      Cashout: [""],
      Payin: [""],
      Payout: [""],
      "download stats as CSV": [""],
      "Descreased by": [""],
      "Increased by": [""],
      "Unable to create a cashout": [""],
      "The bank configuration does not support cashout operations.": [""],
      invalid: [""],
      "need to be higher due to fees": [""],
      "the total transfer at destination will be zero": [""],
      "Cashout created": [""],
      "Duplicated request detected, check if the operation succeded or try again.": [""],
      "The conversion rate was incorrectly applied": [""],
      "The account does not have sufficient funds": [""],
      "Cashouts are not supported": [""],
      "Missing cashout URI in the profile": [""],
      "Sending the confirmation message failed, retry later or contact the administrator.": [""],
      "Convertion rate": [""],
      Fee: [""],
      "To account": [""],
      "No cashout account": [""],
      "Before doing a cashout you need to complete your profile": [""],
      "Amount to send": [""],
      "Amount to receive": [""],
      "Total cost": [""],
      "Balance left": [""],
      "Before fee": [""],
      "Total cashout transfer": [""],
      "No cashout channel available": [""],
      "Before doing a cashout the server need to provide an second channel to confirm the operation": [""],
      "Second factor authentication": [""],
      Email: [""],
      "add a email in your profile to enable this option": [""],
      SMS: [""],
      "add a phone number in your profile to enable this option": [""],
      Details: [""],
      Delete: [""],
      Credentials: [""],
      Cashouts: [""],
      "it doesnt have the pattern of an IBAN number": [""],
      "it doesnt have the pattern of an email": [""],
      "should start with +": [""],
      "phone number can't have other than numbers": [""],
      "account identification in the bank": [""],
      "name of the person owner the account": [""],
      "Internal IBAN": [""],
      "if empty a random account number will be assigned": [""],
      "account identification for bank transfer": [""],
      Phone: [""],
      "Cashout IBAN": [""],
      "account number where the money is going to be sent when doing cashouts": [""],
      "Max debt": [""],
      "how much is user able to transfer after zero balance": [""],
      "Is this a Taler Exchange?": [""],
      "This server doesn't support second factor authentication.": [""],
      "Enable second factor authentication": [""],
      "Using email": [""],
      "Using SMS": [""],
      "Is this account public?": [""],
      "public accounts have their balance publicly accesible": [""],
      "Account updated": [""],
      "The rights to change the account are not sufficient": [""],
      "The username was not found": [""],
      "You can't change the legal name, please contact the your account administrator.": [""],
      "You can't change the debt limit, please contact the your account administrator.": [""],
      "You can't change the cashout address, please contact the your account administrator.": [""],
      "You can't change the contact data, please contact the your account administrator.": [""],
      'Account "%1$s"': [""],
      "Change details": [""],
      Update: [""],
      "password doesn't match": [""],
      "Password changed": [""],
      "Not authorized to change the password, maybe the session is invalid.": [
        ""
      ],
      "You need to provide the old password. If you don't have it contact your account administrator.": [""],
      "Your current password doesn't match, can't change to a new password.": [
        ""
      ],
      "Update password": [""],
      "New password": [""],
      "Type it again": [""],
      "repeat the same password": [""],
      "Current password": [""],
      "your current password, for security": [""],
      Change: [""],
      "Can't delete the account": [""],
      "The account can't be delete while still holding some balance. First make sure that the owner make a complete cashout.": [""],
      "Account removed": [""],
      "No enough permission to delete the account.": [""],
      "The username was not found.": [""],
      "Can't delete a reserved username.": [""],
      "Can't delete an account with balance different than zero.": [""],
      "name doesn't match": [""],
      "You are going to remove the account": [""],
      "This step can't be undone.": [""],
      'Deleting account "%1$s"': [""],
      Verification: [""],
      "enter the account name that is going to be deleted": [""],
      'Account created with password "%1$s". The user must change the password on the next login.': [""],
      "Server replied that phone or email is invalid": [""],
      "The rights to perform the operation are not sufficient": [""],
      "Account username is already taken": [""],
      "Account id is already taken": [""],
      "Bank ran out of bonus credit.": [""],
      "Account username can't be used because is reserved": [""],
      "Can't create accounts": [""],
      "Only system admin can create accounts.": [""],
      "New business account": [""],
      Create: [""],
      "Cashout not supported.": [""],
      "Account not found.": [""],
      "Latest cashouts": [""],
      Created: [""],
      Confirmed: [""],
      "Total debit": [""],
      "Total credit": [""],
      Status: [""],
      never: [""],
      "Cashout for account %1$s": [""],
      "This cashout not found. Maybe already aborted.": [""],
      "Cashout not found. It may be also mean that it was already aborted.": [
        ""
      ],
      "Cashout was already confimed.": [""],
      "Cashout operation is not supported.": [""],
      "The cashout operation is already aborted.": [""],
      "Missing destination account.": [""],
      "Too many failed attempts.": [""],
      "The code for this cashout is invalid.": [""],
      "Cashout detail": [""],
      Debited: [""],
      Credited: [""],
      "Enter the confirmation code": [""],
      Abort: [""],
      Confirm: [""],
      "Unauthorized to make the operation, maybe the session has expired or the password changed.": [""],
      "The operation was rejected due to insufficient funds.": [""],
      "Do not show this again": [""],
      Close: [""],
      "On this device": [""],
      'If you are using a web browser on desktop you should access your wallet with the GNU Taler WebExtension now or click the link if your WebExtension have the "Inject Taler support" option enabled.': [""],
      Start: [""],
      "On a mobile phone": [""],
      "Scan the QR code with your mobile device.": [""],
      "There is an operation already": [""],
      "Complete or cancel the operation in": [""],
      "Server responded with an invalid  withdraw URI": [""],
      "Withdraw URI: %1$s": [""],
      "The operation was rejected due to insufficient funds": [""],
      "Prepare your wallet": [""],
      "After using your wallet you will need to confirm or cancel the operation on this site.": [""],
      "You need a GNU Taler Wallet": [""],
      "If you don't have one yet you can follow the instruction in": [""],
      "Send money": [""],
      "to a %1$s wallet": [""],
      "Withdraw digital money into your mobile wallet or browser extension": [
        ""
      ],
      "operation ready": [""],
      "to another bank account": [""],
      "Make a wire transfer to an account with known bank account number.": [
        ""
      ],
      "Transfer details": [""],
      "This is a demo bank": [""],
      "This part of the demo shows how a bank that supports Taler directly would work. In addition to using your own bank account, you can also see the transaction history of some %1$s.": [""],
      "This part of the demo shows how a bank that supports Taler directly would work.": [""],
      "Pending account delete operation": [""],
      "Pending account update operation": [""],
      "Pending password update operation": [""],
      "Pending transaction operation": [""],
      "Pending withdrawal operation": [""],
      "Pending cashout operation": [""],
      "You can complete or cancel the operation in": [""],
      "Download bank stats": [""],
      "Include hour metric": [""],
      "Include day metric": [""],
      "Include month metric": [""],
      "Include year metric": [""],
      "Include table header": [""],
      "Add previous metric for compare": [""],
      "Fail on first error": [""],
      Download: [""],
      "downloading... %1$s": [""],
      "Download completed": [""],
      "click here to save the file in your computer": [""],
      "Challenge not found.": [""],
      "This user is not authorized to complete this challenge.": [""],
      "Too many attemps, try another code.": [""],
      "The confirmation code is wrong, try again.": [""],
      "The operation expired.": [""],
      "The operation failed.": [""],
      "The operation needs another confirmation to complete.": [""],
      "Account delete": [""],
      "Account update": [""],
      "Password update": [""],
      "Wire transfer": [""],
      Withdrawal: [""],
      "Confirm the operation": [""],
      "Send again": [""],
      "Send code": [""],
      "Operation details": [""],
      "Challenge details": [""],
      "Sent at": [""],
      "To phone": [""],
      "To email": [""],
      "Welcome to %1$s!": [""]
    }
  },
  domain: "messages",
  plural_forms: "nplurals=2; plural=n > 1;",
  lang: "fr",
  completeness: 0
};
strings["es"] = {
  locale_data: {
    messages: {
      "": {
        domain: "messages",
        plural_forms: "nplurals=2; plural=n != 1;",
        lang: "es"
      },
      "Operation failed, please report": [
        "La operaic\xF3n fall\xF3, por favor reportelo"
      ],
      "Request timeout": ["La petici\xF3n al servidor agoto su tiempo"],
      "Request throttled": ["La petici\xF3n al servidor interrumpida"],
      "Malformed response": ["Respuesta malformada"],
      "Network error": ["Error de conexi\xF3n"],
      "Unexpected request error": ["Error de pedido inesperado"],
      "Unexpected error": ["Error inesperado"],
      "IBAN numbers usually have more that 4 digits": [
        "Los n\xFAmeros IBAN usualmente tienen mas de 4 digitos"
      ],
      "IBAN numbers usually have less that 34 digits": [
        "Los n\xFAmeros IBAN usualmente tienen menos de 34 digitos"
      ],
      "IBAN country code not found": ["C\xF3digo de pais de IBAN no encontrado"],
      "IBAN number is not valid, checksum is wrong": [
        "El n\xFAmero IBAN no es v\xE1lido, fall\xF3 la verificaci\xF3n"
      ],
      "Max withdrawal amount": ["Monto m\xE1ximo de extracci\xF3n"],
      "Show withdrawal confirmation": ["Mostrar confirmaci\xF3n de extracci\xF3n"],
      "Show demo description": ["Mostrar descripci\xF3n de demo"],
      "Show install wallet first": ["Mostrar instalar la billetera primero"],
      "Use fast withdrawal form": ["Usar formulario de extracci\xF3n r\xE1pida"],
      "Show debug info": ["Mostrar informaci\xF3n de depuraci\xF3n"],
      "The reserve operation has been confirmed previously and can't be aborted": [
        "La operaci\xF3n en la reserva ya ha sido confirmada previamente y no puede ser abortada"
      ],
      "The operation id is invalid.": ["El id de operaci\xF3n es invalido."],
      "The operation was not found.": ["La operaci\xF3n no se encontr\xF3."],
      "If you have a Taler wallet installed in this device": [
        "Si tienes una billetera Taler instalada en este dispositivo"
      ],
      "You will see the details of the operation in your wallet including the fees (if applies). If you still don't have one you can install it following instructions in": [
        "Veras los detalles de la operaci\xF3n en tu billetera incluyendo comisiones (si aplic\xE1n). Si todav\xEDa no tienes una puedes instalarla siguiendo las instrucciones en"
      ],
      "this page": ["esta p\xE1gina"],
      Withdraw: ["Retirar"],
      "Or if you have the wallet in another device": [
        "O si tienes la billetera en otro dispositivo"
      ],
      "Scan the QR below to start the withdrawal.": [
        "Escanea el QR debajo para comenzar la extracci\xF3n."
      ],
      required: ["requerido"],
      "IBAN should have just uppercased letters and numbers": [
        "IBAN deber\xEDa tener letras may\xFAsculas y n\xFAmeros"
      ],
      "not valid": ["no v\xE1lido"],
      "should be greater than 0": ["Deber\xEDa ser mas grande que 0"],
      "balance is not enough": ["el saldo no es suficiente"],
      "does not follow the pattern": ["no tiene un patr\xF3n valido"],
      'only "IBAN" target are supported': [
        'solo cuentas "IBAN" son soportadas'
      ],
      'use the "amount" parameter to specify the amount to be transferred': [
        'usa el par\xE1metro "amount" para indicar el monto a ser transferido'
      ],
      "the amount is not valid": ["el monto no es v\xE1lido"],
      'use the "message" parameter to specify a reference text for the transfer': [
        'usa el par\xE1metro "message" para indicar un texto de referencia en la transferencia'
      ],
      "The request was invalid or the payto://-URI used unacceptable features.": [
        "El pedido era inv\xE1lido o el URI payto:// usado tiene caracter\xEDsticas inaceptables."
      ],
      "Not enough permission to complete the operation.": [
        "Sin permisos suficientes para completar la operaci\xF3n."
      ],
      'The destination account "%1$s" was not found.': [
        'La cuenta de destino "%1$s" no fue encontrada.'
      ],
      "The origin and the destination of the transfer can't be the same.": [
        "El origen y destino de la transferencia no puede ser la misma."
      ],
      "Your balance is not enough.": ["El saldo no es suficiente."],
      'The origin account "%1$s" was not found.': [
        'La cuenta origen "%1$s" no fue encontrada.'
      ],
      "Using a form": ["Usando un formulario"],
      "Import payto:// URI": ["Importando un URI payto://"],
      Recipient: ["Destinatario"],
      "IBAN of the recipient's account": [
        "Numero IBAN de la cuenta destinataria"
      ],
      "Transfer subject": ["Asunto de transferencia"],
      subject: ["asunto"],
      "some text to identify the transfer": [
        "alg\xFAn texto para identificar la transferencia"
      ],
      Amount: ["Monto"],
      "amount to transfer": ["monto a transferir"],
      "payto URI:": ["payto URI:"],
      "uniform resource identifier of the target account": [
        "identificador de recurso uniforme de la cuenta destino"
      ],
      "payto://iban/[receiver-iban]?message=[subject]&amount=[%1$s:X.Y]": [
        "payto://iban/[iban-destinatario]?message=[asunto]&amount=[%1$s:X.Y]"
      ],
      Cancel: ["Cancelar"],
      Send: ["Env\xEDar"],
      "Missing username": ["Falta nombre de usuario"],
      "Missing password": ["Falta contrase\xF1a"],
      'Wrong credentials for "%1$s"': ['Credenciales incorrectas para "%1$s"'],
      "Account not found": ["Cuenta no encontrada"],
      Username: ["Nombre de usuario"],
      "username of the account": ["nombre de usuario de la cuenta"],
      Password: ["Contrase\xF1a"],
      "password of the account": ["contrase\xF1a de la cuenta"],
      Check: ["Verificar"],
      "Log in": ["Acceso"],
      Register: ["Registrarse"],
      "Wire transfer completed!": ["Transferencia bancaria completada!"],
      "The withdrawal has been aborted previously and can't be confirmed": [
        "La extracci\xF3n fue abortada anteriormente y no puede ser confirmada"
      ],
      "The withdrawal operation can't be confirmed before a wallet accepted the transaction.": [
        "La operaci\xF3n de extracci\xF3n no puede ser confirmada antes de que una billetera acepte la transaccion."
      ],
      "Your balance is not enough for the operation.": [
        "El saldo no es suficiente para la operaci\xF3n."
      ],
      "Confirm the withdrawal operation": [
        "Confirme la operaci\xF3n de extracci\xF3n"
      ],
      "Wire transfer details": ["Detalle de transferencia bancaria"],
      "Taler Exchange operator's account": [
        "Cuenta del operador del Taler Exchange"
      ],
      "Taler Exchange operator's name": [
        "Nombre del operador del Taler Exchange"
      ],
      Transfer: ["Transferencia"],
      "Authentication required": ["Autenticaci\xF3n requerida"],
      "This operation was created with other username": [
        "Esta operaci\xF3n fue creada con otro usuario"
      ],
      "Operation aborted": ["Operaci\xF3n abortada"],
      "The wire transfer to the Taler Exchange operator's account was aborted, your balance was not affected.": [
        "La transferencia bancaria a la cuenta del operador del Taler Exchange fue abortada, su saldo no fue afectado."
      ],
      "You can close this page now or continue to the account page.": [
        "Ya puedes cerrar esta pagina or continuar a la p\xE1gina de estado de cuenta."
      ],
      Continue: ["Continuar"],
      "Withdrawal confirmed": ["La extracci\xF3n fue confirmada"],
      "The wire transfer to the Taler operator has been initiated. You will soon receive the requested amount in your Taler wallet.": [
        "La transferencia bancaria al operador Taler fue iniciada. Pronto recibir\xE1s el monto pedido en tu billetera Taler."
      ],
      Done: ["Listo"],
      "Operation canceled": ["Operaci\xF3n cancelada"],
      "The operation is marked as 'selected' but some step in the withdrawal failed": [
        "La operaci\xF3n est\xE1 marcada como 'seleccionada' pero algunos pasos en la extracci\xF3n fallaron"
      ],
      "The account is selected but no withdrawal identification found.": [
        "La cuenta est\xE1 seleccionada pero no se encontr\xF3 el identificador de extracci\xF3n."
      ],
      "There is a withdrawal identification but no account has been selected or the selected account is invalid.": [
        "Hay un identificador de extracci\xF3n pero la cuenta no ha sido seleccionada o la selccionada es inv\xE1lida."
      ],
      "No withdrawal ID found and no account has been selected or the selected account is invalid.": [
        "No hay un identificador de extracci\xF3n y ninguna cuenta a sido seleccionada o la seleccionada es inv\xE1lida."
      ],
      "Operation not found": ["Operaci\xF3n no encontrada"],
      "This operation is not known by the server. The operation id is wrong or the server deleted the operation information before reaching here.": [
        "Esta operaci\xF3n no es conocida por el servidor. El identificador de operaci\xF3n es incorrecto o el server borr\xF3 la informaci\xF3n de la operaci\xF3n antes de llegar hasta aqu\xED."
      ],
      "Cotinue to dashboard": ["Continuar al panel"],
      "The Withdrawal URI is not valid": ["El URI de estracci\xF3n no es v\xE1lido"],
      'the bank backend is not supported. supported version "%1$s", server version "%2$s"': [
        'El servidor de bank no esta spoportado. Version soportada "%1$s", version del server "%2$s"'
      ],
      "Internal error, please report.": [
        "Error interno, por favor reporte el error."
      ],
      Preferences: ["Preferencias"],
      "Welcome, %1$s": ["Bienvenido/a, %1$s"],
      "Latest transactions": ["\xDAltimas transacciones"],
      Date: ["Fecha"],
      Counterpart: ["Contraparte"],
      Subject: ["Asunto"],
      sent: ["enviado"],
      received: ["recibido"],
      "invalid value": ["valor inv\xE1lido"],
      to: ["hacia"],
      from: ["desde"],
      "First page": ["Primera p\xE1gina"],
      Next: ["Siguiente"],
      "History of public accounts": ["Historial de cuentas p\xFAblicas"],
      "Currently, the bank is not accepting new registrations!": [
        "Actualmente, el banco no est\xE1 aceptado nuevos registros!"
      ],
      "Missing name": ["Falta nombre"],
      "Use letters and numbers only, and start with a lowercase letter": [
        "Solo use letras y n\xFAmeros, y comience con una letra min\xFAscula"
      ],
      "Passwords don't match": ["La contrase\xF1a no coincide"],
      "Server replied with invalid phone or email.": [
        "El servidor repondio con tel\xE9fono o direcci\xF3n de correo inv\xE1lido."
      ],
      "Registration is disabled because the bank ran out of bonus credit.": [
        "El registro est\xE1 deshabilitado porque el banco se qued\xF3 sin cr\xE9dito bonus."
      ],
      "No enough permission to create that account.": [
        "Sin permisos suficientes para crear esa cuenta."
      ],
      "That account id is already taken.": [
        "El identificador de cuenta ya est\xE1 tomado."
      ],
      "That username is already taken.": [
        "El nombre de usuario ya est\xE1 tomado."
      ],
      "That username can't be used because is reserved.": [
        "El nombre de usuario no puede ser usado porque esta reservado."
      ],
      "Only admin is allow to set debt limit.": [
        "Solo el administrador tiene permitido cambiar el l\xEDmite de deuda."
      ],
      "No information for the selected authentication channel.": [
        "No hay informaci\xF3n para el canal de autenticaci\xF3n seleccionado."
      ],
      "Authentication channel is not supported.": [
        "Canal de autenticaci\xF3n no esta soportado."
      ],
      "Only admin can create accounts with second factor authentication.": [
        "Solo el administrador puede crear cuentas con el segundo factor de autenticaci\xF3n."
      ],
      "Account registration": ["Registro de cuenta"],
      "Repeat password": ["Repita la contrase\xF1a"],
      Name: ["Nombre"],
      "Create a random temporary user": ["Crear un usuario aleatorio temporal"],
      "Make a wire transfer": ["Hacer una transferencia bancaria"],
      "Wire transfer created!": ["Transferencia bancaria creada!"],
      Accounts: ["Cuentas"],
      "A list of all business account in the bank.": [
        "Una lista de todas las cuentas en el banco."
      ],
      "Create account": ["Crear cuenta"],
      Balance: ["Saldo"],
      Actions: ["Acciones"],
      unknown: ["desconocido"],
      "change password": ["cambiar contrase\xF1a"],
      remove: ["elimiar"],
      "Select a section": ["Seleccione una secci\xF3n"],
      "Last hour": ["\xDAltima hora"],
      "Last day": ["\xDAltimo d\xEDa"],
      "Last month": ["\xDAltimo mes"],
      "Last year": ["\xDAltimo a\xF1o"],
      "Last Year": ["\xDAltimo A\xF1o"],
      "Trading volume on %1$s compared to %2$s": [
        "V\xF3lumen de comercio en %1$s comparado con %2$s"
      ],
      Cashin: ["Ingreso"],
      Cashout: ["Egreso"],
      Payin: ["Envios de dinero"],
      Payout: ["Recibos de dinero"],
      "download stats as CSV": ["descargar estad\xEDsticas en CSV"],
      "Descreased by": ["Descendiente por"],
      "Increased by": ["Ascendente por"],
      "Unable to create a cashout": ["Imposible crear un egreso"],
      "The bank configuration does not support cashout operations.": [
        "La configuraci\xF3n del banco no soporta operaciones de egreso."
      ],
      invalid: ["inv\xE1lido"],
      "need to be higher due to fees": [
        "necesita ser mayor debido a las comisiones"
      ],
      "the total transfer at destination will be zero": [
        "el total de la transferencia en destino ser\xE1 cero"
      ],
      "Cashout created": ["Egreso creado"],
      "Duplicated request detected, check if the operation succeded or try again.": [
        "Se detect\xF3 una petici\xF3n duplicada, verifique si la operaci\xF3n tuvo \xE9xito o intente otra vez."
      ],
      "The conversion rate was incorrectly applied": [
        "La tasa de conversi\xF3n se aplic\xF3 incorrectamente"
      ],
      "The account does not have sufficient funds": [
        "La cuenta no tiene fondos suficientes"
      ],
      "Cashouts are not supported": ["Egresos no est\xE1n soportados"],
      "Missing cashout URI in the profile": [
        "Falta direcci\xF3n de egreso en el perf\xEDl"
      ],
      "Sending the confirmation message failed, retry later or contact the administrator.": [
        "El env\xEDo del mensaje de confirmaci\xF3n fall\xF3, intente mas tarde o contacte al administrador."
      ],
      "Convertion rate": ["Tasa de conversi\xF3n"],
      Fee: ["Comisi\xF3n"],
      "To account": ["Hacia cuenta"],
      "No cashout account": ["No hay cuenta de egreso"],
      "Before doing a cashout you need to complete your profile": [
        "Antes de hacer un egreso necesita completar su perf\xEDl"
      ],
      "Amount to send": ["Monto a enviar"],
      "Amount to receive": ["Monto a recibir"],
      "Total cost": ["Costo total"],
      "Balance left": ["Saldo remanente"],
      "Before fee": ["Antes de comisi\xF3n"],
      "Total cashout transfer": ["Total de egreso"],
      "No cashout channel available": ["No hay canal de egreso disponible"],
      "Before doing a cashout the server need to provide an second channel to confirm the operation": [
        "Antes de hacer un egreso el servidor necesita proveer un segundo canal para confirmar la operaci\xF3n"
      ],
      "Second factor authentication": ["Segundo factor de autenticaci\xF3n"],
      Email: ["Correo eletr\xF3nico"],
      "add a email in your profile to enable this option": [
        "agrege un correo en su perf\xEDl para habilitar esta opci\xF3n"
      ],
      SMS: ["SMS"],
      "add a phone number in your profile to enable this option": [
        "agregue un n\xFAmero de tel\xE9fono para habilitar esta opci\xF3n"
      ],
      Details: ["Detalles"],
      Delete: ["Borrar"],
      Credentials: ["Credenciales"],
      Cashouts: ["Egresos"],
      "it doesnt have the pattern of an IBAN number": [
        "no tiene el patr\xF3n de un n\xFAmero IBAN"
      ],
      "it doesnt have the pattern of an email": [
        "no tiene el patr\xF3n de un correo electr\xF3nico"
      ],
      "should start with +": ["deber\xEDa comenzar con un +"],
      "phone number can't have other than numbers": [
        "n\xFAmero de tel\xE9fono no puede tener otra cosa que numeros"
      ],
      "account identification in the bank": [
        "identificador de cuenta en el banco"
      ],
      "name of the person owner the account": [
        "nombre de la persona due\xF1a de la cuenta"
      ],
      "Internal IBAN": ["IBAN interno"],
      "if empty a random account number will be assigned": [
        "si est\xE1 vac\xEDo un n\xFAmero de cuenta aleatorio ser\xE1 asignado"
      ],
      "account identification for bank transfer": [
        "identificador de cuenta para transferencia bancaria"
      ],
      Phone: ["Tel\xE9fono"],
      "Cashout IBAN": ["IBAN de egreso"],
      "account number where the money is going to be sent when doing cashouts": [
        "numero de cuenta donde el dinero ser\xE1 enviado cuando se ejecuten egresos"
      ],
      "Max debt": ["M\xE1xima deuda"],
      "how much is user able to transfer after zero balance": [
        "cuanto tiene habilitado a transferir despues de un saldo en cero"
      ],
      "Is this a Taler Exchange?": ["Es un Taler Exchange?"],
      "This server doesn't support second factor authentication.": [
        "Este servidor no tiene soporte para segundo factor de autenticaci\xF3n."
      ],
      "Enable second factor authentication": [
        "H\xE1bilitar segundo factor de autenticaci\xF3n"
      ],
      "Using email": ["Usando correo eletr\xF3nico"],
      "Using SMS": ["Usando SMS"],
      "Is this account public?": ["Es una cuenta p\xFAblica?"],
      "public accounts have their balance publicly accesible": [
        "las cuentas p\xFAblicas tienen su saldo accesible al p\xFAblico"
      ],
      "Account updated": ["Cuenta actualizada"],
      "The rights to change the account are not sufficient": [
        "Los permisos para cambiar la cuenta no son suficientes"
      ],
      "The username was not found": ["El nombre de usaurio no se encontr\xF3"],
      "You can't change the legal name, please contact the your account administrator.": [
        "No puede cambiar el nombre legal, por favor contacte el administrador de la cuenta."
      ],
      "You can't change the debt limit, please contact the your account administrator.": [
        "No puede cambiar el l\xEDmite de deuda, por favor contacte el administrador de la cuenta."
      ],
      "You can't change the cashout address, please contact the your account administrator.": [
        "No puede cambiar la direcci\xF3n de egreso, por favor contacte al administrador de la cuenta."
      ],
      "You can't change the contact data, please contact the your account administrator.": [
        "No puede cambiar los datos de contacto, por favor contacte al administrador de la cuenta."
      ],
      'Account "%1$s"': ['Cuenta "%1$s"'],
      "Change details": ["Cambiar detalles"],
      Update: ["Actualizar"],
      "password doesn't match": ["la contrase\xF1a no coincide"],
      "Password changed": ["La contrase\xF1a cambi\xF3"],
      "Not authorized to change the password, maybe the session is invalid.": [
        "No est\xE1 autorizado a cambiar el password, quiz\xE1 la sesi\xF3n es invalida."
      ],
      "You need to provide the old password. If you don't have it contact your account administrator.": [
        "Se necesita el password viejo para cambiar la contrase\xF1a. Si no lo tiene contacte a su administrador."
      ],
      "Your current password doesn't match, can't change to a new password.": [
        "Su actual contrase\xF1a no coincide, no puede cambiar a una nueva contrase\xF1a."
      ],
      "Update password": ["Actualizar contrase\xF1a"],
      "New password": ["Nueva contrase\xF1a"],
      "Type it again": ["Escribalo otra vez"],
      "repeat the same password": ["repita la misma contrase\xF1a"],
      "Current password": ["Contrase\xF1a actual"],
      "your current password, for security": [
        "su actual contrase\xF1a, por seguridad"
      ],
      Change: ["Cambiar"],
      "Can't delete the account": ["No se puede eliminar la cuenta"],
      "The account can't be delete while still holding some balance. First make sure that the owner make a complete cashout.": [
        "La cuenta no puede ser eliminada mientras tiene saldo. Primero asegures\xE9 que el due\xF1o haga un egreso completo."
      ],
      "Account removed": ["Cuenta eliminada"],
      "No enough permission to delete the account.": [
        "No tiene permisos suficientes para eliminar la cuenta."
      ],
      "The username was not found.": ["El nombr ede usuario no se encontr\xF3."],
      "Can't delete a reserved username.": [
        "No se puede eliminar un nombre de usuario reservado."
      ],
      "Can't delete an account with balance different than zero.": [
        "No se puede eliminar una cuenta con saldo diferente a cero."
      ],
      "name doesn't match": ["el nombre no coincide"],
      "You are going to remove the account": ["Est\xE1 por eliminar la cuenta"],
      "This step can't be undone.": ["Este paso no puede ser deshecho."],
      'Deleting account "%1$s"': ['Borrando cuenta "%1$s"'],
      Verification: ["Verificaci\xF3n"],
      "enter the account name that is going to be deleted": [
        "ingrese el nombre de cuenta que ser\xE1 eliminado"
      ],
      'Account created with password "%1$s". The user must change the password on the next login.': [
        'Cuenta creada con contrase\xF1a "%1$s". El usuario debe cambiar la contrase\xF1a en el siguiente ingreso.'
      ],
      "Server replied that phone or email is invalid": [
        "El servidor respondi\xF3 que el tel\xE9fono o correo eletr\xF3nico es invalido"
      ],
      "The rights to perform the operation are not sufficient": [
        "Los permisos para ejecutar la operaci\xF3n no son suficientes"
      ],
      "Account username is already taken": [
        "El nombre del usuario ya est\xE1 tomado"
      ],
      "Account id is already taken": ["El id de cuenta ya est\xE1 tomado"],
      "Bank ran out of bonus credit.": [
        "El banco no tiene mas cr\xE9dito de bonus."
      ],
      "Account username can't be used because is reserved": [
        "El nombre de usuario de la cuenta no puede userse porque est\xE1 reservado"
      ],
      "Can't create accounts": ["No puede crear cuentas"],
      "Only system admin can create accounts.": [
        "Solo los administradores del sistema pueden crear cuentas."
      ],
      "New business account": ["Nueva cuenta"],
      Create: ["Crear"],
      "Cashout not supported.": ["Egreso no soportado."],
      "Account not found.": ["Cuenta no encontrada."],
      "Latest cashouts": ["\xDAltimos egresos"],
      Created: ["Creado"],
      Confirmed: ["Confirmado"],
      "Total debit": ["D\xE9bito total"],
      "Total credit": ["Cr\xE9dito total"],
      Status: ["Estado"],
      never: ["nunca"],
      "Cashout for account %1$s": ["Egreso para cuenta %1$s"],
      "This cashout not found. Maybe already aborted.": [
        "Este egreso no se encontr\xF3. Quiz\xE1 fue abortado."
      ],
      "Cashout not found. It may be also mean that it was already aborted.": [
        "Egreso no econtrado. Tambi\xE9n puede significar que ya ha sido abortado."
      ],
      "Cashout was already confimed.": ["Egreso ya fue confirmado."],
      "Cashout operation is not supported.": [
        "Operaci\xF3n de egreso no soportada."
      ],
      "The cashout operation is already aborted.": [
        "La operaci\xF3n de egreso ya est\xE1 abortada."
      ],
      "Missing destination account.": ["Falta cuenta destino."],
      "Too many failed attempts.": ["Demasiados intentos fallidos."],
      "The code for this cashout is invalid.": [
        "El c\xF3digo para este egreso es invalido."
      ],
      "Cashout detail": ["Detalles de egreso"],
      Debited: ["Debitado"],
      Credited: ["Acreditado"],
      "Enter the confirmation code": ["Ingresar el c\xF3digo de confirmaci\xF3n"],
      Abort: ["Abortar"],
      Confirm: ["Confirmar"],
      "Unauthorized to make the operation, maybe the session has expired or the password changed.": [
        "No autorizado para hacer la operaci\xF3n, quiz\xE1 la sesi\xF3n haya expirado or cambi\xF3 la contrase\xF1a."
      ],
      "The operation was rejected due to insufficient funds.": [
        "La operaci\xF3n fue rechazada debido a saldo insuficiente."
      ],
      "Do not show this again": ["No mostrar otra vez"],
      Close: ["Cerrar"],
      "On this device": ["En este dispositivo"],
      'If you are using a web browser on desktop you should access your wallet with the GNU Taler WebExtension now or click the link if your WebExtension have the "Inject Taler support" option enabled.': [
        'Si esta usando un explorador web de escritorio deber\xEDas acceder ahora a tu billletera con la GNU Taler WebExtension o hacer click en el link si tu extensi\xF3n tiene la configuraci\xF3n "Inyectar soporte para Taler" habilitada.'
      ],
      Start: ["Comenzar"],
      "On a mobile phone": ["En un dispotivo mobile"],
      "Scan the QR code with your mobile device.": [
        "Escanear el c\xF3digo QR con tu dispotivo m\xF3vil."
      ],
      "There is an operation already": ["Ya hay una operaci\xF3n"],
      "Complete or cancel the operation in": [
        "Completa o cancela la operaci\xF3n en"
      ],
      "Server responded with an invalid  withdraw URI": [
        "El servidor respondi\xF3 con una URI de extracci\xF3n inv\xE1lida"
      ],
      "Withdraw URI: %1$s": ["URI de extracci\xF3n: %1$s"],
      "The operation was rejected due to insufficient funds": [
        "La operaci\xF3n fue rechazada debido a fundos insuficientes"
      ],
      "Prepare your wallet": ["Prepare su billetera"],
      "After using your wallet you will need to confirm or cancel the operation on this site.": [
        "Despues de usar tu billetera necesitar\xE1s confirmar o cancelar la operaci\xF3n en este sitio."
      ],
      "You need a GNU Taler Wallet": ["Necesitas una GNU Taler Wallet"],
      "If you don't have one yet you can follow the instruction in": [
        "Si no tienes una todav\xEDa puedes seguir las instrucciones en"
      ],
      "Send money": ["Enviar dinero"],
      "to a %1$s wallet": ["a una billetera %1$s"],
      "Withdraw digital money into your mobile wallet or browser extension": [
        "Extraer dinero digital a tu billetera m\xF3vil o extesi\xF3n web"
      ],
      "operation ready": ["operaci\xF3n lista"],
      "to another bank account": ["a otra cuenta bancaria"],
      "Make a wire transfer to an account with known bank account number.": [
        "Hacer una transferencia bancaria a una cuenta con un n\xFAmero de cuenta conocido."
      ],
      "Transfer details": ["Detalles de transferencia"],
      "This is a demo bank": ["Este es un banco de demostraci\xF3n"],
      "This part of the demo shows how a bank that supports Taler directly would work. In addition to using your own bank account, you can also see the transaction history of some %1$s.": [
        "Esta parte de la demostraci\xF3n muestra c\xF3mo funciona un banco que soporta Taler directamente. Adem\xE1s de usar tu propia cuenta de banco, tambi\xE9n podr\xE1s ver el historial de transacciones de algunas %1$s."
      ],
      "This part of the demo shows how a bank that supports Taler directly would work.": [
        "Esta parte de la demostraci\xF3n muetra como un banco que soporta Taler directamente funcionar\xEDa."
      ],
      "Pending account delete operation": [
        "Operaci\xF3n pendiente de eliminaci\xF3n de cuenta"
      ],
      "Pending account update operation": [
        "Operaci\xF3n pendiente de actualizaci\xF3n de cuenta"
      ],
      "Pending password update operation": [
        "Operaci\xF3n pendiente de actualizaci\xF3n de password"
      ],
      "Pending transaction operation": ["Operaci\xF3n pendiente de transacci\xF3n"],
      "Pending withdrawal operation": ["Operaci\xF3n pendiente de extracci\xF3n"],
      "Pending cashout operation": ["Operaci\xF3n pendiente de egreso"],
      "You can complete or cancel the operation in": [
        "Puedes completar o cancelar la operaci\xF3n en"
      ],
      "Download bank stats": ["Descargar estad\xEDsticas del banco"],
      "Include hour metric": ["Incluir m\xE9trica horaria"],
      "Include day metric": ["Incluir m\xE9trica diaria"],
      "Include month metric": ["Incluir m\xE9trica mensual"],
      "Include year metric": ["Incluir m\xE9trica anual"],
      "Include table header": ["Incluir encabezado de tabla"],
      "Add previous metric for compare": [
        "Agregar m\xE9trica previa para comparar"
      ],
      "Fail on first error": ["Fallar en el primer error"],
      Download: ["Descargar"],
      "downloading... %1$s": ["descargando... %1$s"],
      "Download completed": ["Descarga completada"],
      "click here to save the file in your computer": [
        "click aqu\xED para guardar el archivo en su computadora"
      ],
      "Challenge not found.": ["Desaf\xEDo no encontrado."],
      "This user is not authorized to complete this challenge.": [
        "Este usuario no est\xE1 autorizado para completar este desaf\xEDo."
      ],
      "Too many attemps, try another code.": [
        "Demasiados intentos, intente otro c\xF3digo."
      ],
      "The confirmation code is wrong, try again.": [
        "El c\xF3digo de confirmaci\xF3n es erroneo, intente otra vez."
      ],
      "The operation expired.": ["La operaci\xF3n expir\xF3."],
      "The operation failed.": ["La operaci\xF3n fall\xF3."],
      "The operation needs another confirmation to complete.": [
        "La operaci\xF3n necesita otra confirmaci\xF3n para completar."
      ],
      "Account delete": ["Eliminaci\xF3n de cuenta"],
      "Account update": ["Actualizaci\xF3n de cuenta"],
      "Password update": ["Actualizaci\xF3n de contrase\xF1a"],
      "Wire transfer": ["Transferencia bancaria"],
      Withdrawal: ["Extracci\xF3n"],
      "Confirm the operation": ["Confirmar la operaci\xF3n"],
      "Send again": ["Enviar otra vez"],
      "Send code": ["Enviar c\xF3digo"],
      "Operation details": ["Detalles de operaci\xF3n"],
      "Challenge details": ["Detalles del desaf\xEDo"],
      "Sent at": ["Enviado a"],
      "To phone": ["Al tel\xE9fono"],
      "To email": ["Al email"],
      "Welcome to %1$s!": ["Bienvenido a %1$s!"]
    }
  },
  domain: "messages",
  plural_forms: "nplurals=2; plural=n != 1;",
  lang: "es",
  completeness: 100
};
strings["en"] = {
  locale_data: {
    messages: {
      "": {
        domain: "messages",
        plural_forms: "nplurals=2; plural=(n != 1);",
        lang: "en"
      },
      "Operation failed, please report": [""],
      "Request timeout": [""],
      "Request throttled": [""],
      "Malformed response": [""],
      "Network error": [""],
      "Unexpected request error": [""],
      "Unexpected error": [""],
      "IBAN numbers usually have more that 4 digits": [""],
      "IBAN numbers usually have less that 34 digits": [""],
      "IBAN country code not found": [""],
      "IBAN number is not valid, checksum is wrong": [""],
      "Max withdrawal amount": [""],
      "Show withdrawal confirmation": [""],
      "Show demo description": [""],
      "Show install wallet first": [""],
      "Use fast withdrawal form": [""],
      "Show debug info": [""],
      "The reserve operation has been confirmed previously and can't be aborted": [""],
      "The operation id is invalid.": [""],
      "The operation was not found.": [""],
      "If you have a Taler wallet installed in this device": [""],
      "You will see the details of the operation in your wallet including the fees (if applies). If you still don't have one you can install it following instructions in": [""],
      "this page": [""],
      Withdraw: [""],
      "Or if you have the wallet in another device": [""],
      "Scan the QR below to start the withdrawal.": [""],
      required: [""],
      "IBAN should have just uppercased letters and numbers": [""],
      "not valid": [""],
      "should be greater than 0": [""],
      "balance is not enough": [""],
      "does not follow the pattern": [""],
      'only "IBAN" target are supported': [""],
      'use the "amount" parameter to specify the amount to be transferred': [
        ""
      ],
      "the amount is not valid": [""],
      'use the "message" parameter to specify a reference text for the transfer': [""],
      "The request was invalid or the payto://-URI used unacceptable features.": [""],
      "Not enough permission to complete the operation.": [""],
      'The destination account "%1$s" was not found.': [""],
      "The origin and the destination of the transfer can't be the same.": [""],
      "Your balance is not enough.": [""],
      'The origin account "%1$s" was not found.': [""],
      "Using a form": [""],
      "Import payto:// URI": [""],
      Recipient: [""],
      "IBAN of the recipient's account": [""],
      "Transfer subject": [""],
      subject: [""],
      "some text to identify the transfer": [""],
      Amount: [""],
      "amount to transfer": [""],
      "payto URI:": [""],
      "uniform resource identifier of the target account": [""],
      "payto://iban/[receiver-iban]?message=[subject]&amount=[%1$s:X.Y]": [""],
      Cancel: [""],
      Send: [""],
      "Missing username": [""],
      "Missing password": [""],
      'Wrong credentials for "%1$s"': [""],
      "Account not found": [""],
      Username: [""],
      "username of the account": [""],
      Password: [""],
      "password of the account": [""],
      Check: [""],
      "Log in": [""],
      Register: [""],
      "Wire transfer completed!": [""],
      "The withdrawal has been aborted previously and can't be confirmed": [""],
      "The withdrawal operation can't be confirmed before a wallet accepted the transaction.": [""],
      "Your balance is not enough for the operation.": [""],
      "Confirm the withdrawal operation": [""],
      "Wire transfer details": [""],
      "Taler Exchange operator's account": [""],
      "Taler Exchange operator's name": [""],
      Transfer: [""],
      "Authentication required": [""],
      "This operation was created with other username": [""],
      "Operation aborted": [""],
      "The wire transfer to the Taler Exchange operator's account was aborted, your balance was not affected.": [""],
      "You can close this page now or continue to the account page.": [""],
      Continue: [""],
      "Withdrawal confirmed": [""],
      "The wire transfer to the Taler operator has been initiated. You will soon receive the requested amount in your Taler wallet.": [""],
      Done: [""],
      "Operation canceled": [""],
      "The operation is marked as 'selected' but some step in the withdrawal failed": [""],
      "The account is selected but no withdrawal identification found.": [""],
      "There is a withdrawal identification but no account has been selected or the selected account is invalid.": [""],
      "No withdrawal ID found and no account has been selected or the selected account is invalid.": [""],
      "Operation not found": [""],
      "This operation is not known by the server. The operation id is wrong or the server deleted the operation information before reaching here.": [""],
      "Cotinue to dashboard": [""],
      "The Withdrawal URI is not valid": [""],
      'the bank backend is not supported. supported version "%1$s", server version "%2$s"': [""],
      "Internal error, please report.": [""],
      Preferences: [""],
      "Welcome, %1$s": [""],
      "Latest transactions": [""],
      Date: [""],
      Counterpart: [""],
      Subject: [""],
      sent: [""],
      received: [""],
      "invalid value": [""],
      to: [""],
      from: [""],
      "First page": [""],
      Next: [""],
      "History of public accounts": [""],
      "Currently, the bank is not accepting new registrations!": [""],
      "Missing name": [""],
      "Use letters and numbers only, and start with a lowercase letter": [""],
      "Passwords don't match": [""],
      "Server replied with invalid phone or email.": [""],
      "Registration is disabled because the bank ran out of bonus credit.": [
        ""
      ],
      "No enough permission to create that account.": [""],
      "That account id is already taken.": [""],
      "That username is already taken.": [""],
      "That username can't be used because is reserved.": [""],
      "Only admin is allow to set debt limit.": [""],
      "No information for the selected authentication channel.": [""],
      "Authentication channel is not supported.": [""],
      "Only admin can create accounts with second factor authentication.": [""],
      "Account registration": [""],
      "Repeat password": [""],
      Name: [""],
      "Create a random temporary user": [""],
      "Make a wire transfer": [""],
      "Wire transfer created!": [""],
      Accounts: [""],
      "A list of all business account in the bank.": [""],
      "Create account": [""],
      Balance: [""],
      Actions: [""],
      unknown: [""],
      "change password": [""],
      remove: [""],
      "Select a section": [""],
      "Last hour": [""],
      "Last day": [""],
      "Last month": [""],
      "Last year": [""],
      "Last Year": [""],
      "Trading volume on %1$s compared to %2$s": [""],
      Cashin: [""],
      Cashout: [""],
      Payin: [""],
      Payout: [""],
      "download stats as CSV": [""],
      "Descreased by": [""],
      "Increased by": [""],
      "Unable to create a cashout": [""],
      "The bank configuration does not support cashout operations.": [""],
      invalid: [""],
      "need to be higher due to fees": [""],
      "the total transfer at destination will be zero": [""],
      "Cashout created": [""],
      "Duplicated request detected, check if the operation succeded or try again.": [""],
      "The conversion rate was incorrectly applied": [""],
      "The account does not have sufficient funds": [""],
      "Cashouts are not supported": [""],
      "Missing cashout URI in the profile": [""],
      "Sending the confirmation message failed, retry later or contact the administrator.": [""],
      "Convertion rate": [""],
      Fee: [""],
      "To account": [""],
      "No cashout account": [""],
      "Before doing a cashout you need to complete your profile": [""],
      "Amount to send": [""],
      "Amount to receive": [""],
      "Total cost": [""],
      "Balance left": [""],
      "Before fee": [""],
      "Total cashout transfer": [""],
      "No cashout channel available": [""],
      "Before doing a cashout the server need to provide an second channel to confirm the operation": [""],
      "Second factor authentication": [""],
      Email: [""],
      "add a email in your profile to enable this option": [""],
      SMS: [""],
      "add a phone number in your profile to enable this option": [""],
      Details: [""],
      Delete: [""],
      Credentials: [""],
      Cashouts: [""],
      "it doesnt have the pattern of an IBAN number": [""],
      "it doesnt have the pattern of an email": [""],
      "should start with +": [""],
      "phone number can't have other than numbers": [""],
      "account identification in the bank": [""],
      "name of the person owner the account": [""],
      "Internal IBAN": [""],
      "if empty a random account number will be assigned": [""],
      "account identification for bank transfer": [""],
      Phone: [""],
      "Cashout IBAN": [""],
      "account number where the money is going to be sent when doing cashouts": [""],
      "Max debt": [""],
      "how much is user able to transfer after zero balance": [""],
      "Is this a Taler Exchange?": [""],
      "This server doesn't support second factor authentication.": [""],
      "Enable second factor authentication": [""],
      "Using email": [""],
      "Using SMS": [""],
      "Is this account public?": [""],
      "public accounts have their balance publicly accesible": [""],
      "Account updated": [""],
      "The rights to change the account are not sufficient": [""],
      "The username was not found": [""],
      "You can't change the legal name, please contact the your account administrator.": [""],
      "You can't change the debt limit, please contact the your account administrator.": [""],
      "You can't change the cashout address, please contact the your account administrator.": [""],
      "You can't change the contact data, please contact the your account administrator.": [""],
      'Account "%1$s"': [""],
      "Change details": [""],
      Update: [""],
      "password doesn't match": [""],
      "Password changed": [""],
      "Not authorized to change the password, maybe the session is invalid.": [
        ""
      ],
      "You need to provide the old password. If you don't have it contact your account administrator.": [""],
      "Your current password doesn't match, can't change to a new password.": [
        ""
      ],
      "Update password": [""],
      "New password": [""],
      "Type it again": [""],
      "repeat the same password": [""],
      "Current password": [""],
      "your current password, for security": [""],
      Change: [""],
      "Can't delete the account": [""],
      "The account can't be delete while still holding some balance. First make sure that the owner make a complete cashout.": [""],
      "Account removed": [""],
      "No enough permission to delete the account.": [""],
      "The username was not found.": [""],
      "Can't delete a reserved username.": [""],
      "Can't delete an account with balance different than zero.": [""],
      "name doesn't match": [""],
      "You are going to remove the account": [""],
      "This step can't be undone.": [""],
      'Deleting account "%1$s"': [""],
      Verification: [""],
      "enter the account name that is going to be deleted": [""],
      'Account created with password "%1$s". The user must change the password on the next login.': [""],
      "Server replied that phone or email is invalid": [""],
      "The rights to perform the operation are not sufficient": [""],
      "Account username is already taken": [""],
      "Account id is already taken": [""],
      "Bank ran out of bonus credit.": [""],
      "Account username can't be used because is reserved": [""],
      "Can't create accounts": [""],
      "Only system admin can create accounts.": [""],
      "New business account": [""],
      Create: [""],
      "Cashout not supported.": [""],
      "Account not found.": [""],
      "Latest cashouts": [""],
      Created: [""],
      Confirmed: [""],
      "Total debit": [""],
      "Total credit": [""],
      Status: [""],
      never: [""],
      "Cashout for account %1$s": [""],
      "This cashout not found. Maybe already aborted.": [""],
      "Cashout not found. It may be also mean that it was already aborted.": [
        ""
      ],
      "Cashout was already confimed.": [""],
      "Cashout operation is not supported.": [""],
      "The cashout operation is already aborted.": [""],
      "Missing destination account.": [""],
      "Too many failed attempts.": [""],
      "The code for this cashout is invalid.": [""],
      "Cashout detail": [""],
      Debited: [""],
      Credited: [""],
      "Enter the confirmation code": [""],
      Abort: [""],
      Confirm: [""],
      "Unauthorized to make the operation, maybe the session has expired or the password changed.": [""],
      "The operation was rejected due to insufficient funds.": [""],
      "Do not show this again": [""],
      Close: [""],
      "On this device": [""],
      'If you are using a web browser on desktop you should access your wallet with the GNU Taler WebExtension now or click the link if your WebExtension have the "Inject Taler support" option enabled.': [""],
      Start: [""],
      "On a mobile phone": [""],
      "Scan the QR code with your mobile device.": [""],
      "There is an operation already": [""],
      "Complete or cancel the operation in": [""],
      "Server responded with an invalid  withdraw URI": [""],
      "Withdraw URI: %1$s": [""],
      "The operation was rejected due to insufficient funds": [""],
      "Prepare your wallet": [""],
      "After using your wallet you will need to confirm or cancel the operation on this site.": [""],
      "You need a GNU Taler Wallet": [""],
      "If you don't have one yet you can follow the instruction in": [""],
      "Send money": [""],
      "to a %1$s wallet": [""],
      "Withdraw digital money into your mobile wallet or browser extension": [
        ""
      ],
      "operation ready": [""],
      "to another bank account": [""],
      "Make a wire transfer to an account with known bank account number.": [
        ""
      ],
      "Transfer details": [""],
      "This is a demo bank": [""],
      "This part of the demo shows how a bank that supports Taler directly would work. In addition to using your own bank account, you can also see the transaction history of some %1$s.": [""],
      "This part of the demo shows how a bank that supports Taler directly would work.": [""],
      "Pending account delete operation": [""],
      "Pending account update operation": [""],
      "Pending password update operation": [""],
      "Pending transaction operation": [""],
      "Pending withdrawal operation": [""],
      "Pending cashout operation": [""],
      "You can complete or cancel the operation in": [""],
      "Download bank stats": [""],
      "Include hour metric": [""],
      "Include day metric": [""],
      "Include month metric": [""],
      "Include year metric": [""],
      "Include table header": [""],
      "Add previous metric for compare": [""],
      "Fail on first error": [""],
      Download: [""],
      "downloading... %1$s": [""],
      "Download completed": [""],
      "click here to save the file in your computer": [""],
      "Challenge not found.": [""],
      "This user is not authorized to complete this challenge.": [""],
      "Too many attemps, try another code.": [""],
      "The confirmation code is wrong, try again.": [""],
      "The operation expired.": [""],
      "The operation failed.": [""],
      "The operation needs another confirmation to complete.": [""],
      "Account delete": [""],
      "Account update": [""],
      "Password update": [""],
      "Wire transfer": [""],
      Withdrawal: [""],
      "Confirm the operation": [""],
      "Send again": [""],
      "Send code": [""],
      "Operation details": [""],
      "Challenge details": [""],
      "Sent at": [""],
      "To phone": [""],
      "To email": [""],
      "Welcome to %1$s!": [""]
    }
  },
  domain: "messages",
  plural_forms: "nplurals=2; plural=(n != 1);",
  lang: "en",
  completeness: 100
};
strings["de"] = {
  locale_data: {
    messages: {
      "": {
        domain: "messages",
        plural_forms: "nplurals=2; plural=n != 1;",
        lang: "de"
      },
      "Operation failed, please report": [""],
      "Request timeout": [""],
      "Request throttled": [""],
      "Malformed response": [""],
      "Network error": [""],
      "Unexpected request error": [""],
      "Unexpected error": [""],
      "IBAN numbers usually have more that 4 digits": [""],
      "IBAN numbers usually have less that 34 digits": [""],
      "IBAN country code not found": [""],
      "IBAN number is not valid, checksum is wrong": [""],
      "Max withdrawal amount": [""],
      "Show withdrawal confirmation": [""],
      "Show demo description": [""],
      "Show install wallet first": [""],
      "Use fast withdrawal form": [""],
      "Show debug info": [""],
      "The reserve operation has been confirmed previously and can't be aborted": [""],
      "The operation id is invalid.": [""],
      "The operation was not found.": [""],
      "If you have a Taler wallet installed in this device": [""],
      "You will see the details of the operation in your wallet including the fees (if applies). If you still don't have one you can install it following instructions in": [""],
      "this page": [""],
      Withdraw: [""],
      "Or if you have the wallet in another device": [""],
      "Scan the QR below to start the withdrawal.": [""],
      required: [""],
      "IBAN should have just uppercased letters and numbers": [""],
      "not valid": [""],
      "should be greater than 0": [""],
      "balance is not enough": [""],
      "does not follow the pattern": [""],
      'only "IBAN" target are supported': [""],
      'use the "amount" parameter to specify the amount to be transferred': [
        ""
      ],
      "the amount is not valid": [""],
      'use the "message" parameter to specify a reference text for the transfer': [""],
      "The request was invalid or the payto://-URI used unacceptable features.": [""],
      "Not enough permission to complete the operation.": [""],
      'The destination account "%1$s" was not found.': [""],
      "The origin and the destination of the transfer can't be the same.": [""],
      "Your balance is not enough.": [""],
      'The origin account "%1$s" was not found.': [""],
      "Using a form": [""],
      "Import payto:// URI": [""],
      Recipient: [""],
      "IBAN of the recipient's account": [""],
      "Transfer subject": [""],
      subject: ["Verwendungszweck"],
      "some text to identify the transfer": [""],
      Amount: ["Betrag"],
      "amount to transfer": ["Betrag"],
      "payto URI:": [""],
      "uniform resource identifier of the target account": [""],
      "payto://iban/[receiver-iban]?message=[subject]&amount=[%1$s:X.Y]": [""],
      Cancel: [""],
      Send: [""],
      "Missing username": [""],
      "Missing password": [""],
      'Wrong credentials for "%1$s"': [""],
      "Account not found": [""],
      Username: [""],
      "username of the account": [""],
      Password: [""],
      "password of the account": ["Buchungen auf \xF6ffentlich sichtbaren Konten"],
      Check: [""],
      "Log in": [""],
      Register: [""],
      "Wire transfer completed!": [""],
      "The withdrawal has been aborted previously and can't be confirmed": [""],
      "The withdrawal operation can't be confirmed before a wallet accepted the transaction.": [""],
      "Your balance is not enough for the operation.": [""],
      "Confirm the withdrawal operation": ["Abhebung best\xE4tigen"],
      "Wire transfer details": [""],
      "Taler Exchange operator's account": [""],
      "Taler Exchange operator's name": [""],
      Transfer: [""],
      "Authentication required": [""],
      "This operation was created with other username": [""],
      "Operation aborted": [""],
      "The wire transfer to the Taler Exchange operator's account was aborted, your balance was not affected.": [""],
      "You can close this page now or continue to the account page.": [""],
      Continue: [""],
      "Withdrawal confirmed": [""],
      "The wire transfer to the Taler operator has been initiated. You will soon receive the requested amount in your Taler wallet.": [""],
      Done: [""],
      "Operation canceled": [""],
      "The operation is marked as 'selected' but some step in the withdrawal failed": [""],
      "The account is selected but no withdrawal identification found.": [""],
      "There is a withdrawal identification but no account has been selected or the selected account is invalid.": [""],
      "No withdrawal ID found and no account has been selected or the selected account is invalid.": [""],
      "Operation not found": [""],
      "This operation is not known by the server. The operation id is wrong or the server deleted the operation information before reaching here.": [""],
      "Cotinue to dashboard": [""],
      "The Withdrawal URI is not valid": [""],
      'the bank backend is not supported. supported version "%1$s", server version "%2$s"': [""],
      "Internal error, please report.": [""],
      Preferences: [""],
      "Welcome, %1$s": [""],
      "Latest transactions": [""],
      Date: ["Datum"],
      Counterpart: ["Empf\xE4nger"],
      Subject: ["Verwendungszweck"],
      sent: [""],
      received: [""],
      "invalid value": [""],
      to: [""],
      from: [""],
      "First page": [""],
      Next: [""],
      "History of public accounts": [
        "Buchungen auf \xF6ffentlich sichtbaren Konten"
      ],
      "Currently, the bank is not accepting new registrations!": [""],
      "Missing name": [""],
      "Use letters and numbers only, and start with a lowercase letter": [""],
      "Passwords don't match": [""],
      "Server replied with invalid phone or email.": [""],
      "Registration is disabled because the bank ran out of bonus credit.": [
        ""
      ],
      "No enough permission to create that account.": [""],
      "That account id is already taken.": [""],
      "That username is already taken.": [""],
      "That username can't be used because is reserved.": [""],
      "Only admin is allow to set debt limit.": [""],
      "No information for the selected authentication channel.": [""],
      "Authentication channel is not supported.": [""],
      "Only admin can create accounts with second factor authentication.": [""],
      "Account registration": [""],
      "Repeat password": [""],
      Name: [""],
      "Create a random temporary user": [""],
      "Make a wire transfer": [""],
      "Wire transfer created!": [""],
      Accounts: ["Betrag"],
      "A list of all business account in the bank.": [""],
      "Create account": [""],
      Balance: [""],
      Actions: [""],
      unknown: [""],
      "change password": [""],
      remove: [""],
      "Select a section": [""],
      "Last hour": [""],
      "Last day": [""],
      "Last month": [""],
      "Last year": [""],
      "Last Year": [""],
      "Trading volume on %1$s compared to %2$s": [""],
      Cashin: [""],
      Cashout: [""],
      Payin: [""],
      Payout: [""],
      "download stats as CSV": [""],
      "Descreased by": [""],
      "Increased by": [""],
      "Unable to create a cashout": [""],
      "The bank configuration does not support cashout operations.": [""],
      invalid: [""],
      "need to be higher due to fees": [""],
      "the total transfer at destination will be zero": [""],
      "Cashout created": [""],
      "Duplicated request detected, check if the operation succeded or try again.": [""],
      "The conversion rate was incorrectly applied": [""],
      "The account does not have sufficient funds": [""],
      "Cashouts are not supported": [""],
      "Missing cashout URI in the profile": [""],
      "Sending the confirmation message failed, retry later or contact the administrator.": [""],
      "Convertion rate": [""],
      Fee: [""],
      "To account": [""],
      "No cashout account": [""],
      "Before doing a cashout you need to complete your profile": [""],
      "Amount to send": ["Betrag"],
      "Amount to receive": [""],
      "Total cost": [""],
      "Balance left": [""],
      "Before fee": [""],
      "Total cashout transfer": [""],
      "No cashout channel available": [""],
      "Before doing a cashout the server need to provide an second channel to confirm the operation": [""],
      "Second factor authentication": [""],
      Email: [""],
      "add a email in your profile to enable this option": [""],
      SMS: [""],
      "add a phone number in your profile to enable this option": [""],
      Details: [""],
      Delete: [""],
      Credentials: [""],
      Cashouts: [""],
      "it doesnt have the pattern of an IBAN number": [""],
      "it doesnt have the pattern of an email": [""],
      "should start with +": [""],
      "phone number can't have other than numbers": [""],
      "account identification in the bank": [""],
      "name of the person owner the account": [""],
      "Internal IBAN": [""],
      "if empty a random account number will be assigned": [""],
      "account identification for bank transfer": [""],
      Phone: [""],
      "Cashout IBAN": [""],
      "account number where the money is going to be sent when doing cashouts": [""],
      "Max debt": [""],
      "how much is user able to transfer after zero balance": [""],
      "Is this a Taler Exchange?": [""],
      "This server doesn't support second factor authentication.": [""],
      "Enable second factor authentication": [""],
      "Using email": [""],
      "Using SMS": [""],
      "Is this account public?": [""],
      "public accounts have their balance publicly accesible": [""],
      "Account updated": [""],
      "The rights to change the account are not sufficient": [""],
      "The username was not found": [""],
      "You can't change the legal name, please contact the your account administrator.": [""],
      "You can't change the debt limit, please contact the your account administrator.": [""],
      "You can't change the cashout address, please contact the your account administrator.": [""],
      "You can't change the contact data, please contact the your account administrator.": [""],
      'Account "%1$s"': [""],
      "Change details": [""],
      Update: [""],
      "password doesn't match": [""],
      "Password changed": [""],
      "Not authorized to change the password, maybe the session is invalid.": [
        ""
      ],
      "You need to provide the old password. If you don't have it contact your account administrator.": [""],
      "Your current password doesn't match, can't change to a new password.": [
        ""
      ],
      "Update password": [""],
      "New password": [""],
      "Type it again": [""],
      "repeat the same password": [""],
      "Current password": [""],
      "your current password, for security": [""],
      Change: [""],
      "Can't delete the account": [""],
      "The account can't be delete while still holding some balance. First make sure that the owner make a complete cashout.": [""],
      "Account removed": [""],
      "No enough permission to delete the account.": [""],
      "The username was not found.": [""],
      "Can't delete a reserved username.": [""],
      "Can't delete an account with balance different than zero.": [""],
      "name doesn't match": [""],
      "You are going to remove the account": [""],
      "This step can't be undone.": [""],
      'Deleting account "%1$s"': [""],
      Verification: [""],
      "enter the account name that is going to be deleted": [""],
      'Account created with password "%1$s". The user must change the password on the next login.': [""],
      "Server replied that phone or email is invalid": [""],
      "The rights to perform the operation are not sufficient": [""],
      "Account username is already taken": [""],
      "Account id is already taken": [""],
      "Bank ran out of bonus credit.": [""],
      "Account username can't be used because is reserved": [""],
      "Can't create accounts": [""],
      "Only system admin can create accounts.": [""],
      "New business account": [""],
      Create: [""],
      "Cashout not supported.": [""],
      "Account not found.": [""],
      "Latest cashouts": [""],
      Created: [""],
      Confirmed: ["Best\xE4tigen"],
      "Total debit": [""],
      "Total credit": [""],
      Status: [""],
      never: [""],
      "Cashout for account %1$s": [""],
      "This cashout not found. Maybe already aborted.": [""],
      "Cashout not found. It may be also mean that it was already aborted.": [
        ""
      ],
      "Cashout was already confimed.": [""],
      "Cashout operation is not supported.": [""],
      "The cashout operation is already aborted.": [""],
      "Missing destination account.": [""],
      "Too many failed attempts.": [""],
      "The code for this cashout is invalid.": [""],
      "Cashout detail": [""],
      Debited: [""],
      Credited: [""],
      "Enter the confirmation code": [""],
      Abort: [""],
      Confirm: ["Best\xE4tigen"],
      "Unauthorized to make the operation, maybe the session has expired or the password changed.": [""],
      "The operation was rejected due to insufficient funds.": [""],
      "Do not show this again": [""],
      Close: [""],
      "On this device": [""],
      'If you are using a web browser on desktop you should access your wallet with the GNU Taler WebExtension now or click the link if your WebExtension have the "Inject Taler support" option enabled.': [""],
      Start: [""],
      "On a mobile phone": [""],
      "Scan the QR code with your mobile device.": [""],
      "There is an operation already": [""],
      "Complete or cancel the operation in": ["Abhebung best\xE4tigen"],
      "Server responded with an invalid  withdraw URI": [""],
      "Withdraw URI: %1$s": [""],
      "The operation was rejected due to insufficient funds": [""],
      "Prepare your wallet": [""],
      "After using your wallet you will need to confirm or cancel the operation on this site.": [""],
      "You need a GNU Taler Wallet": [""],
      "If you don't have one yet you can follow the instruction in": [""],
      "Send money": [""],
      "to a %1$s wallet": [""],
      "Withdraw digital money into your mobile wallet or browser extension": [
        ""
      ],
      "operation ready": [""],
      "to another bank account": [""],
      "Make a wire transfer to an account with known bank account number.": [
        ""
      ],
      "Transfer details": [""],
      "This is a demo bank": [""],
      "This part of the demo shows how a bank that supports Taler directly would work. In addition to using your own bank account, you can also see the transaction history of some %1$s.": [""],
      "This part of the demo shows how a bank that supports Taler directly would work.": [""],
      "Pending account delete operation": [""],
      "Pending account update operation": [""],
      "Pending password update operation": [""],
      "Pending transaction operation": [""],
      "Pending withdrawal operation": [""],
      "Pending cashout operation": [""],
      "You can complete or cancel the operation in": [""],
      "Download bank stats": [""],
      "Include hour metric": [""],
      "Include day metric": [""],
      "Include month metric": [""],
      "Include year metric": [""],
      "Include table header": [""],
      "Add previous metric for compare": [""],
      "Fail on first error": [""],
      Download: [""],
      "downloading... %1$s": [""],
      "Download completed": [""],
      "click here to save the file in your computer": [""],
      "Challenge not found.": [""],
      "This user is not authorized to complete this challenge.": [""],
      "Too many attemps, try another code.": [""],
      "The confirmation code is wrong, try again.": [""],
      "The operation expired.": [""],
      "The operation failed.": [""],
      "The operation needs another confirmation to complete.": [""],
      "Account delete": [""],
      "Account update": [""],
      "Password update": [""],
      "Wire transfer": [""],
      Withdrawal: ["Abhebung best\xE4tigen"],
      "Confirm the operation": ["Abhebung best\xE4tigen"],
      "Send again": [""],
      "Send code": [""],
      "Operation details": [""],
      "Challenge details": [""],
      "Sent at": [""],
      "To phone": [""],
      "To email": [""],
      "Welcome to %1$s!": [""]
    }
  },
  domain: "messages",
  plural_forms: "nplurals=2; plural=n != 1;",
  lang: "de",
  completeness: 4
};

// src/settings.ts
var defaultSettings = {
  backendBaseURL: buildDefaultBackendBaseURL(),
  iconLinkURL: void 0,
  simplePasswordForRandomAccounts: false,
  allowRandomAccountCreation: false,
  topNavSites: {}
};
var codecForAppUiSettings = () => buildCodecForObject2().property("backendBaseURL", codecOptional2(codecForString2())).property("allowRandomAccountCreation", codecOptional2(codecForBoolean2())).property(
  "simplePasswordForRandomAccounts",
  codecOptional2(codecForBoolean2())
).property("iconLinkURL", codecOptional2(codecForString2())).property("topNavSites", codecOptional2(codecForMap2(codecForString2()))).build("AppUiSettings");
function removeUndefineField(obj) {
  const keys = Object.keys(obj);
  return keys.reduce((prev, cur) => {
    if (typeof prev[cur] === "undefined") {
      delete prev[cur];
    }
    return prev;
  }, obj);
}
function fetchSettings(listener) {
  fetch("./settings.json").then((resp) => resp.json()).then((json) => codecForAppUiSettings().decode(json)).then(
    (result) => listener({
      ...defaultSettings,
      ...removeUndefineField(result)
    })
  ).catch((e3) => {
    console.log("failed to fetch settings", e3);
    listener(defaultSettings);
  });
}
function buildDefaultBackendBaseURL() {
  if (typeof window !== "undefined") {
    const currentLocation = new URL(
      window.location.pathname,
      window.location.origin
    ).href;
    return canonicalizeBaseUrl2(currentLocation.replace("/webui", ""));
  }
  throw Error("No default URL");
}

// src/app.tsx
var WITH_LOCAL_STORAGE_CACHE = false;
function App() {
  const [settings, setSettings] = p3();
  h2(() => {
    fetchSettings(setSettings);
  }, []);
  if (!settings)
    return /* @__PURE__ */ h(Loading, null);
  return /* @__PURE__ */ h(SettingsProvider, { value: settings }, /* @__PURE__ */ h(
    TranslationProvider,
    {
      source: strings,
      completeness: {
        es: strings["es"].completeness,
        de: strings["de"].completeness
      }
    },
    /* @__PURE__ */ h(
      SWRConfig2,
      {
        value: {
          provider: WITH_LOCAL_STORAGE_CACHE ? localStorageProvider : void 0,
          // normally, do not revalidate
          revalidateOnFocus: false,
          revalidateOnReconnect: false,
          revalidateIfStale: false,
          revalidateOnMount: void 0,
          focusThrottleInterval: void 0,
          // normally, do not refresh
          refreshInterval: void 0,
          dedupingInterval: 2e3,
          refreshWhenHidden: false,
          refreshWhenOffline: false,
          // ignore errors
          shouldRetryOnError: false,
          errorRetryCount: 0,
          errorRetryInterval: void 0,
          // do not go to loading again if already has data
          keepPreviousData: true
        }
      },
      /* @__PURE__ */ h(TalerWalletIntegrationBrowserProvider, null, /* @__PURE__ */ h(BrowserHashNavigationProvider, null, /* @__PURE__ */ h(Routing, null)))
    )
  ));
}
function localStorageProvider() {
  const map4 = new Map(JSON.parse(localStorage.getItem("app-cache") || "[]"));
  window.addEventListener("beforeunload", () => {
    const appCache = JSON.stringify(Array.from(map4.entries()));
    localStorage.setItem("app-cache", appCache);
  });
  return map4;
}

// src/index.tsx
init_preact_module();
var app = document.getElementById("app");
if (app) {
  P(/* @__PURE__ */ h(App, null), app);
} else {
  console.error("HTML element with id 'app' not found.");
}
/*! Bundled license information:

jed/jed.js:
  (**
   * @preserve jed.js https://github.com/SlexAxton/Jed
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.js.map
